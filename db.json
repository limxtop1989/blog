{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"fcf23f77224ea9f1b8afaf2f336ef22c02efd6c8","modified":1633598177468},{"_id":"source/_posts/.DS_Store","hash":"6f9be16fc84a3ecdf3654e551ef509e45f901adb","modified":1629463860965},{"_id":"source/_posts/activity-transfer-detection.md","hash":"cd79bba92056e670e54f8b6d4e2bd0d1d2e1713d","modified":1626661799595},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1626418027924},{"_id":"source/_posts/activity-transfer-detection/app_flow_chart.png","hash":"a762043d313d9bafcd04ae3f94297bcdda0d29b6","modified":1626525196692},{"_id":"source/_posts/activity-transfer-detection/sequence_of_lifecycle_method_for_starting_activity.png","hash":"71dd1bad66777eee6e0fbff606058759d456bae5","modified":1626525210486},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1626576575259},{"_id":"themes/butterfly/README.md","hash":"cedd13fcd8c75a68742265dd8eced4087e940ffd","modified":1626576575259},{"_id":"themes/butterfly/_config.yml","hash":"4eabe9cbad125367d36d43137fdbd8327205cc44","modified":1626576575260},{"_id":"themes/butterfly/README_CN.md","hash":"459d6f3200863021bee1fe72a719aef236fb4090","modified":1626576575259},{"_id":"themes/butterfly/package.json","hash":"c0d62352ca336c5322fdf5e45d756779c10bdaea","modified":1626576575273},{"_id":"themes/butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1626576575259},{"_id":"themes/butterfly/languages/default.yml","hash":"7ca673fb629ea74f5ba5e75b4f0f95248cfb5090","modified":1626576575260},{"_id":"themes/butterfly/languages/en.yml","hash":"cd333235ff1648a6bf58dfafc81f2c57672a15a5","modified":1626576575260},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"741e522b2387f94764a73844e7b084cc7e927c54","modified":1626576575260},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"79a50c40d9f5463f1fa42aa870ac6b8b84540412","modified":1626576575260},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1626576575260},{"_id":"themes/butterfly/layout/category.pug","hash":"60c1b795b6e227b5dd81963b51d29d1b81d0bf49","modified":1626576575261},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1626576575272},{"_id":"themes/butterfly/layout/page.pug","hash":"82aa988527a11835e7ac86ce4f23b8cd20014dfa","modified":1626576575273},{"_id":"themes/butterfly/layout/post.pug","hash":"8d398c8925182699d9f2b9f1b727f06228488312","modified":1626576575273},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1626576575273},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":1626576575259},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1626576575259},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1626576575259},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1626576575259},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"7d378e328a53cc99d5acc9682dce53f5eb61537d","modified":1626576575261},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"4156224c47bfc2482281ac4e4df701c30476ff00","modified":1626576575261},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1626576575261},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"1377952022ee0a9eaa7a2fd1098f1571efc468d9","modified":1626576575261},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"6f2608c4d93d3d10ae6b2cd7f8918f303f024321","modified":1626576575264},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1626576575265},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"2d0453adf92a3fd3466cf0793f14685d17b8b51d","modified":1626576575265},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"8dafc2dcd8c33f70a546fee443f0b6d80b3cd243","modified":1626576575265},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1626576575273},{"_id":"themes/butterfly/scripts/events/init.js","hash":"018aa446265fe627301b1d53d7cba4f4ff1960ac","modified":1626576575273},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":1626576575273},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"4cc2d517195c8779471d326ada09f9371cbad4dd","modified":1626576575273},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"9821872007cf57efae4b728dc575ef9d004547bb","modified":1626576575274},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1626576575274},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1626576575274},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"65f2442e04c4defd16e7c1e67701d3bb41d9577a","modified":1626576575274},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":1626576575274},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"54b9324e3506dcc9c9991ef5e11e37e66e21594f","modified":1626576575274},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"b816ded1451f28c7c54151ffe6c259b110253ae3","modified":1626576575274},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"94826ea6bcc4d2304199adae12c4e2b272caf529","modified":1626576575275},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"f33858ffb9e88191e644796e11d2f901eb332308","modified":1626576575275},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1626576575275},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1626576575275},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"35f073021db93699fcac9ef351e26c59c31aadf7","modified":1626576575275},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1626576575275},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1626576575275},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1626576575283},{"_id":"themes/butterfly/source/css/var.styl","hash":"4b7ba48942bc25244d155333c3657f5c1448addf","modified":1626576575283},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1626576575283},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1626576575283},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1626576575283},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1626576575284},{"_id":"themes/butterfly/source/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1626576575284},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1626576575285},{"_id":"themes/butterfly/source/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1626576575285},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1626576575261},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"90d01b88d0f406d00184960b1afe9230aec2ebe6","modified":1626576575262},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"4def0aab9e2172ad1f29abd1535d8e08ff23aa0b","modified":1626576575262},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"889ef16fa34a39e5533bc170e62f20f3450cc522","modified":1626576575262},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1626576575262},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1626576575262},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"e55f8bdb876d5429a908498db1307b94094c0d06","modified":1626576575262},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1626576575263},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1626576575263},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":1626576575263},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"24370508ee87f14418e8f06e9d79ad8c52a342c4","modified":1626576575263},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"c205b9fd72b2fe19e6d15c5b5ab0fb38c653032e","modified":1626576575263},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"92f81a437c9db49f7ebcf608bc09488ecdb55a21","modified":1626576575263},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1626576575264},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1626576575264},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1626576575264},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1626576575264},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"4c3c5cb69b3aead8c232cb0fbc251929f28aad75","modified":1626576575264},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"1f30952fed73dec21b42e2e30b7fe2e84618d2e4","modified":1626576575264},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"dbec869c62135695495703a29ad7655e9965d461","modified":1626576575264},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"b53a2d4f9c37b375a4446d2273dcfb7712d91b3e","modified":1626576575265},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"93d4ebc7dc8228c7a10ddeb5a553d0dcdabbe145","modified":1626576575265},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1626576575265},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"5b404356f311d2ee36478291ca3553210867b738","modified":1626576575265},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":1626576575265},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":1626576575268},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":1626576575270},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"933cb710d2dbcea25c6426a57c6f49d2f48b792c","modified":1626576575270},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1626576575270},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"d50e5c22cd6bc3c378bc581918136746cfa3447f","modified":1626576575271},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1626576575271},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"3d8e3706a056389176f55dd21956aabc78046761","modified":1626576575271},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1626576575271},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"0366c658cdcff839aa1df2e2d252a03a53fd427e","modified":1626576575271},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1626576575271},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1626576575272},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"27afd2274bd5f2cbbf1bad9f0afe2b2b72c213ca","modified":1626576575272},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"ae9336bf31cdad08ff586ead4295912a96563c76","modified":1626576575272},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1626576575272},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1626576575272},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1626576575272},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1626576575272},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"b5525891f6affd02c1ea3b2327c026882efe428b","modified":1626576575272},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"eda47f3e807a466ba8275627ea936c5100c43818","modified":1626576575276},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"e211efbd1952d4b1b881287aa43423133c1d166e","modified":1626576575276},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"85e72c70a0cef29e40be1968f5d23b06c6f8e3aa","modified":1626576575276},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"fa7a4c1685f391d60ed863e869b9604b59746c27","modified":1626576575277},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"7feb755ca7c22da36bbad11e74ecd95fdcf3b879","modified":1626576575277},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1626576575277},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"f1b63892baafa48ab872bc79671d57aafd511f6c","modified":1626576575277},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"dd8cdf639ba2b726437c77fa7aa8d5edbabe8f9b","modified":1626576575277},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"950cc2afb5c0be5bfc192dc68a2c30c8acfbde95","modified":1626576575277},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":1626576575278},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"90fe01c968696a9f791cb2b84fca621cbbb56f47","modified":1626576575278},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"d748951d9fbcd04dda839085af78b01b8fa04cba","modified":1626576575279},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"0551c5893d1589a3d17ce161e50ecb1d724cc6e8","modified":1626576575279},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"ea1ba40dd5954c2ed718a126336fb7f94da4e66f","modified":1626576575279},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"7a072589e6097dbe942783131964f2372fdf1eb6","modified":1626576575279},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"2c5fb77c448ce0a734040c8ce532b28fed688899","modified":1626576575279},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"978c397d0966eaf9e6e2afd13866f8f4900b509f","modified":1626576575279},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"4e629f510b73f998ab208b739c5bd7dcd168d1a7","modified":1626576575280},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"f59a9a0059d5261251bdd6de45aa97dd2d11e633","modified":1626576575280},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"b0488ceacde74af139d66c8db5cb36cc21737b9b","modified":1626576575280},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":1626576575280},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"e554549f0a0ae85362f0b0e8687981741f486f6b","modified":1626576575280},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"90d1ce76b0486ede809bc3b5d4935c22ee376c91","modified":1626576575280},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"2cc49d3f6a6beb9f7bff93e292f88aa5681da1d0","modified":1626576575281},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"7c4152162a03aa8331a783df5695e4ebbb816a8c","modified":1626576575281},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9a881c031f463c486bd25248c2814fd09f97892b","modified":1626576575281},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"f168f5c669978f633abe118cdcc4a12cfc883c01","modified":1626576575281},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"917e0e399e117217184ca63d3eb5c4843bcccf7b","modified":1626576575281},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"6befe4c51b86d0c1de130beeecad9e28d6442713","modified":1626576575281},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"1c3f9d7efc3b9dfcfa8926a1132d0c44ffc7d4b2","modified":1626576575281},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"53ecae272e16223a436c497abbf25dd5f0fc4aaa","modified":1626576575282},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":1626576575282},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1626576575282},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"21964fdd6d74ffbea519418bab65024aee5f3736","modified":1626576575282},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"f741e85295ce15c70a6027ec15a542636dd5dcca","modified":1626576575282},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"86fee274a62f7f034547342930f445c47378eb55","modified":1626576575282},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":1626576575282},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1626576575282},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1626576575284},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1626576575284},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1626576575266},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":1626576575266},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1626576575266},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"400ce038548d6f9ddb486150c724c87b6923a88b","modified":1626576575266},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":1626576575266},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1626576575266},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1626576575266},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1626576575267},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1626576575266},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1626576575267},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1626576575266},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1626576575267},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1626576575267},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0b7571919e8ad51285deda56a1868fccf8c563d7","modified":1626576575267},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"da9813f8dc0d388869c15413cf056012cfb69e1a","modified":1626576575267},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"2e52c64e89f16267596a8465841dd46f51820982","modified":1626576575267},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"c46a932257212f82e4a9974fbbc5de8878c8b383","modified":1626576575267},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"bafb3d5710824caa59a56017afb058fd2b4eac65","modified":1626576575267},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1626576575268},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"16378d8646ea3f4ac99c18f0296dd85b13f9d775","modified":1626576575268},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":1626576575268},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"2b45fe09d5b591dca156b76dae99981f8d8e1c61","modified":1626576575268},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"360845d02c3864975349ae60b3d0c68253ca001c","modified":1626576575268},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1626576575268},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f9b00ead54573ba6e6eb33481588af144aab648d","modified":1626576575269},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"a47d8f9f593091cc91192c0c49deaa2c0d2317fd","modified":1626576575269},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"3f3a3cd8bea2103dedd754f767aca5cb84d5f586","modified":1626576575269},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"b443d6b16baf3ea250041342cc0361a42a412b7f","modified":1626576575269},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"34088a15655704d12e9b1807b47b3f6a860c9eec","modified":1626576575269},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"59b4c26a827ace5a54855881d199977103ff6f50","modified":1626576575269},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":1626576575269},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"cb38ffe911023092a90a28f2ba8317a92b22cd0c","modified":1626576575269},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"a2bc2601b7e0ae5caf1fc51a07390562d928620a","modified":1626576575270},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"d8f59e94eafc669c49349561dc5bbea3915aecb7","modified":1626576575270},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"613280d61b8ab9612014ec016ae3d3698d36fd1a","modified":1626576575270},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1626576575270},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1626576575270},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1626576575270},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1626576575271},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":1626576575271},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"8c0726fb8d9a497d2f900b0be2845efaa68e3d87","modified":1626576575276},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"89cbcc8e087788ecec18b5fa58710afacdb7d080","modified":1626576575276},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1626576575276},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"e0e7065124ef0d99f8322a47bc47838982e04ad0","modified":1626576575276},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1626576575277},{"_id":"public/archives/index.html","hash":"3c13ac8b81fe92ad09abd669516e3fec29227df1","modified":1644891915683},{"_id":"public/archives/2021/index.html","hash":"8a5930a2a07a50b6bb7e89ff89eb4b82f4a7c08e","modified":1644891915683},{"_id":"public/archives/2021/07/index.html","hash":"aef17fd1071ff2210bec6df102a8bb36de34c0f1","modified":1644891915683},{"_id":"public/index.html","hash":"ea6660cefec3db38601447b0583a9079abecaac1","modified":1644891915683},{"_id":"public/2021/07/17/activity-transfer-detection/index.html","hash":"e1a8cba7e6204c181d7e1add7e67a8d66c1b43c6","modified":1644843775563},{"_id":"public/2021/07/16/hello-world/index.html","hash":"854a5cdfc067ce3724101c4113efe974f78cf5e9","modified":1632050445292},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1626579118820},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1626579118820},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1626579118820},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1626579118820},{"_id":"public/2021/07/17/activity-transfer-detection/app_flow_chart.png","hash":"a762043d313d9bafcd04ae3f94297bcdda0d29b6","modified":1626579118820},{"_id":"public/2021/07/17/activity-transfer-detection/sequence_of_lifecycle_method_for_starting_activity.png","hash":"71dd1bad66777eee6e0fbff606058759d456bae5","modified":1626579118820},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626579118820},{"_id":"public/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1626579118820},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1626579118820},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1626579118820},{"_id":"public/css/index.css","hash":"43a3e4279c34ed3542b557ecb49a9681ec61119f","modified":1626579118820},{"_id":"public/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1626579118820},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1626579118820},{"_id":"source/_posts/English-introduction2.md","hash":"f6408791f25f0a5375814499dd947714448a48c7","modified":1629292695598},{"_id":"source/_posts/English-introduction.md","hash":"e250a283cb709a1d1a77a660d5d1cb75ac5caf7f","modified":1644833571331},{"_id":"source/_posts/English-introduction/455c9a21-0451-4256-94cc-3b79cec2d58a.webp","hash":"8c0eb4027b1a553cf5399bd9a07e8bc2d5b1f69b","modified":1629291708089},{"_id":"source/_posts/English-introduction/3d2515cb-3f1b-4fb0-bf37-d4235478d34a.webp","hash":"f2c8465a088414e3ca8ea8d6593a61879a93e590","modified":1629291745095},{"_id":"source/_posts/English-introduction/743839ae-8b54-43af-94a3-1efaa17dc711.webp","hash":"d73f8d2e10217a2442ee57d86faba4d7da2bf047","modified":1629291737199},{"_id":"source/_posts/english-introduction2/455c9a21-0451-4256-94cc-3b79cec2d58a.webp","hash":"8c0eb4027b1a553cf5399bd9a07e8bc2d5b1f69b","modified":1629291708089},{"_id":"source/_posts/english-introduction2/743839ae-8b54-43af-94a3-1efaa17dc711.webp","hash":"d73f8d2e10217a2442ee57d86faba4d7da2bf047","modified":1629291737199},{"_id":"source/_posts/english-introduction2/3d2515cb-3f1b-4fb0-bf37-d4235478d34a.webp","hash":"f2c8465a088414e3ca8ea8d6593a61879a93e590","modified":1629291745095},{"_id":"source/_posts/English-introduction/9cbef091-ff03-487e-99d3-a638cab03662.webp","hash":"ef45c54bcbfc98d05c05c7d546a15b328ef8863f","modified":1629291731834},{"_id":"source/_posts/english-introduction2/9cbef091-ff03-487e-99d3-a638cab03662.webp","hash":"ef45c54bcbfc98d05c05c7d546a15b328ef8863f","modified":1629291731834},{"_id":"public/archives/2021/08/index.html","hash":"eaf3050a27e475ad79df85af762cfec02cdd793d","modified":1644891915683},{"_id":"public/2021/08/18/English-introduction/index.html","hash":"276ff203aef8e27f91e970bacecd0481e7acc2ba","modified":1644843775563},{"_id":"public/2021/08/18/English-introduction2/index.html","hash":"4c5f04b3a3e73b01a01222252ebc74fa4ee3b348","modified":1629293455820},{"_id":"public/2021/08/18/English-introduction/3d2515cb-3f1b-4fb0-bf37-d4235478d34a.webp","hash":"f2c8465a088414e3ca8ea8d6593a61879a93e590","modified":1629293455820},{"_id":"public/2021/08/18/English-introduction/455c9a21-0451-4256-94cc-3b79cec2d58a.webp","hash":"8c0eb4027b1a553cf5399bd9a07e8bc2d5b1f69b","modified":1629293455820},{"_id":"public/2021/08/18/English-introduction/743839ae-8b54-43af-94a3-1efaa17dc711.webp","hash":"d73f8d2e10217a2442ee57d86faba4d7da2bf047","modified":1629293455820},{"_id":"public/2021/08/18/English-introduction2/455c9a21-0451-4256-94cc-3b79cec2d58a.webp","hash":"8c0eb4027b1a553cf5399bd9a07e8bc2d5b1f69b","modified":1629293455820},{"_id":"public/2021/08/18/English-introduction2/743839ae-8b54-43af-94a3-1efaa17dc711.webp","hash":"d73f8d2e10217a2442ee57d86faba4d7da2bf047","modified":1629293455820},{"_id":"public/2021/08/18/English-introduction2/3d2515cb-3f1b-4fb0-bf37-d4235478d34a.webp","hash":"f2c8465a088414e3ca8ea8d6593a61879a93e590","modified":1629293455820},{"_id":"public/2021/08/18/English-introduction/9cbef091-ff03-487e-99d3-a638cab03662.webp","hash":"ef45c54bcbfc98d05c05c7d546a15b328ef8863f","modified":1629293455820},{"_id":"public/2021/08/18/English-introduction2/9cbef091-ff03-487e-99d3-a638cab03662.webp","hash":"ef45c54bcbfc98d05c05c7d546a15b328ef8863f","modified":1629293455820},{"_id":"source/_drafts/Control-title-in-CollapsingToolbarLayout.md","hash":"26d12e250a9977f2d47ce8ecdfe30e6e2c69d7e7","modified":1630395078724},{"_id":"public/tags/英语-自学-入门-指南-方法论-词典/index.html","hash":"e02de85a8fd4a04278ef60d06bf423c3a6355887","modified":1644891915683},{"_id":"source/_posts/FragmentManager源码剖析.md","hash":"7f01ca22dd7d7c6f15dbf7789cb039ad1030ac76","modified":1631800507609},{"_id":"source/_drafts/Android-TouchEvent-源码剖析.md","hash":"72bdb85477bc34e1945dc18f4b3773bf70c8d40c","modified":1630395292870},{"_id":"source/_drafts/RxJava线程调度源码剖析.md","hash":"f270769c8c0abc156c68841ff83adc26c8ebd02d","modified":1630395203115},{"_id":"source/_drafts/ViewModel-LiveData-源码剖析.md","hash":"834fb7fad5eda7b53451a87285ef7c8feb81c11d","modified":1630394008550},{"_id":"public/archives/2021/09/index.html","hash":"64ef790ccab238839baccbb30d406ea522fee9e5","modified":1644891915683},{"_id":"public/tags/Fragment-FragmentManager源码/index.html","hash":"6ed496fc53f8f2c243a2893bfccfc060ec0e28c7","modified":1632053768892},{"_id":"public/2021/09/16/FragmentManager源码剖析/index.html","hash":"1ba355b43727a7c97631a61465db02b1b1e05dd4","modified":1632050445292},{"_id":"source/_posts/ViewModel源码剖析.md","hash":"1f373359bd9749a5c20053fee3f780eb3ddc8e7c","modified":1644891672912},{"_id":"public/tags/ViewModel源码剖析-Android-ViewModel/index.html","hash":"94ec04b1f3179fc4a93cff1a8f264feffb4abda9","modified":1644891915683},{"_id":"public/2021/09/19/ViewModel源码剖析/index.html","hash":"eee8794e3cb29a7b856cb8e98e3f1dc7d52d85f5","modified":1644891915683},{"_id":"source/_posts/FragmentManager源码剖析1.md","hash":"d8f2d2c2b0ebdd0e249221531fd4977584cd78c3","modified":1634563859937},{"_id":"public/archives/2021/10/index.html","hash":"68f7f261d847910654de6e277dd7e84539fe44b7","modified":1644891915683},{"_id":"public/2021/10/18/FragmentManager源码剖析1/index.html","hash":"101bea12c934b8229ba77c8151e43fe1bb28e159","modified":1644843775563},{"_id":"source/_posts/FragmentManager源码剖析2.md","hash":"38377028a25b3f90191920208a8ad96425d03168","modified":1634563733631},{"_id":"public/2021/10/18/FragmentManager源码剖析2/index.html","hash":"e92a7e80c4b72e6ff2a4a663a1935e506aa327d3","modified":1644843775563},{"_id":"source/_drafts/.DS_Store","hash":"ab2c0e8ffb4f84d58bb7c1c62569233c13edd57f","modified":1634611007489},{"_id":"source/_posts/LifeCycle-LiveData源码剖析.md","hash":"4f6aad7e427d89c19bd63680894930f460c258e1","modified":1644891911509},{"_id":"public/2022/02/14/LifeCycle-LiveData源码剖析/index.html","hash":"ba00de988dc11c623ea2614acc9c2ac086f0b08e","modified":1644891915683},{"_id":"public/archives/2022/index.html","hash":"cb9aa5b116ab8de8def9bab8bc9c4dfd48180905","modified":1644891915683},{"_id":"public/archives/2022/02/index.html","hash":"6d23891d31f8a2001fe71b751e2d077cd08c82f8","modified":1644891915683},{"_id":"public/tags/LifeCycle-LiveData/index.html","hash":"c8a0d35cb7baf77fc76cc182c0af5191a999021c","modified":1644891915683}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Android Activity 转移类型检测","date":"2021-07-17T12:26:30.000Z","_content":"\nRequirement:：\n\n应用内有些Activity数据敏感，需要区别对待，这里需要识别首次进入红色Activity集合内，在红色Activity集合内跳转，和跳出红色Activity集合三种情况。【当红色Activity集合是应用内的Activity集合时，就相当于首次进入应用，应用内界面跳转和退出应用的判定】\n\n[![W1aZWR.png](https://z3.ax1x.com/2021/07/17/W1aZWR.png)](https://imgtu.com/i/W1aZWR)\n\n算法描述：\n\n1. 定义一个保存Activity Simple Name的集合。\n\n2. Activity onResume时，将此Activity Simple Name加入集合。\n\n3. 1. 当集合元素个数等于**1**时，为首次进入该应用打开的第一个Activity。\n   2. 当集合元素个数等于**2**时，表示打开应用内的其他Activity。\n\n4. Activity onStop时，将此Activity Simple Name移出集合。\n\n5. 1. 当集合元素个数为**1**时，表示在应用内跳转。\n   2. 当集合元素个数为**0**时，表示打开其他应用。\n\n\n\n原理：\n\n[![W1aVY9.png](https://z3.ax1x.com/2021/07/17/W1aVY9.png)](https://imgtu.com/i/W1aVY9)\n\n\n\n由上图可知，Activity A启动Activity B时，执行顺序是Activity A's onPause() -> Activity B's onResume() -> Activity A's onStop()。应用内的Activity在执行 onResume() & onStop()时，我们规约将其Activity Simple Name加入&移出集合，而启动应用外的Activity我们没有能力如此操作。\n\n1. 首次进入Activity集合，应用内的Activity onResume被调用；\n2. 在Activity集合间跳转，应用内的Activity onResume & onStop被调用；\n3. 跳出Activity集合，应用内的Activity onStop 被调用；\n\n\n\n所以，启动应用内还是应用外的Activity在此产生差异，而差异让程序识别成为可能。\n\n1. 当Activity B是**应用内Activity**时，集合内元素个数变迁如下：\n\n   Activity A's onPause() -> Activity B's onResume() -> Activity A's onStop()\n\n   **1**（Activity A）         **2**（Activity A&B）        **1**（Activity B）\n\n2. 当Activity B是**应用外Activity**时，集合内元素个数变迁如下：\n\n   Activity A's onPause() -> Activity B's onResume() -> Activity A's onStop()\n\n   **1**（Activity A）         **1**（Activity A）              **0**（）\n","source":"_posts/activity-transfer-detection.md","raw":"---\ntitle: Android Activity 转移类型检测\ndate: 2021-07-17 20:26:30\ntags:\n---\n\nRequirement:：\n\n应用内有些Activity数据敏感，需要区别对待，这里需要识别首次进入红色Activity集合内，在红色Activity集合内跳转，和跳出红色Activity集合三种情况。【当红色Activity集合是应用内的Activity集合时，就相当于首次进入应用，应用内界面跳转和退出应用的判定】\n\n[![W1aZWR.png](https://z3.ax1x.com/2021/07/17/W1aZWR.png)](https://imgtu.com/i/W1aZWR)\n\n算法描述：\n\n1. 定义一个保存Activity Simple Name的集合。\n\n2. Activity onResume时，将此Activity Simple Name加入集合。\n\n3. 1. 当集合元素个数等于**1**时，为首次进入该应用打开的第一个Activity。\n   2. 当集合元素个数等于**2**时，表示打开应用内的其他Activity。\n\n4. Activity onStop时，将此Activity Simple Name移出集合。\n\n5. 1. 当集合元素个数为**1**时，表示在应用内跳转。\n   2. 当集合元素个数为**0**时，表示打开其他应用。\n\n\n\n原理：\n\n[![W1aVY9.png](https://z3.ax1x.com/2021/07/17/W1aVY9.png)](https://imgtu.com/i/W1aVY9)\n\n\n\n由上图可知，Activity A启动Activity B时，执行顺序是Activity A's onPause() -> Activity B's onResume() -> Activity A's onStop()。应用内的Activity在执行 onResume() & onStop()时，我们规约将其Activity Simple Name加入&移出集合，而启动应用外的Activity我们没有能力如此操作。\n\n1. 首次进入Activity集合，应用内的Activity onResume被调用；\n2. 在Activity集合间跳转，应用内的Activity onResume & onStop被调用；\n3. 跳出Activity集合，应用内的Activity onStop 被调用；\n\n\n\n所以，启动应用内还是应用外的Activity在此产生差异，而差异让程序识别成为可能。\n\n1. 当Activity B是**应用内Activity**时，集合内元素个数变迁如下：\n\n   Activity A's onPause() -> Activity B's onResume() -> Activity A's onStop()\n\n   **1**（Activity A）         **2**（Activity A&B）        **1**（Activity B）\n\n2. 当Activity B是**应用外Activity**时，集合内元素个数变迁如下：\n\n   Activity A's onPause() -> Activity B's onResume() -> Activity A's onStop()\n\n   **1**（Activity A）         **1**（Activity A）              **0**（）\n","slug":"activity-transfer-detection","published":1,"updated":"2021-07-19T02:29:59.595Z","_id":"ckr8n7ku9000035ci30yc2t6l","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Requirement:：</p>\n<p>应用内有些Activity数据敏感，需要区别对待，这里需要识别首次进入红色Activity集合内，在红色Activity集合内跳转，和跳出红色Activity集合三种情况。【当红色Activity集合是应用内的Activity集合时，就相当于首次进入应用，应用内界面跳转和退出应用的判定】</p>\n<p><a href=\"https://imgtu.com/i/W1aZWR\"><img src=\"https://z3.ax1x.com/2021/07/17/W1aZWR.png\" alt=\"W1aZWR.png\"></a></p>\n<p>算法描述：</p>\n<ol>\n<li><p>定义一个保存Activity Simple Name的集合。</p>\n</li>\n<li><p>Activity onResume时，将此Activity Simple Name加入集合。</p>\n</li>\n<li><ol>\n<li>当集合元素个数等于<strong>1</strong>时，为首次进入该应用打开的第一个Activity。</li>\n<li>当集合元素个数等于<strong>2</strong>时，表示打开应用内的其他Activity。</li>\n</ol>\n</li>\n<li><p>Activity onStop时，将此Activity Simple Name移出集合。</p>\n</li>\n<li><ol>\n<li>当集合元素个数为<strong>1</strong>时，表示在应用内跳转。</li>\n<li>当集合元素个数为<strong>0</strong>时，表示打开其他应用。</li>\n</ol>\n</li>\n</ol>\n<p>原理：</p>\n<p><a href=\"https://imgtu.com/i/W1aVY9\"><img src=\"https://z3.ax1x.com/2021/07/17/W1aVY9.png\" alt=\"W1aVY9.png\"></a></p>\n<p>由上图可知，Activity A启动Activity B时，执行顺序是Activity A’s onPause() -&gt; Activity B’s onResume() -&gt; Activity A’s onStop()。应用内的Activity在执行 onResume() &amp; onStop()时，我们规约将其Activity Simple Name加入&amp;移出集合，而启动应用外的Activity我们没有能力如此操作。</p>\n<ol>\n<li>首次进入Activity集合，应用内的Activity onResume被调用；</li>\n<li>在Activity集合间跳转，应用内的Activity onResume &amp; onStop被调用；</li>\n<li>跳出Activity集合，应用内的Activity onStop 被调用；</li>\n</ol>\n<p>所以，启动应用内还是应用外的Activity在此产生差异，而差异让程序识别成为可能。</p>\n<ol>\n<li><p>当Activity B是<strong>应用内Activity</strong>时，集合内元素个数变迁如下：</p>\n<p>Activity A’s onPause() -&gt; Activity B’s onResume() -&gt; Activity A’s onStop()</p>\n<p><strong>1</strong>（Activity A）         <strong>2</strong>（Activity A&amp;B）        <strong>1</strong>（Activity B）</p>\n</li>\n<li><p>当Activity B是<strong>应用外Activity</strong>时，集合内元素个数变迁如下：</p>\n<p>Activity A’s onPause() -&gt; Activity B’s onResume() -&gt; Activity A’s onStop()</p>\n<p><strong>1</strong>（Activity A）         <strong>1</strong>（Activity A）              <strong>0</strong>（）</p>\n</li>\n</ol>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>Requirement:：</p>\n<p>应用内有些Activity数据敏感，需要区别对待，这里需要识别首次进入红色Activity集合内，在红色Activity集合内跳转，和跳出红色Activity集合三种情况。【当红色Activity集合是应用内的Activity集合时，就相当于首次进入应用，应用内界面跳转和退出应用的判定】</p>\n<p><a href=\"https://imgtu.com/i/W1aZWR\"><img src=\"https://z3.ax1x.com/2021/07/17/W1aZWR.png\" alt=\"W1aZWR.png\"></a></p>\n<p>算法描述：</p>\n<ol>\n<li><p>定义一个保存Activity Simple Name的集合。</p>\n</li>\n<li><p>Activity onResume时，将此Activity Simple Name加入集合。</p>\n</li>\n<li><ol>\n<li>当集合元素个数等于<strong>1</strong>时，为首次进入该应用打开的第一个Activity。</li>\n<li>当集合元素个数等于<strong>2</strong>时，表示打开应用内的其他Activity。</li>\n</ol>\n</li>\n<li><p>Activity onStop时，将此Activity Simple Name移出集合。</p>\n</li>\n<li><ol>\n<li>当集合元素个数为<strong>1</strong>时，表示在应用内跳转。</li>\n<li>当集合元素个数为<strong>0</strong>时，表示打开其他应用。</li>\n</ol>\n</li>\n</ol>\n<p>原理：</p>\n<p><a href=\"https://imgtu.com/i/W1aVY9\"><img src=\"https://z3.ax1x.com/2021/07/17/W1aVY9.png\" alt=\"W1aVY9.png\"></a></p>\n<p>由上图可知，Activity A启动Activity B时，执行顺序是Activity A’s onPause() -&gt; Activity B’s onResume() -&gt; Activity A’s onStop()。应用内的Activity在执行 onResume() &amp; onStop()时，我们规约将其Activity Simple Name加入&amp;移出集合，而启动应用外的Activity我们没有能力如此操作。</p>\n<ol>\n<li>首次进入Activity集合，应用内的Activity onResume被调用；</li>\n<li>在Activity集合间跳转，应用内的Activity onResume &amp; onStop被调用；</li>\n<li>跳出Activity集合，应用内的Activity onStop 被调用；</li>\n</ol>\n<p>所以，启动应用内还是应用外的Activity在此产生差异，而差异让程序识别成为可能。</p>\n<ol>\n<li><p>当Activity B是<strong>应用内Activity</strong>时，集合内元素个数变迁如下：</p>\n<p>Activity A’s onPause() -&gt; Activity B’s onResume() -&gt; Activity A’s onStop()</p>\n<p><strong>1</strong>（Activity A）         <strong>2</strong>（Activity A&amp;B）        <strong>1</strong>（Activity B）</p>\n</li>\n<li><p>当Activity B是<strong>应用外Activity</strong>时，集合内元素个数变迁如下：</p>\n<p>Activity A’s onPause() -&gt; Activity B’s onResume() -&gt; Activity A’s onStop()</p>\n<p><strong>1</strong>（Activity A）         <strong>1</strong>（Activity A）              <strong>0</strong>（）</p>\n</li>\n</ol>\n"},{"title":"English-introduction","date":"2021-08-18T13:23:28.000Z","_content":"\n# 英语自学指南\n\nEmail: limxtop@gmail.com\n\n\n\n# 自学掌握语言的根本方法 \n\n**天道酬勤!** \n\n理论上，不仅是英语学科，其他大部分知识的学习，只要投入足够的时间和运用合理的技巧，大体上，总是可以学好的。 \n\n有些知识，比如无人驾驶，因为跨越很多学科，并建立在诸多基础知识之上，所以，门槛很高，学习周期漫长，过程自然也费劲许多。但就英语而言，虽然也有难度，但只要方法得当，努力耕耘，也可以水到渠成，瓜熟蒂落。 \n\n我认为意识到这点很重要，**唯有当你坚信自己通过不懈的努力，有能力完成这个学习目标，掌握以前久攻不下的英语。你才有恒心和毅力，在学习过程中遇到诸多挫折之后，依然百折不挠地前进。** \n\n**但很遗憾，感觉很多人并没有意识到这点，甚至更加糟糕的是，还并不敢苟同这样的观念。于是，在进步到某个阶段的时候，就缴械投降，遂而前功尽弃了。** \n\n有一种观点或者说法很流行:童年时代才是学习语言的最佳年纪，所以当我们长大以后，即使学习了很多年的英语，依然不能开口流利说英语。这样的观点之所以深受认可是因为我们小时候开始学习汉语长大后可以用汉语口若悬河地表达，但成年后即使学习英语时间看似并不比汉语少，很多人依然在英语表达上结巴的表面事实。不过，私以为，这样的观点并非正确，与之相反，我依然深信表面上童年确实是学习语言的最佳时机，但如果能够洞察这里的真相和原因，我们可以从中获得关于如何学习语言的启发，也有足够的的理由相信，语言的学习和掌握，和年纪没有多大关系，而且由于成年人具备更好的学习能力，学习语言可以更加的有效率。 \n\n**那么为什么懵懂的孩童时代学习语言进步显著，而认知能力和学习能力已经今非昔比的成人学习语言却举步维艰?在我看来是因为前者在学习语言的时间和精力上投入比后者多出很多**。我能预知到这并非是一句能够让人轻易信服的结论，毕竟以我个人经历而言，经过小学六年的学习实践，自己已经具备初步的汉语表达能力，著书立说尚且有待时日，但与人日常攀谈，向来得心应手。但从初中到大学学习了10年的英语，在你摩拳擦掌，准备开口说的时候，此刻他们却纷纷打地鼠一般给你玩捉迷藏，以至于你憋红了脸，也只能支支吾吾，拼凑出词不达意，漏洞百出的词句。养兵千日，期待着有朝一日可以用兵，却发现无计可施，还有什么比这个更令人沮丧?以至于让多少人，放弃了坚持。 \n\n那么很多人都会疑问，我们学习汉语的时间怎么会比英语多呢?这里的玄机在于我们计算语言学习的时间有失偏颇，我们学习汉语并非只是在语文课上，我们上数学课也是用汉语，由于我们的生活环境，日常的交流也是用汉语，甚至到了中学我们的生物、物理、化学、地理、政治、历史课等除了英语课外所有的科目，还有我们所阅读的课外读物都是汉语，所以虽然只有六年的时间，但在这短短的时间里面因为我们所处的环境，使得我们有意无意地接收大量的的听说读写能力的训练和强化。而英语则并非如此。 \n\n**所以，我们的英语能力差强人意，根源在于我们投入的训练和实践远远不够。** \n\n使用工具是人类的天赋，而借助工具，或者外界力量用于辅助学习是一个很可取的选择。只是学习知识是一个将知识吸收内化的过程。当我们在学习的过程中，受挫，我们总是会感到沮丧，对自己失去信心。会有倾向求助于外界，期望有高人从天而降，对我们指点迷津，或者像神明一般施加法力，直接帮我们脱离苦海，比如我们会去报名参加培训，找老师，使用各种各样的APP。但这并不现实。师傅只是领进门，修行还是靠个人。学习这个过程大部分的工作还需要我们自己去完成。如果寻求外界获得成功，取得进步的决定性因素，并非是他们，而是因为你深度参与其中实践。**归根结底，他们都遵循，学习的本质是不断去亲身训练这一基本原则。所以，不管采取什么学习方法，有一点需要明白，万事求诸己。** \n\n# 如何训练和实践 \n\n不可否认，学习又是一件艰难漫长的过程。**所以，坚持本身至关重要。而坚持，归根结底是坚持训练。** \n\n**具体如何坚持训练呢？想必不是起早贪黑，狂背单词，或者捧着英文教科书念念有词，那样太辛苦了。于我而言，把自己接触的资讯全都切换为英文的，就好啦。将自己的手机，电脑语言切换成英语，所阅读的专业、非专业书籍也几乎是英文，平时多阅读英文文档呀，刷刷推特。不用特地投入时间学英语，但却在日如一日的重复里，慢慢地就可以感觉到进步和蜕变了。** \n\n练习听力，阅读文字只是输入式的训练，真正而更加有效的训练方式，应该是输出，也就是写作和口语表达。当我们在做输入式训练的时候，其实我们可以不怎么动脑的，甚至当时心不在焉。所以，只有输入式训练的话，进步的道路步履维艰， \n\n学习时间里，听说读写的训练，想必都不会有多大的问题。每个学习英语的成年中国人最大的问题在于，由于他们已经擅长汉语，在时间长出很多的非学习时间里，也就是日常生活中，他们习惯性地用汉语思考，因为用汉语可以很流畅，但用外语在屡屡碰壁，而语言是思考的载体，所以**思考才是训练的核心**。就像我们解题，阅读题目思考设计解答方案才是解题的核心，在纸上将答案表达出来不过是将思考输出。而这，就很好地解释了为什么小孩学习英语比较容易，因为当时他们的汉语与英语势均力敌，不像成年人，因为选择舒适的方式，不断地训练，强化了汉语，导致即使特别花时间精力对英语特别扶贫，也缩短不了他们的贫富差距。一方面我们做了大量的输入式训练，另一方面刻意规避输出式的训练，而这，正是，很多人学习英语，却收效甚微的根结所在。至于连输入式训练都没有的人，结果如何，自不必说。 \n\n**我们可以尝试着用英语去描述自己的所见所闻和所思所想，不懂的记录下来查询辞典。比如站在十字街头，会想到intersection，懂得词汇之后，可以尝试遣词造句，进一步地训练表达内容思想更加丰富的句子和短文，这些动作都是需要我们动脑思考的，是有效训练的很好实践。** \n\n# 好的学习方法 \n\n***Practice makes perfect*。但很遗憾，坚持训练本身很多人没能坚持下来。因为抽象来看，学习过程就是运用自己心智，与学习本身自带的诸多困难对抗，如图1。当屡屡受挫，你感知到的困难已经超越了自己的解决能力，放弃是一种明智和无奈的选择。**  \n\n![](https://s3.bmp.ovh/imgs/2021/08/487b6f7ecd3e3944.webp)\n\n**学习过程会屡屡碰壁，好的学习方法，应该要能够降低这种困难，减少斜坡的倾角。我们应该寻找和掌握一种方法，让学习如丝般顺滑，而不是举步维艰。**说到坚持练习，比如经常阅读英文书籍，但很少能够寻找到为自己词汇水平的资料，一个短句好几个单词都不懂，阅读一整页下来，不知所云，长久以往，很少有人能够保持热情与耐心继续阅读下去，即使做到，感觉也没有多大意义，因为虽然你过目了，但你依然没有掌握认识它，顶多似曾相识。**此时，身边有一本辞典，就显得尤为重要，它可以将这种困难降低到几乎为零的程度，遇到不懂的单词，即刻查询。通过自己所阅读的资料为主线，扩充自己的词汇量。** \n\n所谓工欲善其事，必先利其器。当遇到不懂的单词，比如malicious，在有道或者Google翻译里面查询，能得到的只有其翻译，也许还会花点心思查看下对应的同义词、反义词、同根词。但这种学习方式不过是建立英文单词与汉语释义单一的映射，这是一种硬编码，记忆效率极其低下。可曾记得小学时候，我们为了记忆九九乘法表，花了一个星期的时间，天天背诵，终于烙印在脑里。 \n\n自己在使用英文资料学习编程的过程中，时常在思索如何解决快速索引释义的问题，偶然而又幸运的是，意外发现了GoldenDict辞典软件，如图2，它并本身并不提供任何辞典，但它支持种类繁多的辞典格式，与它们搭档，使得GoldenDict在众多辞典软件里所向披靡。我安装了好几部英英辞典，里面提供完整的释义，词组，相关的同义词和丰富的例句。我喜欢这种像神经网络一样，在与他物联系中记忆的方式，短时间内阅读辞典查询结果，可能不如狂背一百遍的记忆效果好，但我对自己的方法爱不释手，毕竟，单词并非独立的存在，它需要和其他单词组合拼凑成句子，才能构建表达完整的含义，也只有知道了组合后，我们才有可能学以致用。在丰富的组合连接之下，每个单词不再是一座孤岛，在记忆的深处都有迹可循，长期以往，这样可以有效地构建我们丰富的语言体系，和表达能力。毕竟，表达和思考，本质上无非就是向记忆索取词汇，但凡词汇索引建的好，这个过程就不会吃力。而单独记忆单词的结果是知道中文含义，但不知道如何使用，真的开口说话时，更是哑口无言，或者词不能大意。同时我很讨厌背诵，在时常检查背诵的初中时代，自己有过不幸被老师点名，在全班同学面前背诵文言文，却背不出一个完整的段落，申请背诵另外一篇，没想到依然差强人意。兴许是屡次三番摘得年级桂冠光芒的照耀，老师同学只是爆发出慈眉善目的笑声，险过一关。不过值得一提的是，时至今日，我依然记得初中课文里出现的几个句子“天下事有难易乎?为之，则难者亦易矣;不为，则易者亦难矣。人之为学有难易乎?学之，则难者亦易矣;不学，则易者亦难矣。” \n\n![](https://s3.bmp.ovh/imgs/2021/08/69bc4729f629349e.webp))\n\n1，“无他，但手熟尔”2，“故不积跬步，无以至千里;不积小流，无以成江海。”3,“世之奇伟、瑰怪、非常之观，常在险远，而人之所罕至焉，故非有志者不能至也。”4它们启发与激励着我，每每灰心丧气的时候，鼓舞自己，再坚持一下。 \n\n# 关于记忆 \n\n我当然认为记忆本身很重要，只是觉得应该追本溯源，记忆最原始，源头的部分，因为这些内容是朴素的，简洁的，内容少很容易记，其他的内容，可以通过记忆的内容通过推理、推到得出，是故没有必要滥用珍贵的记忆资源。 \n\n举个例子: \n\ncos(A+B) = cosA∗cosB −sinA∗sinB (1)\n\nsin(A+B) = sinA∗sinB +cosA∗cosB (2)\n\ntan(A+B) = sin(A+B)/cos(A+B) = (tanA∗tanB+1)/(1−tanA∗tanB) (3)\n\n如上数学公式还记得吧?当年的女数学老师只是用复杂的方法证明其正确，却没有教会我们如何推理记忆。那时，同学们只能靠大量的解题，在重复的训练中强化记忆，但只要训练中断时日，记忆可能就会出现偏差。 \n\n但其实，只需要记得图3矩形框里的几何图形及其意义，上面一系列相关的公式可以一字不落地推理得出，简洁直观，一目了然。 \n\n![](https://s3.bmp.ovh/imgs/2021/08/0d1a20ecab37a4d3.webp)\n\naf ∗ cos(A + B) = ac − ef (4)\n\nac−ef = af ∗cosA∗cosB −af ∗sinA∗sinB (5)\n\n由 (4) 和 (5) 我们可得(1) \n\n对于理工科而言，单纯的记忆结果除了提高解题速度，应付考试，是没有多大功用的，因为它很容易遗忘。重要的是理解简化推理论证的过程，或者最原始基本的定义，通过定义和推理关键步骤，整个知识版图都可以顺藤摸瓜探索出来。 \n\n# 如何记忆单词 \n\n其实，感觉很多人都懂这些，但为了完整性，还是罗列一下，因为自己本身也不专业，一笔带过吧。 \n\n## 按音节记忆单词 \n\n刚接触英语时，貌似是老师这么教我们b-i-k-e bike，初学时无可厚非。在入门后，就应该按照音节来辅助记忆了，辅音一般不变，元音虽然时常有好几种发音，但多是相对固定，我记得初中英语教科书上有这样的汇总表格，但自己平时留意，也可以总结出常用的规律。比如i发aɪ音，所以从拼写可以推断出发音，bike念作baɪk，从发音可以推断出拼写，baɪk其拼写为bike。 \n\n## 词根词缀\n\nmature有成熟，完善之意，pre有在前，前面之意，所以premature就表示早熟，或者引申为早产。具体可以搜索参考词根词缀记忆领域的书籍。 \n\n## 系统学习 \n\n按照情景或者场景系统地学习词汇和用法，比如房子的物品名称，以及其相关的动词和对话表达，如图4。 \n\n![](https://s3.bmp.ovh/imgs/2021/08/b8518865846f4d62.webp)\n\n学到的词汇要平时多用，听说读写最好雨露均沾。 \n\n# 审慎对待任何学习方法 \n\n中学时代，曾经在书籍上阅读过一段文字，某君总结自己的学习经验时，将自己英语听力的提高归功于自己平时听英文歌曲。于是自己也尝试着去听英文歌。但过了些时日，并没有感觉到听力明显的提升，但也许是自己练习不够，也许自己听的时候并没有全神贯注的听，当然，还有可能这种方法本身就不可能奏效。理论上，只要练习，总会有进步的，但私以为这样的方法收效甚微，毕竟，如果单词你本来就不懂，你是很难通过听来学习掌握的。首先，你得会识字，以此为前提，你可以听懂和表达。意识到这些，已经是多年以后了，以至于，在后来，又几乎重蹈覆辙。 \n\n在书店发现一本书，书名叫《千万别学英语》，有些标新立异，就捧读起来。一本书的厚度，但里面的内容如果没记错的话，总结起来，大概是每天都听两遍磁带，每周固定休息一天。作者的观点是，我们大脑学习语言的部分，也需要休息整顿。并危言耸听道，如果不在休息日绝对不能接触英语，将前功尽弃。我仿佛在地摊上发现了练得一身上乘武功的武林秘籍，只要按部就班地模仿学习，在武林上雄霸一方指日可待，喜悦之前，溢于言表，开始憧憬创造奇迹的未来。后来的结果，如大家所料，并没有什么意外。依然收效甚微，在英语的学习上依旧艰难前进。如果没有记错，书里还提到一点，就是把听不懂的单词特别标注出来，使用最新的英英词典查询(他批判长辈把辞典馈赠给子女用的行为，认为辞典日新月异，祖传的都已经不合时宜)。 \n\n这里并没有否定他们学习方法的意思，我觉得每个人的学习方法都可以不同，都是在刻苦练习，殊途同归。也许他们的方法确实帮助他们掌握了英语，也许是他们实践中的某个环节起到了决定性的作用，只是他自己都没能意识到，于是总结自己经验时，出了偏差。分享自己成功学习经验的行为，我觉得这本身就很值得褒奖。只是，以我现在的处事原则来看，任何一种结论，言辞，都要思辨、审慎地对待，汲取合理有效的部分，不能盲从，包括此篇。 \n\n李阳的疯狂英语，也在事实上影响了很多人，我没怎么接触过，也就不予置评了。但曾经在南方周末看过毛坦厂中学的报道，学生起早贪黑，在操场上捧着书，像疯子一样大声朗读。我想说，每个人都有自己的学习方法，爱怎么整都是自己的事情，只是，学习应该是一件轻松愉悦的事情，没必要头悬梁锥刺股，整的与自己为敌。同时也应该多比较他人的学习方法，师夷长技，博采众长，为自己所用，相信很多人都认同，闭门造车往往进度条滚动太慢。 \n\n# 宽容的环境 \n\n很多人学了很多年的英语，终归不会开口流利地表达自己的想法和感受，归根结底在于我们过多的注重孤立的词汇和语法学习，没有系统地学习词汇，没有学习丰富的词组，更缺少平时的开口表达。 \n\n在缺少表达的问题上，很多人简单的归因为身边没有外国朋友可以交流实践。但其实，这是一个伪命题。退一步说，假设真有一位外国友人如神兵天降于你身边，你也很少有机会可以开口实践，毕竟，人家也是人，实在无法做到和一位词不达意，说话结巴的人，和颜悦色地交流。也就是说，在你想和别人交流时，自身必须达到一定的表达能力，而在此之前，一切都靠自学，或者和自己水平相当的伙伴协同学习。试想那些咿呀学语的婴孩，也就只有父母家人才有耐心和热情陪同重复那些简单的词汇语句，以此教导他的语言能力。 \n\n由于很多人掌握的词汇支离破碎，常常并不足以表达一个完整的句子，此时采用中英结合的方式，倒是不错的选择。但问题在于，有人很厌恶这样的举动，并公开地排斥。甚至，有人会厌恶那些在中国说着英语的中国人，他们认为，在中国就该讲中国话，是中国人就该讲中国话，爱国就应该讲国语。或者仅仅英语不合他们自己接收信息的习惯方式，就足以在内心产生抵触。暂且不深入展开他们的逻辑，但可以想象，有这样的现象存在，那些想实践英语的人，自然面对更多的困难和挑战。当然，我们可以选择忽视他们的意见，我们也需要有勇气直面他们的反对，并踽踽而行，毕竟，他们并非正确，真理也并非掌握在他们手上。不得不承认他们不过是在言论自由的框架之下表达自己的反对意见，对此我自然也不能有什么指摘，只是希望，这些人，特别是公众人物，在自由地表达自己的意见时，能够明白自己言行的后果，从而在情不自禁的随口一说时，更加审慎一些。 \n\n\n\n# GodenDict 安装\n\n下载链接: https://pan.baidu.com/s/1oV6AxRUlX1c7mpE352bt8w 提取码: uxtw \n\n## Windows & Mac\n\n1. 下载GodenDict应用程序：\n   1. Mac： GoldenDict-1.5.0-RC2-209-gfe9312e(Qt_563)\n   2. Windows： GoldenDict-1.0.1-Portable\n2. 下载词典文件并解压\n   1. En-En-Longman_Pronunciation3.zip\n   2. En-En_OALD8.zip\n   3. En-En_Merriam_Webster11\n   4. En-zh_CN_OALD4\n   5. En-En_Longman_DOCE5\n3. GodenDic 安装完毕，打开Dictionary菜单，在如下界面点击Add，将解压的词典目录逐个添加，完成后点击Rescan now，程序建立索引。\n\n![](https://s3.bmp.ovh/imgs/2021/08/305a1480dcfc9dbd.png)\n\nMac上会有如下界面异常，\n\n<img src=\"https://s3.bmp.ovh/imgs/2021/08/bad36e68350614d4.png\" style=\"zoom:100%;\" />\n\n点击Preference菜单，如下截图勾选“Expand optional parts”\n\n![](https://s3.bmp.ovh/imgs/2021/08/f3565b6d9c3abefc.png)\n\n最后，可以把这个选项勾选。\n\n![](https://s3.bmp.ovh/imgs/2021/08/79f7c59f09d94491.png)\n\n## Android\n\n1. 下载Android APK并安装：[下载链接](http://goldendict.mobi/downloads/android/free/)\n2. 下载词典文件：上一节百度云 Android 目录（此目录下的文件是从词典文件压缩包里面提取，去掉音频和图片，以减少手机存储占用）\n3. 将下载的词典文件存放于手机根目录的：GoldenDict 文件夹（注意命名，大小写完全一致）\n4. 手机上打开GoldenDict，此时先建立索引，完毕就可以正常使用。\n\n## iOS： \n\n尚未支持，可以考虑使用欧路词典或其他，并按照类似思路，安装词典即可。\n\n\n\n# 写作\n\n## 语法\n\n写作的基础是正确的语法，语法书我只推荐这本：[旋元佑进阶文法](http://grammar.codeyu.com/) ，推荐阅读第一章的基本句型和第十六七章的合句和名词子句，就能感同身受，此书是否值得细读了。或者参考[豆瓣的评价](https://book.douban.com/subject/34840714/)。\n\n## 写作课程\n\n[Academic English: Writing Specialization](https://www.coursera.org/specializations/academic-english)\n\n[Writing in the Sciences](https://online.stanford.edu/courses/som-y0010-writing-sciences)\n\n其他的就不做推荐了，相信每个人都可以寻找到适合自己的资料。\n\n\n\n\n\n**如果本文令你受益匪浅，愿意慷慨解囊，可以看这里，一分也是爱。分享推荐给身边的朋友，也是不胜感激**\n\n<img src=\"https://s3.bmp.ovh/imgs/2021/08/05d5219d41934cc5.png\" style=\"zoom:25%;\" />\n","source":"_posts/English-introduction.md","raw":"---\ntitle: English-introduction\ndate: 2021-08-18 21:23:28\ntags: 英语,自学,入门,指南,方法论,词典\n---\n\n# 英语自学指南\n\nEmail: limxtop@gmail.com\n\n\n\n# 自学掌握语言的根本方法 \n\n**天道酬勤!** \n\n理论上，不仅是英语学科，其他大部分知识的学习，只要投入足够的时间和运用合理的技巧，大体上，总是可以学好的。 \n\n有些知识，比如无人驾驶，因为跨越很多学科，并建立在诸多基础知识之上，所以，门槛很高，学习周期漫长，过程自然也费劲许多。但就英语而言，虽然也有难度，但只要方法得当，努力耕耘，也可以水到渠成，瓜熟蒂落。 \n\n我认为意识到这点很重要，**唯有当你坚信自己通过不懈的努力，有能力完成这个学习目标，掌握以前久攻不下的英语。你才有恒心和毅力，在学习过程中遇到诸多挫折之后，依然百折不挠地前进。** \n\n**但很遗憾，感觉很多人并没有意识到这点，甚至更加糟糕的是，还并不敢苟同这样的观念。于是，在进步到某个阶段的时候，就缴械投降，遂而前功尽弃了。** \n\n有一种观点或者说法很流行:童年时代才是学习语言的最佳年纪，所以当我们长大以后，即使学习了很多年的英语，依然不能开口流利说英语。这样的观点之所以深受认可是因为我们小时候开始学习汉语长大后可以用汉语口若悬河地表达，但成年后即使学习英语时间看似并不比汉语少，很多人依然在英语表达上结巴的表面事实。不过，私以为，这样的观点并非正确，与之相反，我依然深信表面上童年确实是学习语言的最佳时机，但如果能够洞察这里的真相和原因，我们可以从中获得关于如何学习语言的启发，也有足够的的理由相信，语言的学习和掌握，和年纪没有多大关系，而且由于成年人具备更好的学习能力，学习语言可以更加的有效率。 \n\n**那么为什么懵懂的孩童时代学习语言进步显著，而认知能力和学习能力已经今非昔比的成人学习语言却举步维艰?在我看来是因为前者在学习语言的时间和精力上投入比后者多出很多**。我能预知到这并非是一句能够让人轻易信服的结论，毕竟以我个人经历而言，经过小学六年的学习实践，自己已经具备初步的汉语表达能力，著书立说尚且有待时日，但与人日常攀谈，向来得心应手。但从初中到大学学习了10年的英语，在你摩拳擦掌，准备开口说的时候，此刻他们却纷纷打地鼠一般给你玩捉迷藏，以至于你憋红了脸，也只能支支吾吾，拼凑出词不达意，漏洞百出的词句。养兵千日，期待着有朝一日可以用兵，却发现无计可施，还有什么比这个更令人沮丧?以至于让多少人，放弃了坚持。 \n\n那么很多人都会疑问，我们学习汉语的时间怎么会比英语多呢?这里的玄机在于我们计算语言学习的时间有失偏颇，我们学习汉语并非只是在语文课上，我们上数学课也是用汉语，由于我们的生活环境，日常的交流也是用汉语，甚至到了中学我们的生物、物理、化学、地理、政治、历史课等除了英语课外所有的科目，还有我们所阅读的课外读物都是汉语，所以虽然只有六年的时间，但在这短短的时间里面因为我们所处的环境，使得我们有意无意地接收大量的的听说读写能力的训练和强化。而英语则并非如此。 \n\n**所以，我们的英语能力差强人意，根源在于我们投入的训练和实践远远不够。** \n\n使用工具是人类的天赋，而借助工具，或者外界力量用于辅助学习是一个很可取的选择。只是学习知识是一个将知识吸收内化的过程。当我们在学习的过程中，受挫，我们总是会感到沮丧，对自己失去信心。会有倾向求助于外界，期望有高人从天而降，对我们指点迷津，或者像神明一般施加法力，直接帮我们脱离苦海，比如我们会去报名参加培训，找老师，使用各种各样的APP。但这并不现实。师傅只是领进门，修行还是靠个人。学习这个过程大部分的工作还需要我们自己去完成。如果寻求外界获得成功，取得进步的决定性因素，并非是他们，而是因为你深度参与其中实践。**归根结底，他们都遵循，学习的本质是不断去亲身训练这一基本原则。所以，不管采取什么学习方法，有一点需要明白，万事求诸己。** \n\n# 如何训练和实践 \n\n不可否认，学习又是一件艰难漫长的过程。**所以，坚持本身至关重要。而坚持，归根结底是坚持训练。** \n\n**具体如何坚持训练呢？想必不是起早贪黑，狂背单词，或者捧着英文教科书念念有词，那样太辛苦了。于我而言，把自己接触的资讯全都切换为英文的，就好啦。将自己的手机，电脑语言切换成英语，所阅读的专业、非专业书籍也几乎是英文，平时多阅读英文文档呀，刷刷推特。不用特地投入时间学英语，但却在日如一日的重复里，慢慢地就可以感觉到进步和蜕变了。** \n\n练习听力，阅读文字只是输入式的训练，真正而更加有效的训练方式，应该是输出，也就是写作和口语表达。当我们在做输入式训练的时候，其实我们可以不怎么动脑的，甚至当时心不在焉。所以，只有输入式训练的话，进步的道路步履维艰， \n\n学习时间里，听说读写的训练，想必都不会有多大的问题。每个学习英语的成年中国人最大的问题在于，由于他们已经擅长汉语，在时间长出很多的非学习时间里，也就是日常生活中，他们习惯性地用汉语思考，因为用汉语可以很流畅，但用外语在屡屡碰壁，而语言是思考的载体，所以**思考才是训练的核心**。就像我们解题，阅读题目思考设计解答方案才是解题的核心，在纸上将答案表达出来不过是将思考输出。而这，就很好地解释了为什么小孩学习英语比较容易，因为当时他们的汉语与英语势均力敌，不像成年人，因为选择舒适的方式，不断地训练，强化了汉语，导致即使特别花时间精力对英语特别扶贫，也缩短不了他们的贫富差距。一方面我们做了大量的输入式训练，另一方面刻意规避输出式的训练，而这，正是，很多人学习英语，却收效甚微的根结所在。至于连输入式训练都没有的人，结果如何，自不必说。 \n\n**我们可以尝试着用英语去描述自己的所见所闻和所思所想，不懂的记录下来查询辞典。比如站在十字街头，会想到intersection，懂得词汇之后，可以尝试遣词造句，进一步地训练表达内容思想更加丰富的句子和短文，这些动作都是需要我们动脑思考的，是有效训练的很好实践。** \n\n# 好的学习方法 \n\n***Practice makes perfect*。但很遗憾，坚持训练本身很多人没能坚持下来。因为抽象来看，学习过程就是运用自己心智，与学习本身自带的诸多困难对抗，如图1。当屡屡受挫，你感知到的困难已经超越了自己的解决能力，放弃是一种明智和无奈的选择。**  \n\n![](https://s3.bmp.ovh/imgs/2021/08/487b6f7ecd3e3944.webp)\n\n**学习过程会屡屡碰壁，好的学习方法，应该要能够降低这种困难，减少斜坡的倾角。我们应该寻找和掌握一种方法，让学习如丝般顺滑，而不是举步维艰。**说到坚持练习，比如经常阅读英文书籍，但很少能够寻找到为自己词汇水平的资料，一个短句好几个单词都不懂，阅读一整页下来，不知所云，长久以往，很少有人能够保持热情与耐心继续阅读下去，即使做到，感觉也没有多大意义，因为虽然你过目了，但你依然没有掌握认识它，顶多似曾相识。**此时，身边有一本辞典，就显得尤为重要，它可以将这种困难降低到几乎为零的程度，遇到不懂的单词，即刻查询。通过自己所阅读的资料为主线，扩充自己的词汇量。** \n\n所谓工欲善其事，必先利其器。当遇到不懂的单词，比如malicious，在有道或者Google翻译里面查询，能得到的只有其翻译，也许还会花点心思查看下对应的同义词、反义词、同根词。但这种学习方式不过是建立英文单词与汉语释义单一的映射，这是一种硬编码，记忆效率极其低下。可曾记得小学时候，我们为了记忆九九乘法表，花了一个星期的时间，天天背诵，终于烙印在脑里。 \n\n自己在使用英文资料学习编程的过程中，时常在思索如何解决快速索引释义的问题，偶然而又幸运的是，意外发现了GoldenDict辞典软件，如图2，它并本身并不提供任何辞典，但它支持种类繁多的辞典格式，与它们搭档，使得GoldenDict在众多辞典软件里所向披靡。我安装了好几部英英辞典，里面提供完整的释义，词组，相关的同义词和丰富的例句。我喜欢这种像神经网络一样，在与他物联系中记忆的方式，短时间内阅读辞典查询结果，可能不如狂背一百遍的记忆效果好，但我对自己的方法爱不释手，毕竟，单词并非独立的存在，它需要和其他单词组合拼凑成句子，才能构建表达完整的含义，也只有知道了组合后，我们才有可能学以致用。在丰富的组合连接之下，每个单词不再是一座孤岛，在记忆的深处都有迹可循，长期以往，这样可以有效地构建我们丰富的语言体系，和表达能力。毕竟，表达和思考，本质上无非就是向记忆索取词汇，但凡词汇索引建的好，这个过程就不会吃力。而单独记忆单词的结果是知道中文含义，但不知道如何使用，真的开口说话时，更是哑口无言，或者词不能大意。同时我很讨厌背诵，在时常检查背诵的初中时代，自己有过不幸被老师点名，在全班同学面前背诵文言文，却背不出一个完整的段落，申请背诵另外一篇，没想到依然差强人意。兴许是屡次三番摘得年级桂冠光芒的照耀，老师同学只是爆发出慈眉善目的笑声，险过一关。不过值得一提的是，时至今日，我依然记得初中课文里出现的几个句子“天下事有难易乎?为之，则难者亦易矣;不为，则易者亦难矣。人之为学有难易乎?学之，则难者亦易矣;不学，则易者亦难矣。” \n\n![](https://s3.bmp.ovh/imgs/2021/08/69bc4729f629349e.webp))\n\n1，“无他，但手熟尔”2，“故不积跬步，无以至千里;不积小流，无以成江海。”3,“世之奇伟、瑰怪、非常之观，常在险远，而人之所罕至焉，故非有志者不能至也。”4它们启发与激励着我，每每灰心丧气的时候，鼓舞自己，再坚持一下。 \n\n# 关于记忆 \n\n我当然认为记忆本身很重要，只是觉得应该追本溯源，记忆最原始，源头的部分，因为这些内容是朴素的，简洁的，内容少很容易记，其他的内容，可以通过记忆的内容通过推理、推到得出，是故没有必要滥用珍贵的记忆资源。 \n\n举个例子: \n\ncos(A+B) = cosA∗cosB −sinA∗sinB (1)\n\nsin(A+B) = sinA∗sinB +cosA∗cosB (2)\n\ntan(A+B) = sin(A+B)/cos(A+B) = (tanA∗tanB+1)/(1−tanA∗tanB) (3)\n\n如上数学公式还记得吧?当年的女数学老师只是用复杂的方法证明其正确，却没有教会我们如何推理记忆。那时，同学们只能靠大量的解题，在重复的训练中强化记忆，但只要训练中断时日，记忆可能就会出现偏差。 \n\n但其实，只需要记得图3矩形框里的几何图形及其意义，上面一系列相关的公式可以一字不落地推理得出，简洁直观，一目了然。 \n\n![](https://s3.bmp.ovh/imgs/2021/08/0d1a20ecab37a4d3.webp)\n\naf ∗ cos(A + B) = ac − ef (4)\n\nac−ef = af ∗cosA∗cosB −af ∗sinA∗sinB (5)\n\n由 (4) 和 (5) 我们可得(1) \n\n对于理工科而言，单纯的记忆结果除了提高解题速度，应付考试，是没有多大功用的，因为它很容易遗忘。重要的是理解简化推理论证的过程，或者最原始基本的定义，通过定义和推理关键步骤，整个知识版图都可以顺藤摸瓜探索出来。 \n\n# 如何记忆单词 \n\n其实，感觉很多人都懂这些，但为了完整性，还是罗列一下，因为自己本身也不专业，一笔带过吧。 \n\n## 按音节记忆单词 \n\n刚接触英语时，貌似是老师这么教我们b-i-k-e bike，初学时无可厚非。在入门后，就应该按照音节来辅助记忆了，辅音一般不变，元音虽然时常有好几种发音，但多是相对固定，我记得初中英语教科书上有这样的汇总表格，但自己平时留意，也可以总结出常用的规律。比如i发aɪ音，所以从拼写可以推断出发音，bike念作baɪk，从发音可以推断出拼写，baɪk其拼写为bike。 \n\n## 词根词缀\n\nmature有成熟，完善之意，pre有在前，前面之意，所以premature就表示早熟，或者引申为早产。具体可以搜索参考词根词缀记忆领域的书籍。 \n\n## 系统学习 \n\n按照情景或者场景系统地学习词汇和用法，比如房子的物品名称，以及其相关的动词和对话表达，如图4。 \n\n![](https://s3.bmp.ovh/imgs/2021/08/b8518865846f4d62.webp)\n\n学到的词汇要平时多用，听说读写最好雨露均沾。 \n\n# 审慎对待任何学习方法 \n\n中学时代，曾经在书籍上阅读过一段文字，某君总结自己的学习经验时，将自己英语听力的提高归功于自己平时听英文歌曲。于是自己也尝试着去听英文歌。但过了些时日，并没有感觉到听力明显的提升，但也许是自己练习不够，也许自己听的时候并没有全神贯注的听，当然，还有可能这种方法本身就不可能奏效。理论上，只要练习，总会有进步的，但私以为这样的方法收效甚微，毕竟，如果单词你本来就不懂，你是很难通过听来学习掌握的。首先，你得会识字，以此为前提，你可以听懂和表达。意识到这些，已经是多年以后了，以至于，在后来，又几乎重蹈覆辙。 \n\n在书店发现一本书，书名叫《千万别学英语》，有些标新立异，就捧读起来。一本书的厚度，但里面的内容如果没记错的话，总结起来，大概是每天都听两遍磁带，每周固定休息一天。作者的观点是，我们大脑学习语言的部分，也需要休息整顿。并危言耸听道，如果不在休息日绝对不能接触英语，将前功尽弃。我仿佛在地摊上发现了练得一身上乘武功的武林秘籍，只要按部就班地模仿学习，在武林上雄霸一方指日可待，喜悦之前，溢于言表，开始憧憬创造奇迹的未来。后来的结果，如大家所料，并没有什么意外。依然收效甚微，在英语的学习上依旧艰难前进。如果没有记错，书里还提到一点，就是把听不懂的单词特别标注出来，使用最新的英英词典查询(他批判长辈把辞典馈赠给子女用的行为，认为辞典日新月异，祖传的都已经不合时宜)。 \n\n这里并没有否定他们学习方法的意思，我觉得每个人的学习方法都可以不同，都是在刻苦练习，殊途同归。也许他们的方法确实帮助他们掌握了英语，也许是他们实践中的某个环节起到了决定性的作用，只是他自己都没能意识到，于是总结自己经验时，出了偏差。分享自己成功学习经验的行为，我觉得这本身就很值得褒奖。只是，以我现在的处事原则来看，任何一种结论，言辞，都要思辨、审慎地对待，汲取合理有效的部分，不能盲从，包括此篇。 \n\n李阳的疯狂英语，也在事实上影响了很多人，我没怎么接触过，也就不予置评了。但曾经在南方周末看过毛坦厂中学的报道，学生起早贪黑，在操场上捧着书，像疯子一样大声朗读。我想说，每个人都有自己的学习方法，爱怎么整都是自己的事情，只是，学习应该是一件轻松愉悦的事情，没必要头悬梁锥刺股，整的与自己为敌。同时也应该多比较他人的学习方法，师夷长技，博采众长，为自己所用，相信很多人都认同，闭门造车往往进度条滚动太慢。 \n\n# 宽容的环境 \n\n很多人学了很多年的英语，终归不会开口流利地表达自己的想法和感受，归根结底在于我们过多的注重孤立的词汇和语法学习，没有系统地学习词汇，没有学习丰富的词组，更缺少平时的开口表达。 \n\n在缺少表达的问题上，很多人简单的归因为身边没有外国朋友可以交流实践。但其实，这是一个伪命题。退一步说，假设真有一位外国友人如神兵天降于你身边，你也很少有机会可以开口实践，毕竟，人家也是人，实在无法做到和一位词不达意，说话结巴的人，和颜悦色地交流。也就是说，在你想和别人交流时，自身必须达到一定的表达能力，而在此之前，一切都靠自学，或者和自己水平相当的伙伴协同学习。试想那些咿呀学语的婴孩，也就只有父母家人才有耐心和热情陪同重复那些简单的词汇语句，以此教导他的语言能力。 \n\n由于很多人掌握的词汇支离破碎，常常并不足以表达一个完整的句子，此时采用中英结合的方式，倒是不错的选择。但问题在于，有人很厌恶这样的举动，并公开地排斥。甚至，有人会厌恶那些在中国说着英语的中国人，他们认为，在中国就该讲中国话，是中国人就该讲中国话，爱国就应该讲国语。或者仅仅英语不合他们自己接收信息的习惯方式，就足以在内心产生抵触。暂且不深入展开他们的逻辑，但可以想象，有这样的现象存在，那些想实践英语的人，自然面对更多的困难和挑战。当然，我们可以选择忽视他们的意见，我们也需要有勇气直面他们的反对，并踽踽而行，毕竟，他们并非正确，真理也并非掌握在他们手上。不得不承认他们不过是在言论自由的框架之下表达自己的反对意见，对此我自然也不能有什么指摘，只是希望，这些人，特别是公众人物，在自由地表达自己的意见时，能够明白自己言行的后果，从而在情不自禁的随口一说时，更加审慎一些。 \n\n\n\n# GodenDict 安装\n\n下载链接: https://pan.baidu.com/s/1oV6AxRUlX1c7mpE352bt8w 提取码: uxtw \n\n## Windows & Mac\n\n1. 下载GodenDict应用程序：\n   1. Mac： GoldenDict-1.5.0-RC2-209-gfe9312e(Qt_563)\n   2. Windows： GoldenDict-1.0.1-Portable\n2. 下载词典文件并解压\n   1. En-En-Longman_Pronunciation3.zip\n   2. En-En_OALD8.zip\n   3. En-En_Merriam_Webster11\n   4. En-zh_CN_OALD4\n   5. En-En_Longman_DOCE5\n3. GodenDic 安装完毕，打开Dictionary菜单，在如下界面点击Add，将解压的词典目录逐个添加，完成后点击Rescan now，程序建立索引。\n\n![](https://s3.bmp.ovh/imgs/2021/08/305a1480dcfc9dbd.png)\n\nMac上会有如下界面异常，\n\n<img src=\"https://s3.bmp.ovh/imgs/2021/08/bad36e68350614d4.png\" style=\"zoom:100%;\" />\n\n点击Preference菜单，如下截图勾选“Expand optional parts”\n\n![](https://s3.bmp.ovh/imgs/2021/08/f3565b6d9c3abefc.png)\n\n最后，可以把这个选项勾选。\n\n![](https://s3.bmp.ovh/imgs/2021/08/79f7c59f09d94491.png)\n\n## Android\n\n1. 下载Android APK并安装：[下载链接](http://goldendict.mobi/downloads/android/free/)\n2. 下载词典文件：上一节百度云 Android 目录（此目录下的文件是从词典文件压缩包里面提取，去掉音频和图片，以减少手机存储占用）\n3. 将下载的词典文件存放于手机根目录的：GoldenDict 文件夹（注意命名，大小写完全一致）\n4. 手机上打开GoldenDict，此时先建立索引，完毕就可以正常使用。\n\n## iOS： \n\n尚未支持，可以考虑使用欧路词典或其他，并按照类似思路，安装词典即可。\n\n\n\n# 写作\n\n## 语法\n\n写作的基础是正确的语法，语法书我只推荐这本：[旋元佑进阶文法](http://grammar.codeyu.com/) ，推荐阅读第一章的基本句型和第十六七章的合句和名词子句，就能感同身受，此书是否值得细读了。或者参考[豆瓣的评价](https://book.douban.com/subject/34840714/)。\n\n## 写作课程\n\n[Academic English: Writing Specialization](https://www.coursera.org/specializations/academic-english)\n\n[Writing in the Sciences](https://online.stanford.edu/courses/som-y0010-writing-sciences)\n\n其他的就不做推荐了，相信每个人都可以寻找到适合自己的资料。\n\n\n\n\n\n**如果本文令你受益匪浅，愿意慷慨解囊，可以看这里，一分也是爱。分享推荐给身边的朋友，也是不胜感激**\n\n<img src=\"https://s3.bmp.ovh/imgs/2021/08/05d5219d41934cc5.png\" style=\"zoom:25%;\" />\n","slug":"English-introduction","published":1,"updated":"2022-02-14T10:12:51.331Z","_id":"ckshj98tv0000ddci7ccz6eba","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"英语自学指南\"><a href=\"#英语自学指南\" class=\"headerlink\" title=\"英语自学指南\"></a>英语自学指南</h1><p>Email: <a href=\"mailto:&#108;&#x69;&#x6d;&#120;&#116;&#111;&#112;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;\">&#108;&#x69;&#x6d;&#120;&#116;&#111;&#112;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a></p>\n<h1 id=\"自学掌握语言的根本方法\"><a href=\"#自学掌握语言的根本方法\" class=\"headerlink\" title=\"自学掌握语言的根本方法\"></a>自学掌握语言的根本方法</h1><p><strong>天道酬勤!</strong> </p>\n<p>理论上，不仅是英语学科，其他大部分知识的学习，只要投入足够的时间和运用合理的技巧，大体上，总是可以学好的。 </p>\n<p>有些知识，比如无人驾驶，因为跨越很多学科，并建立在诸多基础知识之上，所以，门槛很高，学习周期漫长，过程自然也费劲许多。但就英语而言，虽然也有难度，但只要方法得当，努力耕耘，也可以水到渠成，瓜熟蒂落。 </p>\n<p>我认为意识到这点很重要，<strong>唯有当你坚信自己通过不懈的努力，有能力完成这个学习目标，掌握以前久攻不下的英语。你才有恒心和毅力，在学习过程中遇到诸多挫折之后，依然百折不挠地前进。</strong> </p>\n<p><strong>但很遗憾，感觉很多人并没有意识到这点，甚至更加糟糕的是，还并不敢苟同这样的观念。于是，在进步到某个阶段的时候，就缴械投降，遂而前功尽弃了。</strong> </p>\n<p>有一种观点或者说法很流行:童年时代才是学习语言的最佳年纪，所以当我们长大以后，即使学习了很多年的英语，依然不能开口流利说英语。这样的观点之所以深受认可是因为我们小时候开始学习汉语长大后可以用汉语口若悬河地表达，但成年后即使学习英语时间看似并不比汉语少，很多人依然在英语表达上结巴的表面事实。不过，私以为，这样的观点并非正确，与之相反，我依然深信表面上童年确实是学习语言的最佳时机，但如果能够洞察这里的真相和原因，我们可以从中获得关于如何学习语言的启发，也有足够的的理由相信，语言的学习和掌握，和年纪没有多大关系，而且由于成年人具备更好的学习能力，学习语言可以更加的有效率。 </p>\n<p><strong>那么为什么懵懂的孩童时代学习语言进步显著，而认知能力和学习能力已经今非昔比的成人学习语言却举步维艰?在我看来是因为前者在学习语言的时间和精力上投入比后者多出很多</strong>。我能预知到这并非是一句能够让人轻易信服的结论，毕竟以我个人经历而言，经过小学六年的学习实践，自己已经具备初步的汉语表达能力，著书立说尚且有待时日，但与人日常攀谈，向来得心应手。但从初中到大学学习了10年的英语，在你摩拳擦掌，准备开口说的时候，此刻他们却纷纷打地鼠一般给你玩捉迷藏，以至于你憋红了脸，也只能支支吾吾，拼凑出词不达意，漏洞百出的词句。养兵千日，期待着有朝一日可以用兵，却发现无计可施，还有什么比这个更令人沮丧?以至于让多少人，放弃了坚持。 </p>\n<p>那么很多人都会疑问，我们学习汉语的时间怎么会比英语多呢?这里的玄机在于我们计算语言学习的时间有失偏颇，我们学习汉语并非只是在语文课上，我们上数学课也是用汉语，由于我们的生活环境，日常的交流也是用汉语，甚至到了中学我们的生物、物理、化学、地理、政治、历史课等除了英语课外所有的科目，还有我们所阅读的课外读物都是汉语，所以虽然只有六年的时间，但在这短短的时间里面因为我们所处的环境，使得我们有意无意地接收大量的的听说读写能力的训练和强化。而英语则并非如此。 </p>\n<p><strong>所以，我们的英语能力差强人意，根源在于我们投入的训练和实践远远不够。</strong> </p>\n<p>使用工具是人类的天赋，而借助工具，或者外界力量用于辅助学习是一个很可取的选择。只是学习知识是一个将知识吸收内化的过程。当我们在学习的过程中，受挫，我们总是会感到沮丧，对自己失去信心。会有倾向求助于外界，期望有高人从天而降，对我们指点迷津，或者像神明一般施加法力，直接帮我们脱离苦海，比如我们会去报名参加培训，找老师，使用各种各样的APP。但这并不现实。师傅只是领进门，修行还是靠个人。学习这个过程大部分的工作还需要我们自己去完成。如果寻求外界获得成功，取得进步的决定性因素，并非是他们，而是因为你深度参与其中实践。<strong>归根结底，他们都遵循，学习的本质是不断去亲身训练这一基本原则。所以，不管采取什么学习方法，有一点需要明白，万事求诸己。</strong> </p>\n<h1 id=\"如何训练和实践\"><a href=\"#如何训练和实践\" class=\"headerlink\" title=\"如何训练和实践\"></a>如何训练和实践</h1><p>不可否认，学习又是一件艰难漫长的过程。<strong>所以，坚持本身至关重要。而坚持，归根结底是坚持训练。</strong> </p>\n<p><strong>具体如何坚持训练呢？想必不是起早贪黑，狂背单词，或者捧着英文教科书念念有词，那样太辛苦了。于我而言，把自己接触的资讯全都切换为英文的，就好啦。将自己的手机，电脑语言切换成英语，所阅读的专业、非专业书籍也几乎是英文，平时多阅读英文文档呀，刷刷推特。不用特地投入时间学英语，但却在日如一日的重复里，慢慢地就可以感觉到进步和蜕变了。</strong> </p>\n<p>练习听力，阅读文字只是输入式的训练，真正而更加有效的训练方式，应该是输出，也就是写作和口语表达。当我们在做输入式训练的时候，其实我们可以不怎么动脑的，甚至当时心不在焉。所以，只有输入式训练的话，进步的道路步履维艰， </p>\n<p>学习时间里，听说读写的训练，想必都不会有多大的问题。每个学习英语的成年中国人最大的问题在于，由于他们已经擅长汉语，在时间长出很多的非学习时间里，也就是日常生活中，他们习惯性地用汉语思考，因为用汉语可以很流畅，但用外语在屡屡碰壁，而语言是思考的载体，所以<strong>思考才是训练的核心</strong>。就像我们解题，阅读题目思考设计解答方案才是解题的核心，在纸上将答案表达出来不过是将思考输出。而这，就很好地解释了为什么小孩学习英语比较容易，因为当时他们的汉语与英语势均力敌，不像成年人，因为选择舒适的方式，不断地训练，强化了汉语，导致即使特别花时间精力对英语特别扶贫，也缩短不了他们的贫富差距。一方面我们做了大量的输入式训练，另一方面刻意规避输出式的训练，而这，正是，很多人学习英语，却收效甚微的根结所在。至于连输入式训练都没有的人，结果如何，自不必说。 </p>\n<p><strong>我们可以尝试着用英语去描述自己的所见所闻和所思所想，不懂的记录下来查询辞典。比如站在十字街头，会想到intersection，懂得词汇之后，可以尝试遣词造句，进一步地训练表达内容思想更加丰富的句子和短文，这些动作都是需要我们动脑思考的，是有效训练的很好实践。</strong> </p>\n<h1 id=\"好的学习方法\"><a href=\"#好的学习方法\" class=\"headerlink\" title=\"好的学习方法\"></a>好的学习方法</h1><p><strong><em>Practice makes perfect</em>。但很遗憾，坚持训练本身很多人没能坚持下来。因为抽象来看，学习过程就是运用自己心智，与学习本身自带的诸多困难对抗，如图1。当屡屡受挫，你感知到的困难已经超越了自己的解决能力，放弃是一种明智和无奈的选择。</strong>  </p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/487b6f7ecd3e3944.webp\"></p>\n<p><strong>学习过程会屡屡碰壁，好的学习方法，应该要能够降低这种困难，减少斜坡的倾角。我们应该寻找和掌握一种方法，让学习如丝般顺滑，而不是举步维艰。</strong>说到坚持练习，比如经常阅读英文书籍，但很少能够寻找到为自己词汇水平的资料，一个短句好几个单词都不懂，阅读一整页下来，不知所云，长久以往，很少有人能够保持热情与耐心继续阅读下去，即使做到，感觉也没有多大意义，因为虽然你过目了，但你依然没有掌握认识它，顶多似曾相识。<strong>此时，身边有一本辞典，就显得尤为重要，它可以将这种困难降低到几乎为零的程度，遇到不懂的单词，即刻查询。通过自己所阅读的资料为主线，扩充自己的词汇量。</strong> </p>\n<p>所谓工欲善其事，必先利其器。当遇到不懂的单词，比如malicious，在有道或者Google翻译里面查询，能得到的只有其翻译，也许还会花点心思查看下对应的同义词、反义词、同根词。但这种学习方式不过是建立英文单词与汉语释义单一的映射，这是一种硬编码，记忆效率极其低下。可曾记得小学时候，我们为了记忆九九乘法表，花了一个星期的时间，天天背诵，终于烙印在脑里。 </p>\n<p>自己在使用英文资料学习编程的过程中，时常在思索如何解决快速索引释义的问题，偶然而又幸运的是，意外发现了GoldenDict辞典软件，如图2，它并本身并不提供任何辞典，但它支持种类繁多的辞典格式，与它们搭档，使得GoldenDict在众多辞典软件里所向披靡。我安装了好几部英英辞典，里面提供完整的释义，词组，相关的同义词和丰富的例句。我喜欢这种像神经网络一样，在与他物联系中记忆的方式，短时间内阅读辞典查询结果，可能不如狂背一百遍的记忆效果好，但我对自己的方法爱不释手，毕竟，单词并非独立的存在，它需要和其他单词组合拼凑成句子，才能构建表达完整的含义，也只有知道了组合后，我们才有可能学以致用。在丰富的组合连接之下，每个单词不再是一座孤岛，在记忆的深处都有迹可循，长期以往，这样可以有效地构建我们丰富的语言体系，和表达能力。毕竟，表达和思考，本质上无非就是向记忆索取词汇，但凡词汇索引建的好，这个过程就不会吃力。而单独记忆单词的结果是知道中文含义，但不知道如何使用，真的开口说话时，更是哑口无言，或者词不能大意。同时我很讨厌背诵，在时常检查背诵的初中时代，自己有过不幸被老师点名，在全班同学面前背诵文言文，却背不出一个完整的段落，申请背诵另外一篇，没想到依然差强人意。兴许是屡次三番摘得年级桂冠光芒的照耀，老师同学只是爆发出慈眉善目的笑声，险过一关。不过值得一提的是，时至今日，我依然记得初中课文里出现的几个句子“天下事有难易乎?为之，则难者亦易矣;不为，则易者亦难矣。人之为学有难易乎?学之，则难者亦易矣;不学，则易者亦难矣。” </p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/69bc4729f629349e.webp\">)</p>\n<p>1，“无他，但手熟尔”2，“故不积跬步，无以至千里;不积小流，无以成江海。”3,“世之奇伟、瑰怪、非常之观，常在险远，而人之所罕至焉，故非有志者不能至也。”4它们启发与激励着我，每每灰心丧气的时候，鼓舞自己，再坚持一下。 </p>\n<h1 id=\"关于记忆\"><a href=\"#关于记忆\" class=\"headerlink\" title=\"关于记忆\"></a>关于记忆</h1><p>我当然认为记忆本身很重要，只是觉得应该追本溯源，记忆最原始，源头的部分，因为这些内容是朴素的，简洁的，内容少很容易记，其他的内容，可以通过记忆的内容通过推理、推到得出，是故没有必要滥用珍贵的记忆资源。 </p>\n<p>举个例子: </p>\n<p>cos(A+B) = cosA∗cosB −sinA∗sinB (1)</p>\n<p>sin(A+B) = sinA∗sinB +cosA∗cosB (2)</p>\n<p>tan(A+B) = sin(A+B)/cos(A+B) = (tanA∗tanB+1)/(1−tanA∗tanB) (3)</p>\n<p>如上数学公式还记得吧?当年的女数学老师只是用复杂的方法证明其正确，却没有教会我们如何推理记忆。那时，同学们只能靠大量的解题，在重复的训练中强化记忆，但只要训练中断时日，记忆可能就会出现偏差。 </p>\n<p>但其实，只需要记得图3矩形框里的几何图形及其意义，上面一系列相关的公式可以一字不落地推理得出，简洁直观，一目了然。 </p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/0d1a20ecab37a4d3.webp\"></p>\n<p>af ∗ cos(A + B) = ac − ef (4)</p>\n<p>ac−ef = af ∗cosA∗cosB −af ∗sinA∗sinB (5)</p>\n<p>由 (4) 和 (5) 我们可得(1) </p>\n<p>对于理工科而言，单纯的记忆结果除了提高解题速度，应付考试，是没有多大功用的，因为它很容易遗忘。重要的是理解简化推理论证的过程，或者最原始基本的定义，通过定义和推理关键步骤，整个知识版图都可以顺藤摸瓜探索出来。 </p>\n<h1 id=\"如何记忆单词\"><a href=\"#如何记忆单词\" class=\"headerlink\" title=\"如何记忆单词\"></a>如何记忆单词</h1><p>其实，感觉很多人都懂这些，但为了完整性，还是罗列一下，因为自己本身也不专业，一笔带过吧。 </p>\n<h2 id=\"按音节记忆单词\"><a href=\"#按音节记忆单词\" class=\"headerlink\" title=\"按音节记忆单词\"></a>按音节记忆单词</h2><p>刚接触英语时，貌似是老师这么教我们b-i-k-e bike，初学时无可厚非。在入门后，就应该按照音节来辅助记忆了，辅音一般不变，元音虽然时常有好几种发音，但多是相对固定，我记得初中英语教科书上有这样的汇总表格，但自己平时留意，也可以总结出常用的规律。比如i发aɪ音，所以从拼写可以推断出发音，bike念作baɪk，从发音可以推断出拼写，baɪk其拼写为bike。 </p>\n<h2 id=\"词根词缀\"><a href=\"#词根词缀\" class=\"headerlink\" title=\"词根词缀\"></a>词根词缀</h2><p>mature有成熟，完善之意，pre有在前，前面之意，所以premature就表示早熟，或者引申为早产。具体可以搜索参考词根词缀记忆领域的书籍。 </p>\n<h2 id=\"系统学习\"><a href=\"#系统学习\" class=\"headerlink\" title=\"系统学习\"></a>系统学习</h2><p>按照情景或者场景系统地学习词汇和用法，比如房子的物品名称，以及其相关的动词和对话表达，如图4。 </p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/b8518865846f4d62.webp\"></p>\n<p>学到的词汇要平时多用，听说读写最好雨露均沾。 </p>\n<h1 id=\"审慎对待任何学习方法\"><a href=\"#审慎对待任何学习方法\" class=\"headerlink\" title=\"审慎对待任何学习方法\"></a>审慎对待任何学习方法</h1><p>中学时代，曾经在书籍上阅读过一段文字，某君总结自己的学习经验时，将自己英语听力的提高归功于自己平时听英文歌曲。于是自己也尝试着去听英文歌。但过了些时日，并没有感觉到听力明显的提升，但也许是自己练习不够，也许自己听的时候并没有全神贯注的听，当然，还有可能这种方法本身就不可能奏效。理论上，只要练习，总会有进步的，但私以为这样的方法收效甚微，毕竟，如果单词你本来就不懂，你是很难通过听来学习掌握的。首先，你得会识字，以此为前提，你可以听懂和表达。意识到这些，已经是多年以后了，以至于，在后来，又几乎重蹈覆辙。 </p>\n<p>在书店发现一本书，书名叫《千万别学英语》，有些标新立异，就捧读起来。一本书的厚度，但里面的内容如果没记错的话，总结起来，大概是每天都听两遍磁带，每周固定休息一天。作者的观点是，我们大脑学习语言的部分，也需要休息整顿。并危言耸听道，如果不在休息日绝对不能接触英语，将前功尽弃。我仿佛在地摊上发现了练得一身上乘武功的武林秘籍，只要按部就班地模仿学习，在武林上雄霸一方指日可待，喜悦之前，溢于言表，开始憧憬创造奇迹的未来。后来的结果，如大家所料，并没有什么意外。依然收效甚微，在英语的学习上依旧艰难前进。如果没有记错，书里还提到一点，就是把听不懂的单词特别标注出来，使用最新的英英词典查询(他批判长辈把辞典馈赠给子女用的行为，认为辞典日新月异，祖传的都已经不合时宜)。 </p>\n<p>这里并没有否定他们学习方法的意思，我觉得每个人的学习方法都可以不同，都是在刻苦练习，殊途同归。也许他们的方法确实帮助他们掌握了英语，也许是他们实践中的某个环节起到了决定性的作用，只是他自己都没能意识到，于是总结自己经验时，出了偏差。分享自己成功学习经验的行为，我觉得这本身就很值得褒奖。只是，以我现在的处事原则来看，任何一种结论，言辞，都要思辨、审慎地对待，汲取合理有效的部分，不能盲从，包括此篇。 </p>\n<p>李阳的疯狂英语，也在事实上影响了很多人，我没怎么接触过，也就不予置评了。但曾经在南方周末看过毛坦厂中学的报道，学生起早贪黑，在操场上捧着书，像疯子一样大声朗读。我想说，每个人都有自己的学习方法，爱怎么整都是自己的事情，只是，学习应该是一件轻松愉悦的事情，没必要头悬梁锥刺股，整的与自己为敌。同时也应该多比较他人的学习方法，师夷长技，博采众长，为自己所用，相信很多人都认同，闭门造车往往进度条滚动太慢。 </p>\n<h1 id=\"宽容的环境\"><a href=\"#宽容的环境\" class=\"headerlink\" title=\"宽容的环境\"></a>宽容的环境</h1><p>很多人学了很多年的英语，终归不会开口流利地表达自己的想法和感受，归根结底在于我们过多的注重孤立的词汇和语法学习，没有系统地学习词汇，没有学习丰富的词组，更缺少平时的开口表达。 </p>\n<p>在缺少表达的问题上，很多人简单的归因为身边没有外国朋友可以交流实践。但其实，这是一个伪命题。退一步说，假设真有一位外国友人如神兵天降于你身边，你也很少有机会可以开口实践，毕竟，人家也是人，实在无法做到和一位词不达意，说话结巴的人，和颜悦色地交流。也就是说，在你想和别人交流时，自身必须达到一定的表达能力，而在此之前，一切都靠自学，或者和自己水平相当的伙伴协同学习。试想那些咿呀学语的婴孩，也就只有父母家人才有耐心和热情陪同重复那些简单的词汇语句，以此教导他的语言能力。 </p>\n<p>由于很多人掌握的词汇支离破碎，常常并不足以表达一个完整的句子，此时采用中英结合的方式，倒是不错的选择。但问题在于，有人很厌恶这样的举动，并公开地排斥。甚至，有人会厌恶那些在中国说着英语的中国人，他们认为，在中国就该讲中国话，是中国人就该讲中国话，爱国就应该讲国语。或者仅仅英语不合他们自己接收信息的习惯方式，就足以在内心产生抵触。暂且不深入展开他们的逻辑，但可以想象，有这样的现象存在，那些想实践英语的人，自然面对更多的困难和挑战。当然，我们可以选择忽视他们的意见，我们也需要有勇气直面他们的反对，并踽踽而行，毕竟，他们并非正确，真理也并非掌握在他们手上。不得不承认他们不过是在言论自由的框架之下表达自己的反对意见，对此我自然也不能有什么指摘，只是希望，这些人，特别是公众人物，在自由地表达自己的意见时，能够明白自己言行的后果，从而在情不自禁的随口一说时，更加审慎一些。 </p>\n<h1 id=\"GodenDict-安装\"><a href=\"#GodenDict-安装\" class=\"headerlink\" title=\"GodenDict 安装\"></a>GodenDict 安装</h1><p>下载链接: <a href=\"https://pan.baidu.com/s/1oV6AxRUlX1c7mpE352bt8w\">https://pan.baidu.com/s/1oV6AxRUlX1c7mpE352bt8w</a> 提取码: uxtw </p>\n<h2 id=\"Windows-amp-Mac\"><a href=\"#Windows-amp-Mac\" class=\"headerlink\" title=\"Windows &amp; Mac\"></a>Windows &amp; Mac</h2><ol>\n<li>下载GodenDict应用程序：<ol>\n<li>Mac： GoldenDict-1.5.0-RC2-209-gfe9312e(Qt_563)</li>\n<li>Windows： GoldenDict-1.0.1-Portable</li>\n</ol>\n</li>\n<li>下载词典文件并解压<ol>\n<li>En-En-Longman_Pronunciation3.zip</li>\n<li>En-En_OALD8.zip</li>\n<li>En-En_Merriam_Webster11</li>\n<li>En-zh_CN_OALD4</li>\n<li>En-En_Longman_DOCE5</li>\n</ol>\n</li>\n<li>GodenDic 安装完毕，打开Dictionary菜单，在如下界面点击Add，将解压的词典目录逐个添加，完成后点击Rescan now，程序建立索引。</li>\n</ol>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/305a1480dcfc9dbd.png\"></p>\n<p>Mac上会有如下界面异常，</p>\n<img src=\"https://s3.bmp.ovh/imgs/2021/08/bad36e68350614d4.png\" style=\"zoom:100%;\" />\n\n<p>点击Preference菜单，如下截图勾选“Expand optional parts”</p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/f3565b6d9c3abefc.png\"></p>\n<p>最后，可以把这个选项勾选。</p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/79f7c59f09d94491.png\"></p>\n<h2 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h2><ol>\n<li>下载Android APK并安装：<a href=\"http://goldendict.mobi/downloads/android/free/\">下载链接</a></li>\n<li>下载词典文件：上一节百度云 Android 目录（此目录下的文件是从词典文件压缩包里面提取，去掉音频和图片，以减少手机存储占用）</li>\n<li>将下载的词典文件存放于手机根目录的：GoldenDict 文件夹（注意命名，大小写完全一致）</li>\n<li>手机上打开GoldenDict，此时先建立索引，完毕就可以正常使用。</li>\n</ol>\n<h2 id=\"iOS：\"><a href=\"#iOS：\" class=\"headerlink\" title=\"iOS：\"></a>iOS：</h2><p>尚未支持，可以考虑使用欧路词典或其他，并按照类似思路，安装词典即可。</p>\n<h1 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h1><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>写作的基础是正确的语法，语法书我只推荐这本：<a href=\"http://grammar.codeyu.com/\">旋元佑进阶文法</a> ，推荐阅读第一章的基本句型和第十六七章的合句和名词子句，就能感同身受，此书是否值得细读了。或者参考<a href=\"https://book.douban.com/subject/34840714/\">豆瓣的评价</a>。</p>\n<h2 id=\"写作课程\"><a href=\"#写作课程\" class=\"headerlink\" title=\"写作课程\"></a>写作课程</h2><p><a href=\"https://www.coursera.org/specializations/academic-english\">Academic English: Writing Specialization</a></p>\n<p><a href=\"https://online.stanford.edu/courses/som-y0010-writing-sciences\">Writing in the Sciences</a></p>\n<p>其他的就不做推荐了，相信每个人都可以寻找到适合自己的资料。</p>\n<p><strong>如果本文令你受益匪浅，愿意慷慨解囊，可以看这里，一分也是爱。分享推荐给身边的朋友，也是不胜感激</strong></p>\n<img src=\"https://s3.bmp.ovh/imgs/2021/08/05d5219d41934cc5.png\" style=\"zoom:25%;\" />\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"英语自学指南\"><a href=\"#英语自学指南\" class=\"headerlink\" title=\"英语自学指南\"></a>英语自学指南</h1><p>Email: <a href=\"mailto:&#108;&#x69;&#x6d;&#120;&#116;&#111;&#112;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;\">&#108;&#x69;&#x6d;&#120;&#116;&#111;&#112;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a></p>\n<h1 id=\"自学掌握语言的根本方法\"><a href=\"#自学掌握语言的根本方法\" class=\"headerlink\" title=\"自学掌握语言的根本方法\"></a>自学掌握语言的根本方法</h1><p><strong>天道酬勤!</strong> </p>\n<p>理论上，不仅是英语学科，其他大部分知识的学习，只要投入足够的时间和运用合理的技巧，大体上，总是可以学好的。 </p>\n<p>有些知识，比如无人驾驶，因为跨越很多学科，并建立在诸多基础知识之上，所以，门槛很高，学习周期漫长，过程自然也费劲许多。但就英语而言，虽然也有难度，但只要方法得当，努力耕耘，也可以水到渠成，瓜熟蒂落。 </p>\n<p>我认为意识到这点很重要，<strong>唯有当你坚信自己通过不懈的努力，有能力完成这个学习目标，掌握以前久攻不下的英语。你才有恒心和毅力，在学习过程中遇到诸多挫折之后，依然百折不挠地前进。</strong> </p>\n<p><strong>但很遗憾，感觉很多人并没有意识到这点，甚至更加糟糕的是，还并不敢苟同这样的观念。于是，在进步到某个阶段的时候，就缴械投降，遂而前功尽弃了。</strong> </p>\n<p>有一种观点或者说法很流行:童年时代才是学习语言的最佳年纪，所以当我们长大以后，即使学习了很多年的英语，依然不能开口流利说英语。这样的观点之所以深受认可是因为我们小时候开始学习汉语长大后可以用汉语口若悬河地表达，但成年后即使学习英语时间看似并不比汉语少，很多人依然在英语表达上结巴的表面事实。不过，私以为，这样的观点并非正确，与之相反，我依然深信表面上童年确实是学习语言的最佳时机，但如果能够洞察这里的真相和原因，我们可以从中获得关于如何学习语言的启发，也有足够的的理由相信，语言的学习和掌握，和年纪没有多大关系，而且由于成年人具备更好的学习能力，学习语言可以更加的有效率。 </p>\n<p><strong>那么为什么懵懂的孩童时代学习语言进步显著，而认知能力和学习能力已经今非昔比的成人学习语言却举步维艰?在我看来是因为前者在学习语言的时间和精力上投入比后者多出很多</strong>。我能预知到这并非是一句能够让人轻易信服的结论，毕竟以我个人经历而言，经过小学六年的学习实践，自己已经具备初步的汉语表达能力，著书立说尚且有待时日，但与人日常攀谈，向来得心应手。但从初中到大学学习了10年的英语，在你摩拳擦掌，准备开口说的时候，此刻他们却纷纷打地鼠一般给你玩捉迷藏，以至于你憋红了脸，也只能支支吾吾，拼凑出词不达意，漏洞百出的词句。养兵千日，期待着有朝一日可以用兵，却发现无计可施，还有什么比这个更令人沮丧?以至于让多少人，放弃了坚持。 </p>\n<p>那么很多人都会疑问，我们学习汉语的时间怎么会比英语多呢?这里的玄机在于我们计算语言学习的时间有失偏颇，我们学习汉语并非只是在语文课上，我们上数学课也是用汉语，由于我们的生活环境，日常的交流也是用汉语，甚至到了中学我们的生物、物理、化学、地理、政治、历史课等除了英语课外所有的科目，还有我们所阅读的课外读物都是汉语，所以虽然只有六年的时间，但在这短短的时间里面因为我们所处的环境，使得我们有意无意地接收大量的的听说读写能力的训练和强化。而英语则并非如此。 </p>\n<p><strong>所以，我们的英语能力差强人意，根源在于我们投入的训练和实践远远不够。</strong> </p>\n<p>使用工具是人类的天赋，而借助工具，或者外界力量用于辅助学习是一个很可取的选择。只是学习知识是一个将知识吸收内化的过程。当我们在学习的过程中，受挫，我们总是会感到沮丧，对自己失去信心。会有倾向求助于外界，期望有高人从天而降，对我们指点迷津，或者像神明一般施加法力，直接帮我们脱离苦海，比如我们会去报名参加培训，找老师，使用各种各样的APP。但这并不现实。师傅只是领进门，修行还是靠个人。学习这个过程大部分的工作还需要我们自己去完成。如果寻求外界获得成功，取得进步的决定性因素，并非是他们，而是因为你深度参与其中实践。<strong>归根结底，他们都遵循，学习的本质是不断去亲身训练这一基本原则。所以，不管采取什么学习方法，有一点需要明白，万事求诸己。</strong> </p>\n<h1 id=\"如何训练和实践\"><a href=\"#如何训练和实践\" class=\"headerlink\" title=\"如何训练和实践\"></a>如何训练和实践</h1><p>不可否认，学习又是一件艰难漫长的过程。<strong>所以，坚持本身至关重要。而坚持，归根结底是坚持训练。</strong> </p>\n<p><strong>具体如何坚持训练呢？想必不是起早贪黑，狂背单词，或者捧着英文教科书念念有词，那样太辛苦了。于我而言，把自己接触的资讯全都切换为英文的，就好啦。将自己的手机，电脑语言切换成英语，所阅读的专业、非专业书籍也几乎是英文，平时多阅读英文文档呀，刷刷推特。不用特地投入时间学英语，但却在日如一日的重复里，慢慢地就可以感觉到进步和蜕变了。</strong> </p>\n<p>练习听力，阅读文字只是输入式的训练，真正而更加有效的训练方式，应该是输出，也就是写作和口语表达。当我们在做输入式训练的时候，其实我们可以不怎么动脑的，甚至当时心不在焉。所以，只有输入式训练的话，进步的道路步履维艰， </p>\n<p>学习时间里，听说读写的训练，想必都不会有多大的问题。每个学习英语的成年中国人最大的问题在于，由于他们已经擅长汉语，在时间长出很多的非学习时间里，也就是日常生活中，他们习惯性地用汉语思考，因为用汉语可以很流畅，但用外语在屡屡碰壁，而语言是思考的载体，所以<strong>思考才是训练的核心</strong>。就像我们解题，阅读题目思考设计解答方案才是解题的核心，在纸上将答案表达出来不过是将思考输出。而这，就很好地解释了为什么小孩学习英语比较容易，因为当时他们的汉语与英语势均力敌，不像成年人，因为选择舒适的方式，不断地训练，强化了汉语，导致即使特别花时间精力对英语特别扶贫，也缩短不了他们的贫富差距。一方面我们做了大量的输入式训练，另一方面刻意规避输出式的训练，而这，正是，很多人学习英语，却收效甚微的根结所在。至于连输入式训练都没有的人，结果如何，自不必说。 </p>\n<p><strong>我们可以尝试着用英语去描述自己的所见所闻和所思所想，不懂的记录下来查询辞典。比如站在十字街头，会想到intersection，懂得词汇之后，可以尝试遣词造句，进一步地训练表达内容思想更加丰富的句子和短文，这些动作都是需要我们动脑思考的，是有效训练的很好实践。</strong> </p>\n<h1 id=\"好的学习方法\"><a href=\"#好的学习方法\" class=\"headerlink\" title=\"好的学习方法\"></a>好的学习方法</h1><p><strong><em>Practice makes perfect</em>。但很遗憾，坚持训练本身很多人没能坚持下来。因为抽象来看，学习过程就是运用自己心智，与学习本身自带的诸多困难对抗，如图1。当屡屡受挫，你感知到的困难已经超越了自己的解决能力，放弃是一种明智和无奈的选择。</strong>  </p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/487b6f7ecd3e3944.webp\"></p>\n<p><strong>学习过程会屡屡碰壁，好的学习方法，应该要能够降低这种困难，减少斜坡的倾角。我们应该寻找和掌握一种方法，让学习如丝般顺滑，而不是举步维艰。</strong>说到坚持练习，比如经常阅读英文书籍，但很少能够寻找到为自己词汇水平的资料，一个短句好几个单词都不懂，阅读一整页下来，不知所云，长久以往，很少有人能够保持热情与耐心继续阅读下去，即使做到，感觉也没有多大意义，因为虽然你过目了，但你依然没有掌握认识它，顶多似曾相识。<strong>此时，身边有一本辞典，就显得尤为重要，它可以将这种困难降低到几乎为零的程度，遇到不懂的单词，即刻查询。通过自己所阅读的资料为主线，扩充自己的词汇量。</strong> </p>\n<p>所谓工欲善其事，必先利其器。当遇到不懂的单词，比如malicious，在有道或者Google翻译里面查询，能得到的只有其翻译，也许还会花点心思查看下对应的同义词、反义词、同根词。但这种学习方式不过是建立英文单词与汉语释义单一的映射，这是一种硬编码，记忆效率极其低下。可曾记得小学时候，我们为了记忆九九乘法表，花了一个星期的时间，天天背诵，终于烙印在脑里。 </p>\n<p>自己在使用英文资料学习编程的过程中，时常在思索如何解决快速索引释义的问题，偶然而又幸运的是，意外发现了GoldenDict辞典软件，如图2，它并本身并不提供任何辞典，但它支持种类繁多的辞典格式，与它们搭档，使得GoldenDict在众多辞典软件里所向披靡。我安装了好几部英英辞典，里面提供完整的释义，词组，相关的同义词和丰富的例句。我喜欢这种像神经网络一样，在与他物联系中记忆的方式，短时间内阅读辞典查询结果，可能不如狂背一百遍的记忆效果好，但我对自己的方法爱不释手，毕竟，单词并非独立的存在，它需要和其他单词组合拼凑成句子，才能构建表达完整的含义，也只有知道了组合后，我们才有可能学以致用。在丰富的组合连接之下，每个单词不再是一座孤岛，在记忆的深处都有迹可循，长期以往，这样可以有效地构建我们丰富的语言体系，和表达能力。毕竟，表达和思考，本质上无非就是向记忆索取词汇，但凡词汇索引建的好，这个过程就不会吃力。而单独记忆单词的结果是知道中文含义，但不知道如何使用，真的开口说话时，更是哑口无言，或者词不能大意。同时我很讨厌背诵，在时常检查背诵的初中时代，自己有过不幸被老师点名，在全班同学面前背诵文言文，却背不出一个完整的段落，申请背诵另外一篇，没想到依然差强人意。兴许是屡次三番摘得年级桂冠光芒的照耀，老师同学只是爆发出慈眉善目的笑声，险过一关。不过值得一提的是，时至今日，我依然记得初中课文里出现的几个句子“天下事有难易乎?为之，则难者亦易矣;不为，则易者亦难矣。人之为学有难易乎?学之，则难者亦易矣;不学，则易者亦难矣。” </p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/69bc4729f629349e.webp\">)</p>\n<p>1，“无他，但手熟尔”2，“故不积跬步，无以至千里;不积小流，无以成江海。”3,“世之奇伟、瑰怪、非常之观，常在险远，而人之所罕至焉，故非有志者不能至也。”4它们启发与激励着我，每每灰心丧气的时候，鼓舞自己，再坚持一下。 </p>\n<h1 id=\"关于记忆\"><a href=\"#关于记忆\" class=\"headerlink\" title=\"关于记忆\"></a>关于记忆</h1><p>我当然认为记忆本身很重要，只是觉得应该追本溯源，记忆最原始，源头的部分，因为这些内容是朴素的，简洁的，内容少很容易记，其他的内容，可以通过记忆的内容通过推理、推到得出，是故没有必要滥用珍贵的记忆资源。 </p>\n<p>举个例子: </p>\n<p>cos(A+B) = cosA∗cosB −sinA∗sinB (1)</p>\n<p>sin(A+B) = sinA∗sinB +cosA∗cosB (2)</p>\n<p>tan(A+B) = sin(A+B)/cos(A+B) = (tanA∗tanB+1)/(1−tanA∗tanB) (3)</p>\n<p>如上数学公式还记得吧?当年的女数学老师只是用复杂的方法证明其正确，却没有教会我们如何推理记忆。那时，同学们只能靠大量的解题，在重复的训练中强化记忆，但只要训练中断时日，记忆可能就会出现偏差。 </p>\n<p>但其实，只需要记得图3矩形框里的几何图形及其意义，上面一系列相关的公式可以一字不落地推理得出，简洁直观，一目了然。 </p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/0d1a20ecab37a4d3.webp\"></p>\n<p>af ∗ cos(A + B) = ac − ef (4)</p>\n<p>ac−ef = af ∗cosA∗cosB −af ∗sinA∗sinB (5)</p>\n<p>由 (4) 和 (5) 我们可得(1) </p>\n<p>对于理工科而言，单纯的记忆结果除了提高解题速度，应付考试，是没有多大功用的，因为它很容易遗忘。重要的是理解简化推理论证的过程，或者最原始基本的定义，通过定义和推理关键步骤，整个知识版图都可以顺藤摸瓜探索出来。 </p>\n<h1 id=\"如何记忆单词\"><a href=\"#如何记忆单词\" class=\"headerlink\" title=\"如何记忆单词\"></a>如何记忆单词</h1><p>其实，感觉很多人都懂这些，但为了完整性，还是罗列一下，因为自己本身也不专业，一笔带过吧。 </p>\n<h2 id=\"按音节记忆单词\"><a href=\"#按音节记忆单词\" class=\"headerlink\" title=\"按音节记忆单词\"></a>按音节记忆单词</h2><p>刚接触英语时，貌似是老师这么教我们b-i-k-e bike，初学时无可厚非。在入门后，就应该按照音节来辅助记忆了，辅音一般不变，元音虽然时常有好几种发音，但多是相对固定，我记得初中英语教科书上有这样的汇总表格，但自己平时留意，也可以总结出常用的规律。比如i发aɪ音，所以从拼写可以推断出发音，bike念作baɪk，从发音可以推断出拼写，baɪk其拼写为bike。 </p>\n<h2 id=\"词根词缀\"><a href=\"#词根词缀\" class=\"headerlink\" title=\"词根词缀\"></a>词根词缀</h2><p>mature有成熟，完善之意，pre有在前，前面之意，所以premature就表示早熟，或者引申为早产。具体可以搜索参考词根词缀记忆领域的书籍。 </p>\n<h2 id=\"系统学习\"><a href=\"#系统学习\" class=\"headerlink\" title=\"系统学习\"></a>系统学习</h2><p>按照情景或者场景系统地学习词汇和用法，比如房子的物品名称，以及其相关的动词和对话表达，如图4。 </p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/b8518865846f4d62.webp\"></p>\n<p>学到的词汇要平时多用，听说读写最好雨露均沾。 </p>\n<h1 id=\"审慎对待任何学习方法\"><a href=\"#审慎对待任何学习方法\" class=\"headerlink\" title=\"审慎对待任何学习方法\"></a>审慎对待任何学习方法</h1><p>中学时代，曾经在书籍上阅读过一段文字，某君总结自己的学习经验时，将自己英语听力的提高归功于自己平时听英文歌曲。于是自己也尝试着去听英文歌。但过了些时日，并没有感觉到听力明显的提升，但也许是自己练习不够，也许自己听的时候并没有全神贯注的听，当然，还有可能这种方法本身就不可能奏效。理论上，只要练习，总会有进步的，但私以为这样的方法收效甚微，毕竟，如果单词你本来就不懂，你是很难通过听来学习掌握的。首先，你得会识字，以此为前提，你可以听懂和表达。意识到这些，已经是多年以后了，以至于，在后来，又几乎重蹈覆辙。 </p>\n<p>在书店发现一本书，书名叫《千万别学英语》，有些标新立异，就捧读起来。一本书的厚度，但里面的内容如果没记错的话，总结起来，大概是每天都听两遍磁带，每周固定休息一天。作者的观点是，我们大脑学习语言的部分，也需要休息整顿。并危言耸听道，如果不在休息日绝对不能接触英语，将前功尽弃。我仿佛在地摊上发现了练得一身上乘武功的武林秘籍，只要按部就班地模仿学习，在武林上雄霸一方指日可待，喜悦之前，溢于言表，开始憧憬创造奇迹的未来。后来的结果，如大家所料，并没有什么意外。依然收效甚微，在英语的学习上依旧艰难前进。如果没有记错，书里还提到一点，就是把听不懂的单词特别标注出来，使用最新的英英词典查询(他批判长辈把辞典馈赠给子女用的行为，认为辞典日新月异，祖传的都已经不合时宜)。 </p>\n<p>这里并没有否定他们学习方法的意思，我觉得每个人的学习方法都可以不同，都是在刻苦练习，殊途同归。也许他们的方法确实帮助他们掌握了英语，也许是他们实践中的某个环节起到了决定性的作用，只是他自己都没能意识到，于是总结自己经验时，出了偏差。分享自己成功学习经验的行为，我觉得这本身就很值得褒奖。只是，以我现在的处事原则来看，任何一种结论，言辞，都要思辨、审慎地对待，汲取合理有效的部分，不能盲从，包括此篇。 </p>\n<p>李阳的疯狂英语，也在事实上影响了很多人，我没怎么接触过，也就不予置评了。但曾经在南方周末看过毛坦厂中学的报道，学生起早贪黑，在操场上捧着书，像疯子一样大声朗读。我想说，每个人都有自己的学习方法，爱怎么整都是自己的事情，只是，学习应该是一件轻松愉悦的事情，没必要头悬梁锥刺股，整的与自己为敌。同时也应该多比较他人的学习方法，师夷长技，博采众长，为自己所用，相信很多人都认同，闭门造车往往进度条滚动太慢。 </p>\n<h1 id=\"宽容的环境\"><a href=\"#宽容的环境\" class=\"headerlink\" title=\"宽容的环境\"></a>宽容的环境</h1><p>很多人学了很多年的英语，终归不会开口流利地表达自己的想法和感受，归根结底在于我们过多的注重孤立的词汇和语法学习，没有系统地学习词汇，没有学习丰富的词组，更缺少平时的开口表达。 </p>\n<p>在缺少表达的问题上，很多人简单的归因为身边没有外国朋友可以交流实践。但其实，这是一个伪命题。退一步说，假设真有一位外国友人如神兵天降于你身边，你也很少有机会可以开口实践，毕竟，人家也是人，实在无法做到和一位词不达意，说话结巴的人，和颜悦色地交流。也就是说，在你想和别人交流时，自身必须达到一定的表达能力，而在此之前，一切都靠自学，或者和自己水平相当的伙伴协同学习。试想那些咿呀学语的婴孩，也就只有父母家人才有耐心和热情陪同重复那些简单的词汇语句，以此教导他的语言能力。 </p>\n<p>由于很多人掌握的词汇支离破碎，常常并不足以表达一个完整的句子，此时采用中英结合的方式，倒是不错的选择。但问题在于，有人很厌恶这样的举动，并公开地排斥。甚至，有人会厌恶那些在中国说着英语的中国人，他们认为，在中国就该讲中国话，是中国人就该讲中国话，爱国就应该讲国语。或者仅仅英语不合他们自己接收信息的习惯方式，就足以在内心产生抵触。暂且不深入展开他们的逻辑，但可以想象，有这样的现象存在，那些想实践英语的人，自然面对更多的困难和挑战。当然，我们可以选择忽视他们的意见，我们也需要有勇气直面他们的反对，并踽踽而行，毕竟，他们并非正确，真理也并非掌握在他们手上。不得不承认他们不过是在言论自由的框架之下表达自己的反对意见，对此我自然也不能有什么指摘，只是希望，这些人，特别是公众人物，在自由地表达自己的意见时，能够明白自己言行的后果，从而在情不自禁的随口一说时，更加审慎一些。 </p>\n<h1 id=\"GodenDict-安装\"><a href=\"#GodenDict-安装\" class=\"headerlink\" title=\"GodenDict 安装\"></a>GodenDict 安装</h1><p>下载链接: <a href=\"https://pan.baidu.com/s/1oV6AxRUlX1c7mpE352bt8w\">https://pan.baidu.com/s/1oV6AxRUlX1c7mpE352bt8w</a> 提取码: uxtw </p>\n<h2 id=\"Windows-amp-Mac\"><a href=\"#Windows-amp-Mac\" class=\"headerlink\" title=\"Windows &amp; Mac\"></a>Windows &amp; Mac</h2><ol>\n<li>下载GodenDict应用程序：<ol>\n<li>Mac： GoldenDict-1.5.0-RC2-209-gfe9312e(Qt_563)</li>\n<li>Windows： GoldenDict-1.0.1-Portable</li>\n</ol>\n</li>\n<li>下载词典文件并解压<ol>\n<li>En-En-Longman_Pronunciation3.zip</li>\n<li>En-En_OALD8.zip</li>\n<li>En-En_Merriam_Webster11</li>\n<li>En-zh_CN_OALD4</li>\n<li>En-En_Longman_DOCE5</li>\n</ol>\n</li>\n<li>GodenDic 安装完毕，打开Dictionary菜单，在如下界面点击Add，将解压的词典目录逐个添加，完成后点击Rescan now，程序建立索引。</li>\n</ol>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/305a1480dcfc9dbd.png\"></p>\n<p>Mac上会有如下界面异常，</p>\n<img src=\"https://s3.bmp.ovh/imgs/2021/08/bad36e68350614d4.png\" style=\"zoom:100%;\" />\n\n<p>点击Preference菜单，如下截图勾选“Expand optional parts”</p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/f3565b6d9c3abefc.png\"></p>\n<p>最后，可以把这个选项勾选。</p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/08/79f7c59f09d94491.png\"></p>\n<h2 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h2><ol>\n<li>下载Android APK并安装：<a href=\"http://goldendict.mobi/downloads/android/free/\">下载链接</a></li>\n<li>下载词典文件：上一节百度云 Android 目录（此目录下的文件是从词典文件压缩包里面提取，去掉音频和图片，以减少手机存储占用）</li>\n<li>将下载的词典文件存放于手机根目录的：GoldenDict 文件夹（注意命名，大小写完全一致）</li>\n<li>手机上打开GoldenDict，此时先建立索引，完毕就可以正常使用。</li>\n</ol>\n<h2 id=\"iOS：\"><a href=\"#iOS：\" class=\"headerlink\" title=\"iOS：\"></a>iOS：</h2><p>尚未支持，可以考虑使用欧路词典或其他，并按照类似思路，安装词典即可。</p>\n<h1 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h1><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>写作的基础是正确的语法，语法书我只推荐这本：<a href=\"http://grammar.codeyu.com/\">旋元佑进阶文法</a> ，推荐阅读第一章的基本句型和第十六七章的合句和名词子句，就能感同身受，此书是否值得细读了。或者参考<a href=\"https://book.douban.com/subject/34840714/\">豆瓣的评价</a>。</p>\n<h2 id=\"写作课程\"><a href=\"#写作课程\" class=\"headerlink\" title=\"写作课程\"></a>写作课程</h2><p><a href=\"https://www.coursera.org/specializations/academic-english\">Academic English: Writing Specialization</a></p>\n<p><a href=\"https://online.stanford.edu/courses/som-y0010-writing-sciences\">Writing in the Sciences</a></p>\n<p>其他的就不做推荐了，相信每个人都可以寻找到适合自己的资料。</p>\n<p><strong>如果本文令你受益匪浅，愿意慷慨解囊，可以看这里，一分也是爱。分享推荐给身边的朋友，也是不胜感激</strong></p>\n<img src=\"https://s3.bmp.ovh/imgs/2021/08/05d5219d41934cc5.png\" style=\"zoom:25%;\" />\n"},{"title":"Control title in CollapsingToolbarLayout","_content":"\n\n\n\n\n[Show CollapsingToolbarLayout title only when collapsed](https://stackoverflow.com/questions/31662416/show-collapsingtoolbarlayout-title-only-when-collapsed)\n\n[Android toolbar center title and custom font](https://stackoverflow.com/questions/26533510/android-toolbar-center-title-and-custom-font)\n\n\n\nhttps://guides.codepath.com/android/handling-scrolls-with-coordinatorlayout\n\nhttps://blog.csdn.net/chenyingjie_Android/article/details/88952611\n\nhttps://www.jianshu.com/p/3a51bd0d1d86\n\nhttps://medium.com/@tonia.tkachuk/appbarlayout-scroll-behavior-with-layout-scrollflags-2eec41b4366b\n\nhttps://www.jianshu.com/p/7caa5f4f49bd\n\nhttps://www.codenong.com/31369842/\n\nhttps://www.jianshu.com/p/2dc563e8a001\n\nhttps://blog.csdn.net/jxf_access/article/details/79564669?spm=a2c6h.12873639.0.0.2637717cRiq3XK\n\nhttps://blog.csdn.net/My_Jack/article/details/70127967\n\n# \n\n\n\n\n\n\n\n\n\n","source":"_drafts/Control-title-in-CollapsingToolbarLayout.md","raw":"---\ntitle: Control title in CollapsingToolbarLayout\ntags:\n---\n\n\n\n\n\n[Show CollapsingToolbarLayout title only when collapsed](https://stackoverflow.com/questions/31662416/show-collapsingtoolbarlayout-title-only-when-collapsed)\n\n[Android toolbar center title and custom font](https://stackoverflow.com/questions/26533510/android-toolbar-center-title-and-custom-font)\n\n\n\nhttps://guides.codepath.com/android/handling-scrolls-with-coordinatorlayout\n\nhttps://blog.csdn.net/chenyingjie_Android/article/details/88952611\n\nhttps://www.jianshu.com/p/3a51bd0d1d86\n\nhttps://medium.com/@tonia.tkachuk/appbarlayout-scroll-behavior-with-layout-scrollflags-2eec41b4366b\n\nhttps://www.jianshu.com/p/7caa5f4f49bd\n\nhttps://www.codenong.com/31369842/\n\nhttps://www.jianshu.com/p/2dc563e8a001\n\nhttps://blog.csdn.net/jxf_access/article/details/79564669?spm=a2c6h.12873639.0.0.2637717cRiq3XK\n\nhttps://blog.csdn.net/My_Jack/article/details/70127967\n\n# \n\n\n\n\n\n\n\n\n\n","slug":"Control-title-in-CollapsingToolbarLayout","published":0,"date":"2021-08-31T06:40:12.531Z","updated":"2021-08-31T07:31:18.724Z","_id":"ckszpbzav0000zfci8gghh2id","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://stackoverflow.com/questions/31662416/show-collapsingtoolbarlayout-title-only-when-collapsed\">Show CollapsingToolbarLayout title only when collapsed</a></p>\n<p><a href=\"https://stackoverflow.com/questions/26533510/android-toolbar-center-title-and-custom-font\">Android toolbar center title and custom font</a></p>\n<p><a href=\"https://guides.codepath.com/android/handling-scrolls-with-coordinatorlayout\">https://guides.codepath.com/android/handling-scrolls-with-coordinatorlayout</a></p>\n<p><a href=\"https://blog.csdn.net/chenyingjie_Android/article/details/88952611\">https://blog.csdn.net/chenyingjie_Android/article/details/88952611</a></p>\n<p><a href=\"https://www.jianshu.com/p/3a51bd0d1d86\">https://www.jianshu.com/p/3a51bd0d1d86</a></p>\n<p><a href=\"https://medium.com/@tonia.tkachuk/appbarlayout-scroll-behavior-with-layout-scrollflags-2eec41b4366b\">https://medium.com/@tonia.tkachuk/appbarlayout-scroll-behavior-with-layout-scrollflags-2eec41b4366b</a></p>\n<p><a href=\"https://www.jianshu.com/p/7caa5f4f49bd\">https://www.jianshu.com/p/7caa5f4f49bd</a></p>\n<p><a href=\"https://www.codenong.com/31369842/\">https://www.codenong.com/31369842/</a></p>\n<p><a href=\"https://www.jianshu.com/p/2dc563e8a001\">https://www.jianshu.com/p/2dc563e8a001</a></p>\n<p><a href=\"https://blog.csdn.net/jxf_access/article/details/79564669?spm=a2c6h.12873639.0.0.2637717cRiq3XK\">https://blog.csdn.net/jxf_access/article/details/79564669?spm=a2c6h.12873639.0.0.2637717cRiq3XK</a></p>\n<p><a href=\"https://blog.csdn.net/My_Jack/article/details/70127967\">https://blog.csdn.net/My_Jack/article/details/70127967</a></p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><a href=\"https://stackoverflow.com/questions/31662416/show-collapsingtoolbarlayout-title-only-when-collapsed\">Show CollapsingToolbarLayout title only when collapsed</a></p>\n<p><a href=\"https://stackoverflow.com/questions/26533510/android-toolbar-center-title-and-custom-font\">Android toolbar center title and custom font</a></p>\n<p><a href=\"https://guides.codepath.com/android/handling-scrolls-with-coordinatorlayout\">https://guides.codepath.com/android/handling-scrolls-with-coordinatorlayout</a></p>\n<p><a href=\"https://blog.csdn.net/chenyingjie_Android/article/details/88952611\">https://blog.csdn.net/chenyingjie_Android/article/details/88952611</a></p>\n<p><a href=\"https://www.jianshu.com/p/3a51bd0d1d86\">https://www.jianshu.com/p/3a51bd0d1d86</a></p>\n<p><a href=\"https://medium.com/@tonia.tkachuk/appbarlayout-scroll-behavior-with-layout-scrollflags-2eec41b4366b\">https://medium.com/@tonia.tkachuk/appbarlayout-scroll-behavior-with-layout-scrollflags-2eec41b4366b</a></p>\n<p><a href=\"https://www.jianshu.com/p/7caa5f4f49bd\">https://www.jianshu.com/p/7caa5f4f49bd</a></p>\n<p><a href=\"https://www.codenong.com/31369842/\">https://www.codenong.com/31369842/</a></p>\n<p><a href=\"https://www.jianshu.com/p/2dc563e8a001\">https://www.jianshu.com/p/2dc563e8a001</a></p>\n<p><a href=\"https://blog.csdn.net/jxf_access/article/details/79564669?spm=a2c6h.12873639.0.0.2637717cRiq3XK\">https://blog.csdn.net/jxf_access/article/details/79564669?spm=a2c6h.12873639.0.0.2637717cRiq3XK</a></p>\n<p><a href=\"https://blog.csdn.net/My_Jack/article/details/70127967\">https://blog.csdn.net/My_Jack/article/details/70127967</a></p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>"},{"title":"Android TouchEvent 源码剖析","_content":"\n\n\nhttps://www.jianshu.com/p/e99b5e8bd67b\n","source":"_drafts/Android-TouchEvent-源码剖析.md","raw":"---\ntitle: Android TouchEvent 源码剖析\ntags:\n---\n\n\n\nhttps://www.jianshu.com/p/e99b5e8bd67b\n","slug":"Android-TouchEvent-源码剖析","published":0,"date":"2021-08-31T07:34:40.681Z","updated":"2021-08-31T07:34:52.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktmzx6nb000085f946r1dpyl","content":"<p><a href=\"https://www.jianshu.com/p/e99b5e8bd67b\">https://www.jianshu.com/p/e99b5e8bd67b</a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><a href=\"https://www.jianshu.com/p/e99b5e8bd67b\">https://www.jianshu.com/p/e99b5e8bd67b</a></p>\n"},{"title":"RxJava线程调度源码剖析","_content":"\n\n\n\n\nhttps://www.jianshu.com/p/c3a930a03855\n\nhttps://cloud.tencent.com/developer/article/1394400\n\nhttps://blog.csdn.net/yuzhiqiang666/article/details/51532776\n","source":"_drafts/RxJava线程调度源码剖析.md","raw":"---\ntitle: RxJava线程调度源码剖析\ntags:\n---\n\n\n\n\n\nhttps://www.jianshu.com/p/c3a930a03855\n\nhttps://cloud.tencent.com/developer/article/1394400\n\nhttps://blog.csdn.net/yuzhiqiang666/article/details/51532776\n","slug":"RxJava线程调度源码剖析","published":0,"date":"2021-08-31T07:32:33.634Z","updated":"2021-08-31T07:33:23.115Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktmzx6nl000185f9gkpjeopf","content":"<p><a href=\"https://www.jianshu.com/p/c3a930a03855\">https://www.jianshu.com/p/c3a930a03855</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1394400\">https://cloud.tencent.com/developer/article/1394400</a></p>\n<p><a href=\"https://blog.csdn.net/yuzhiqiang666/article/details/51532776\">https://blog.csdn.net/yuzhiqiang666/article/details/51532776</a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><a href=\"https://www.jianshu.com/p/c3a930a03855\">https://www.jianshu.com/p/c3a930a03855</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1394400\">https://cloud.tencent.com/developer/article/1394400</a></p>\n<p><a href=\"https://blog.csdn.net/yuzhiqiang666/article/details/51532776\">https://blog.csdn.net/yuzhiqiang666/article/details/51532776</a></p>\n"},{"title":"ViewModel & LiveData 源码剖析","_content":"","source":"_drafts/ViewModel-LiveData-源码剖析.md","raw":"---\ntitle: ViewModel & LiveData 源码剖析\ntags:\n---\n","slug":"ViewModel-LiveData-源码剖析","published":0,"date":"2021-08-31T07:13:28.549Z","updated":"2021-08-31T07:13:28.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktmzx6nm000285f97xe29juy","content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"ViewModel源码剖析","date":"2021-09-19T10:44:37.000Z","_content":"\n\n\n# ViewModel 源码剖析\n\n\n\n# 示例代码\n\nViewModel负责数据存储，借助LiveData，实现异步获取数据，完成后，通知UI观察者，更新UI\n\n```java\npublic class MyViewModel extends ViewModel {\n    private MutableLiveData<List<User>> users;\n    public LiveData<List<User>> getUsers() {\n        if (users == null) {\n            users = new MutableLiveData<List<User>>();\n            loadUsers();\n        }\n        return users;\n    }\n\n    private void loadUsers() {\n        // Do an asynchronous operation to fetch users.\n\t\t\t\tList<User> requestResult = requestUsers();\n\t\t\t\t// Once value changes, observer will be notified.\n\t\t\t\tusers.set(requestResult);\n    }\n}\n```\n\nUI层注册数据变更监听。注意ViewModelProvider构造器参数是哪个Activity，Fragment实例，ViewModel实例化后，其引用寄存在该实例内。他们都实现ViewModelStoreOwner接口。\n\n```java\npublic class MyActivity extends AppCompatActivity {\n    public void onCreate(Bundle savedInstanceState) {\n        // Create a ViewModel the first time the system calls an activity's onCreate() method.\n        // Re-created activities receive the same MyViewModel instance created by the first activity.\n\t\t\t\t// 1. ViewModel实例挂载在this实例里，有点相当于是this实例的成员变量\n        MyViewModel model = new ViewModelProvider(this).get(MyViewModel.class);\n        // 2. 这里的this参数，决定观察者的生命周期。注意，如果此参数是activity实例，而当前类是fragment，则fragment实例内存泄漏\n        model.getUsers().observe(this, users -> {\n            // update UI\n        });\n    }\n}\n```\n\n\n\n注意，observe这里第一个参数，决定观察者的生命周期。所以，如下示例代码，此参数是activity实例，而当前类是fragment，则fragment实例内存泄漏，因为监听实例生命周期和Activity一致，而它持有Fragment实例引用，导致Fragment在Activity生命周期内无法被回收。\n\n```java\npublic class MyFragment extends Fragment {\n    public void onCreate(Bundle savedInstanceState) {\n        // Create a ViewModel the first time the system calls an activity's onCreate() method.\n        // Re-created activities receive the same MyViewModel instance created by the first activity.\n        MyViewModel model = new ViewModelProvider(this).get(MyViewModel.class);\n        \n        model.getUsers().observe(requireActivity(), users -> {\n            // update UI\n        });\n    }\n}\n```\n\n\n\n\n\n# 源码剖析\n\n先从ViewModel实例化开始，首先要解决ViewModel如何实例化，并存放实例，便后续获取实例。\n\n```java\nandroidx.lifecycle.ViewModelProvider.java\n/**\n * Creates {@code ViewModelProvider}. This will create {@code ViewModels}\n * and retain them in a store of the given {@code ViewModelStoreOwner}.\n * <p>\n * This method will use the\n * {@link HasDefaultViewModelProviderFactory#getDefaultViewModelProviderFactory() default factory}\n * if the owner implements {@link HasDefaultViewModelProviderFactory}. Otherwise, a\n * {@link NewInstanceFactory} will be used.\n */\npublic ViewModelProvider(@NonNull ViewModelStoreOwner owner) {\n    this(owner.getViewModelStore(), owner instanceof HasDefaultViewModelProviderFactory\n            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()\n            : NewInstanceFactory.getInstance());\n}\n\n/**\n * Creates {@code ViewModelProvider}, which will create {@code ViewModels} via the given\n * {@code Factory} and retain them in a store of the given {@code ViewModelStoreOwner}.\n *\n * @param owner   a {@code ViewModelStoreOwner} whose {@link ViewModelStore} will be used to\n *                retain {@code ViewModels}\n * @param factory a {@code Factory} which will be used to instantiate\n *                new {@code ViewModels}\n */\npublic ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) {\n    this(owner.getViewModelStore(), factory);\n}\n\n/**\n * Creates {@code ViewModelProvider}, which will create {@code ViewModels} via the given\n * {@code Factory} and retain them in the given {@code store}.\n *\n * @param store   {@code ViewModelStore} where ViewModels will be stored.\n * @param factory factory a {@code Factory} which will be used to instantiate\n *                new {@code ViewModels}\n */\npublic ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) {\n    mFactory = factory;\n    mViewModelStore = store;\n}\n\n\n```\n\nActivity，Fragment实例，他们都实现ViewModelStoreOwner接口，看这名字，顾名思义，就是提供存放ViewModel实例的地方。同时，ViewModelStoreOwner 可能自带ViewModel构造工厂，没有的话，就使用ViewModelProvider 内的NewInstanceFactory实例。\n\nViewModelStoreOwner 返回ViewModelStore，内部就是一个Map，key是`ViewModelProvider(this).get(MyViewModel.class);`get方法传入ViewModel class的canonicalName，value就是对应的ViewModel实例啦。Activity 或者 Fragment 持有ViewModelStore引用。\n\n```java\nandroidx.lifecycle.ViewModelProvider\npublic <T extends ViewModel> T get(@NonNull Class<T> modelClass) {\n    String canonicalName = modelClass.getCanonicalName();\n    if (canonicalName == null) {\n        throw new IllegalArgumentException(\"Local and anonymous classes can not be ViewModels\");\n    }\n    return get(DEFAULT_KEY + \":\" + canonicalName, modelClass);\n}\n\npublic <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {\n    ViewModel viewModel = mViewModelStore.get(key);\n\n    if (modelClass.isInstance(viewModel)) {\n        if (mFactory instanceof OnRequeryFactory) {\n            ((OnRequeryFactory) mFactory).onRequery(viewModel);\n        }\n        return (T) viewModel;\n    } else {\n        //noinspection StatementWithEmptyBody\n        if (viewModel != null) {\n            // TODO: log a warning.\n        }\n    }\n    if (mFactory instanceof KeyedFactory) {\n        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);\n    } else {\n        viewModel = mFactory.create(modelClass);\n    }\n    mViewModelStore.put(key, viewModel);\n    return (T) viewModel;\n}\n```\n\n总结下，ViewModelStoreOwner 提供负责存储ViewModel的类：ViewModelStore，ViewModel由Factory创建，然后放在ViewModelStore实例内，下次直接从ViewModelStore 通过get方法获取，单例。\n\n\n\n![ViewModel](https://s3.bmp.ovh/imgs/2021/09/8a107bebc30102c8.png)\n\n# AndroidViewModel & ViewModel\n\nViewModel 不可以强引用Context，如果确实需要，则使用AndroidViewModel，它持有Application的引用。解决需要的同时，避免Activity泄漏。\n\n`ViewModelProvider` 默认实例化的ViewModel 由NewInstanceFactory 创建。AndroidViewModel 由AndroidViewModelFactory 通过作为实例化`ViewModelProvider` 构造器的Factory 参数创建。\n\nActivity & Fragment 也同时实现`HasDefaultViewModelProviderFactory`接口。看下`SavedStateViewModelFactory` ，区分是实例化 ViewModel 还是AndroidViewModel，并增加保存状态的处理。\n\n```java\nandroidx.lifecycle.SavedStateViewModelFactory\n@NonNull\n@Override\npublic <T extends ViewModel> T create(@NonNull String key, @NonNull Class<T> modelClass) {\n    boolean isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);\n    Constructor<T> constructor;\n    if (isAndroidViewModel && mApplication != null) {\n        constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);\n    } else {\n        constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);\n    }\n    // doesn't need SavedStateHandle\n    if (constructor == null) {\n        return mFactory.create(modelClass);\n    }\n\n    SavedStateHandleController controller = SavedStateHandleController.create(\n            mSavedStateRegistry, mLifecycle, key, mDefaultArgs);\n    try {\n        T viewmodel;\n        if (isAndroidViewModel && mApplication != null) {\n            viewmodel = constructor.newInstance(mApplication, controller.getHandle());\n        } else {\n            viewmodel = constructor.newInstance(controller.getHandle());\n        }\n        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);\n        return viewmodel;\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(\"Failed to access \" + modelClass, e);\n    } catch (InstantiationException e) {\n        throw new RuntimeException(\"A \" + modelClass + \" cannot be instantiated.\", e);\n    } catch (InvocationTargetException e) {\n        throw new RuntimeException(\"An exception happened in constructor of \"\n                + modelClass, e.getCause());\n    }\n}\n```\n\nViewModel就是一个壳，与ViewModelStoreOwner共存亡。但Activity因onConfigurationChanged重建后，会获取上一个Activity ViewModelStore，恢复上一个ViewModel。\n\n```java\nandroidx.activity.ComponentActivity\nvoid ensureViewModelStore() {\n    if (mViewModelStore == null) {\n        NonConfigurationInstances nc =\n                (NonConfigurationInstances) getLastNonConfigurationInstance();\n        if (nc != null) {\n            // Restore the ViewModelStore from NonConfigurationInstances\n            mViewModelStore = nc.viewModelStore;\n        }\n        if (mViewModelStore == null) {\n            mViewModelStore = new ViewModelStore();\n        }\n    }\n}\n```\n\n# OnRequeryFactory 接口\n\n用途：提供从ViewModelProvider get 返回ViewModel实例前的回调，可以在返回前对ViewModel做些预处理。SavedStateViewModelFactory实现此接口。\n\n```java\nandroidx.lifecycle.SavedStateViewModelFactory\n@Override\nvoid onRequery(@NonNull ViewModel viewModel) {\n    attachHandleIfNeeded(viewModel, mSavedStateRegistry, mLifecycle);\n}\n```\n\n```java\nandroidx.lifecycle.ViewModelProvider\npublic <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {\n    ViewModel viewModel = mViewModelStore.get(key);\n\n    if (modelClass.isInstance(viewModel)) {\n\t\t\t\t// ViewModel返回前处理\n        if (mFactory instanceof OnRequeryFactory) {\n            ((OnRequeryFactory) mFactory).onRequery(viewModel);\n        }\n        return (T) viewModel;\n    } else {\n        //noinspection StatementWithEmptyBody\n        if (viewModel != null) {\n            // TODO: log a warning.\n        }\n    }\n    if (mFactory instanceof KeyedFactory) {\n        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);\n    } else {\n        viewModel = mFactory.create(modelClass);\n    }\n    mViewModelStore.put(key, viewModel);\n    return (T) viewModel;\n}\n```\n\n\n","source":"_posts/ViewModel源码剖析.md","raw":"---\ntitle: ViewModel源码剖析\ndate: 2021-09-19 18:44:37\ntags: ViewModel源码剖析, Android, ViewModel\n---\n\n\n\n# ViewModel 源码剖析\n\n\n\n# 示例代码\n\nViewModel负责数据存储，借助LiveData，实现异步获取数据，完成后，通知UI观察者，更新UI\n\n```java\npublic class MyViewModel extends ViewModel {\n    private MutableLiveData<List<User>> users;\n    public LiveData<List<User>> getUsers() {\n        if (users == null) {\n            users = new MutableLiveData<List<User>>();\n            loadUsers();\n        }\n        return users;\n    }\n\n    private void loadUsers() {\n        // Do an asynchronous operation to fetch users.\n\t\t\t\tList<User> requestResult = requestUsers();\n\t\t\t\t// Once value changes, observer will be notified.\n\t\t\t\tusers.set(requestResult);\n    }\n}\n```\n\nUI层注册数据变更监听。注意ViewModelProvider构造器参数是哪个Activity，Fragment实例，ViewModel实例化后，其引用寄存在该实例内。他们都实现ViewModelStoreOwner接口。\n\n```java\npublic class MyActivity extends AppCompatActivity {\n    public void onCreate(Bundle savedInstanceState) {\n        // Create a ViewModel the first time the system calls an activity's onCreate() method.\n        // Re-created activities receive the same MyViewModel instance created by the first activity.\n\t\t\t\t// 1. ViewModel实例挂载在this实例里，有点相当于是this实例的成员变量\n        MyViewModel model = new ViewModelProvider(this).get(MyViewModel.class);\n        // 2. 这里的this参数，决定观察者的生命周期。注意，如果此参数是activity实例，而当前类是fragment，则fragment实例内存泄漏\n        model.getUsers().observe(this, users -> {\n            // update UI\n        });\n    }\n}\n```\n\n\n\n注意，observe这里第一个参数，决定观察者的生命周期。所以，如下示例代码，此参数是activity实例，而当前类是fragment，则fragment实例内存泄漏，因为监听实例生命周期和Activity一致，而它持有Fragment实例引用，导致Fragment在Activity生命周期内无法被回收。\n\n```java\npublic class MyFragment extends Fragment {\n    public void onCreate(Bundle savedInstanceState) {\n        // Create a ViewModel the first time the system calls an activity's onCreate() method.\n        // Re-created activities receive the same MyViewModel instance created by the first activity.\n        MyViewModel model = new ViewModelProvider(this).get(MyViewModel.class);\n        \n        model.getUsers().observe(requireActivity(), users -> {\n            // update UI\n        });\n    }\n}\n```\n\n\n\n\n\n# 源码剖析\n\n先从ViewModel实例化开始，首先要解决ViewModel如何实例化，并存放实例，便后续获取实例。\n\n```java\nandroidx.lifecycle.ViewModelProvider.java\n/**\n * Creates {@code ViewModelProvider}. This will create {@code ViewModels}\n * and retain them in a store of the given {@code ViewModelStoreOwner}.\n * <p>\n * This method will use the\n * {@link HasDefaultViewModelProviderFactory#getDefaultViewModelProviderFactory() default factory}\n * if the owner implements {@link HasDefaultViewModelProviderFactory}. Otherwise, a\n * {@link NewInstanceFactory} will be used.\n */\npublic ViewModelProvider(@NonNull ViewModelStoreOwner owner) {\n    this(owner.getViewModelStore(), owner instanceof HasDefaultViewModelProviderFactory\n            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()\n            : NewInstanceFactory.getInstance());\n}\n\n/**\n * Creates {@code ViewModelProvider}, which will create {@code ViewModels} via the given\n * {@code Factory} and retain them in a store of the given {@code ViewModelStoreOwner}.\n *\n * @param owner   a {@code ViewModelStoreOwner} whose {@link ViewModelStore} will be used to\n *                retain {@code ViewModels}\n * @param factory a {@code Factory} which will be used to instantiate\n *                new {@code ViewModels}\n */\npublic ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) {\n    this(owner.getViewModelStore(), factory);\n}\n\n/**\n * Creates {@code ViewModelProvider}, which will create {@code ViewModels} via the given\n * {@code Factory} and retain them in the given {@code store}.\n *\n * @param store   {@code ViewModelStore} where ViewModels will be stored.\n * @param factory factory a {@code Factory} which will be used to instantiate\n *                new {@code ViewModels}\n */\npublic ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) {\n    mFactory = factory;\n    mViewModelStore = store;\n}\n\n\n```\n\nActivity，Fragment实例，他们都实现ViewModelStoreOwner接口，看这名字，顾名思义，就是提供存放ViewModel实例的地方。同时，ViewModelStoreOwner 可能自带ViewModel构造工厂，没有的话，就使用ViewModelProvider 内的NewInstanceFactory实例。\n\nViewModelStoreOwner 返回ViewModelStore，内部就是一个Map，key是`ViewModelProvider(this).get(MyViewModel.class);`get方法传入ViewModel class的canonicalName，value就是对应的ViewModel实例啦。Activity 或者 Fragment 持有ViewModelStore引用。\n\n```java\nandroidx.lifecycle.ViewModelProvider\npublic <T extends ViewModel> T get(@NonNull Class<T> modelClass) {\n    String canonicalName = modelClass.getCanonicalName();\n    if (canonicalName == null) {\n        throw new IllegalArgumentException(\"Local and anonymous classes can not be ViewModels\");\n    }\n    return get(DEFAULT_KEY + \":\" + canonicalName, modelClass);\n}\n\npublic <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {\n    ViewModel viewModel = mViewModelStore.get(key);\n\n    if (modelClass.isInstance(viewModel)) {\n        if (mFactory instanceof OnRequeryFactory) {\n            ((OnRequeryFactory) mFactory).onRequery(viewModel);\n        }\n        return (T) viewModel;\n    } else {\n        //noinspection StatementWithEmptyBody\n        if (viewModel != null) {\n            // TODO: log a warning.\n        }\n    }\n    if (mFactory instanceof KeyedFactory) {\n        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);\n    } else {\n        viewModel = mFactory.create(modelClass);\n    }\n    mViewModelStore.put(key, viewModel);\n    return (T) viewModel;\n}\n```\n\n总结下，ViewModelStoreOwner 提供负责存储ViewModel的类：ViewModelStore，ViewModel由Factory创建，然后放在ViewModelStore实例内，下次直接从ViewModelStore 通过get方法获取，单例。\n\n\n\n![ViewModel](https://s3.bmp.ovh/imgs/2021/09/8a107bebc30102c8.png)\n\n# AndroidViewModel & ViewModel\n\nViewModel 不可以强引用Context，如果确实需要，则使用AndroidViewModel，它持有Application的引用。解决需要的同时，避免Activity泄漏。\n\n`ViewModelProvider` 默认实例化的ViewModel 由NewInstanceFactory 创建。AndroidViewModel 由AndroidViewModelFactory 通过作为实例化`ViewModelProvider` 构造器的Factory 参数创建。\n\nActivity & Fragment 也同时实现`HasDefaultViewModelProviderFactory`接口。看下`SavedStateViewModelFactory` ，区分是实例化 ViewModel 还是AndroidViewModel，并增加保存状态的处理。\n\n```java\nandroidx.lifecycle.SavedStateViewModelFactory\n@NonNull\n@Override\npublic <T extends ViewModel> T create(@NonNull String key, @NonNull Class<T> modelClass) {\n    boolean isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);\n    Constructor<T> constructor;\n    if (isAndroidViewModel && mApplication != null) {\n        constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);\n    } else {\n        constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);\n    }\n    // doesn't need SavedStateHandle\n    if (constructor == null) {\n        return mFactory.create(modelClass);\n    }\n\n    SavedStateHandleController controller = SavedStateHandleController.create(\n            mSavedStateRegistry, mLifecycle, key, mDefaultArgs);\n    try {\n        T viewmodel;\n        if (isAndroidViewModel && mApplication != null) {\n            viewmodel = constructor.newInstance(mApplication, controller.getHandle());\n        } else {\n            viewmodel = constructor.newInstance(controller.getHandle());\n        }\n        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);\n        return viewmodel;\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(\"Failed to access \" + modelClass, e);\n    } catch (InstantiationException e) {\n        throw new RuntimeException(\"A \" + modelClass + \" cannot be instantiated.\", e);\n    } catch (InvocationTargetException e) {\n        throw new RuntimeException(\"An exception happened in constructor of \"\n                + modelClass, e.getCause());\n    }\n}\n```\n\nViewModel就是一个壳，与ViewModelStoreOwner共存亡。但Activity因onConfigurationChanged重建后，会获取上一个Activity ViewModelStore，恢复上一个ViewModel。\n\n```java\nandroidx.activity.ComponentActivity\nvoid ensureViewModelStore() {\n    if (mViewModelStore == null) {\n        NonConfigurationInstances nc =\n                (NonConfigurationInstances) getLastNonConfigurationInstance();\n        if (nc != null) {\n            // Restore the ViewModelStore from NonConfigurationInstances\n            mViewModelStore = nc.viewModelStore;\n        }\n        if (mViewModelStore == null) {\n            mViewModelStore = new ViewModelStore();\n        }\n    }\n}\n```\n\n# OnRequeryFactory 接口\n\n用途：提供从ViewModelProvider get 返回ViewModel实例前的回调，可以在返回前对ViewModel做些预处理。SavedStateViewModelFactory实现此接口。\n\n```java\nandroidx.lifecycle.SavedStateViewModelFactory\n@Override\nvoid onRequery(@NonNull ViewModel viewModel) {\n    attachHandleIfNeeded(viewModel, mSavedStateRegistry, mLifecycle);\n}\n```\n\n```java\nandroidx.lifecycle.ViewModelProvider\npublic <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {\n    ViewModel viewModel = mViewModelStore.get(key);\n\n    if (modelClass.isInstance(viewModel)) {\n\t\t\t\t// ViewModel返回前处理\n        if (mFactory instanceof OnRequeryFactory) {\n            ((OnRequeryFactory) mFactory).onRequery(viewModel);\n        }\n        return (T) viewModel;\n    } else {\n        //noinspection StatementWithEmptyBody\n        if (viewModel != null) {\n            // TODO: log a warning.\n        }\n    }\n    if (mFactory instanceof KeyedFactory) {\n        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);\n    } else {\n        viewModel = mFactory.create(modelClass);\n    }\n    mViewModelStore.put(key, viewModel);\n    return (T) viewModel;\n}\n```\n\n\n","slug":"ViewModel源码剖析","published":1,"updated":"2022-02-15T02:21:12.912Z","_id":"cktr4p3jz00002tf9bs1438nj","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"ViewModel-源码剖析\"><a href=\"#ViewModel-源码剖析\" class=\"headerlink\" title=\"ViewModel 源码剖析\"></a>ViewModel 源码剖析</h1><h1 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h1><p>ViewModel负责数据存储，借助LiveData，实现异步获取数据，完成后，通知UI观察者，更新UI</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (users == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            users = <span class=\"keyword\">new</span> MutableLiveData&lt;List&lt;User&gt;&gt;();</span><br><span class=\"line\">            loadUsers();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> users;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadUsers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Do an asynchronous operation to fetch users.</span></span><br><span class=\"line\">\t\t\t\tList&lt;User&gt; requestResult = requestUsers();</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Once value changes, observer will be notified.</span></span><br><span class=\"line\">\t\t\t\tusers.set(requestResult);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>UI层注册数据变更监听。注意ViewModelProvider构造器参数是哪个Activity，Fragment实例，ViewModel实例化后，其引用寄存在该实例内。他们都实现ViewModelStoreOwner接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create a ViewModel the first time the system calls an activity&#x27;s onCreate() method.</span></span><br><span class=\"line\">        <span class=\"comment\">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 1. ViewModel实例挂载在this实例里，有点相当于是this实例的成员变量</span></span><br><span class=\"line\">        MyViewModel model = <span class=\"keyword\">new</span> ViewModelProvider(<span class=\"keyword\">this</span>).get(MyViewModel.class);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 这里的this参数，决定观察者的生命周期。注意，如果此参数是activity实例，而当前类是fragment，则fragment实例内存泄漏</span></span><br><span class=\"line\">        model.getUsers().observe(<span class=\"keyword\">this</span>, users -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// update UI</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>注意，observe这里第一个参数，决定观察者的生命周期。所以，如下示例代码，此参数是activity实例，而当前类是fragment，则fragment实例内存泄漏，因为监听实例生命周期和Activity一致，而它持有Fragment实例引用，导致Fragment在Activity生命周期内无法被回收。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create a ViewModel the first time the system calls an activity&#x27;s onCreate() method.</span></span><br><span class=\"line\">        <span class=\"comment\">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class=\"line\">        MyViewModel model = <span class=\"keyword\">new</span> ViewModelProvider(<span class=\"keyword\">this</span>).get(MyViewModel.class);</span><br><span class=\"line\">        </span><br><span class=\"line\">        model.getUsers().observe(requireActivity(), users -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// update UI</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"源码剖析\"><a href=\"#源码剖析\" class=\"headerlink\" title=\"源码剖析\"></a>源码剖析</h1><p>先从ViewModel实例化开始，首先要解决ViewModel如何实例化，并存放实例，便后续获取实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.ViewModelProvider.java</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates &#123;<span class=\"doctag\">@code</span> ViewModelProvider&#125;. This will create &#123;<span class=\"doctag\">@code</span> ViewModels&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * and retain them in a store of the given &#123;<span class=\"doctag\">@code</span> ViewModelStoreOwner&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * This method will use the</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> HasDefaultViewModelProviderFactory#getDefaultViewModelProviderFactory() default factory&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * if the owner implements &#123;<span class=\"doctag\">@link</span> HasDefaultViewModelProviderFactory&#125;. Otherwise, a</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> NewInstanceFactory&#125; will be used.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewModelProvider</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ViewModelStoreOwner owner)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(owner.getViewModelStore(), owner <span class=\"keyword\">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class=\"line\">            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class=\"line\">            : NewInstanceFactory.getInstance());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates &#123;<span class=\"doctag\">@code</span> ViewModelProvider&#125;, which will create &#123;<span class=\"doctag\">@code</span> ViewModels&#125; via the given</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> Factory&#125; and retain them in a store of the given &#123;<span class=\"doctag\">@code</span> ViewModelStoreOwner&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> owner   a &#123;<span class=\"doctag\">@code</span> ViewModelStoreOwner&#125; whose &#123;<span class=\"doctag\">@link</span> ViewModelStore&#125; will be used to</span></span><br><span class=\"line\"><span class=\"comment\"> *                retain &#123;<span class=\"doctag\">@code</span> ViewModels&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> factory a &#123;<span class=\"doctag\">@code</span> Factory&#125; which will be used to instantiate</span></span><br><span class=\"line\"><span class=\"comment\"> *                new &#123;<span class=\"doctag\">@code</span> ViewModels&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewModelProvider</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ViewModelStoreOwner owner, <span class=\"meta\">@NonNull</span> Factory factory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(owner.getViewModelStore(), factory);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates &#123;<span class=\"doctag\">@code</span> ViewModelProvider&#125;, which will create &#123;<span class=\"doctag\">@code</span> ViewModels&#125; via the given</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> Factory&#125; and retain them in the given &#123;<span class=\"doctag\">@code</span> store&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> store   &#123;<span class=\"doctag\">@code</span> ViewModelStore&#125; where ViewModels will be stored.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> factory factory a &#123;<span class=\"doctag\">@code</span> Factory&#125; which will be used to instantiate</span></span><br><span class=\"line\"><span class=\"comment\"> *                new &#123;<span class=\"doctag\">@code</span> ViewModels&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewModelProvider</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ViewModelStore store, <span class=\"meta\">@NonNull</span> Factory factory)</span> </span>&#123;</span><br><span class=\"line\">    mFactory = factory;</span><br><span class=\"line\">    mViewModelStore = store;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Activity，Fragment实例，他们都实现ViewModelStoreOwner接口，看这名字，顾名思义，就是提供存放ViewModel实例的地方。同时，ViewModelStoreOwner 可能自带ViewModel构造工厂，没有的话，就使用ViewModelProvider 内的NewInstanceFactory实例。</p>\n<p>ViewModelStoreOwner 返回ViewModelStore，内部就是一个Map，key是<code>ViewModelProvider(this).get(MyViewModel.class);</code>get方法传入ViewModel class的canonicalName，value就是对应的ViewModel实例啦。Activity 或者 Fragment 持有ViewModelStore引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.ViewModelProvider</span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    String canonicalName = modelClass.getCanonicalName();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canonicalName == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Local and anonymous classes can not be ViewModels&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get(DEFAULT_KEY + <span class=\"string\">&quot;:&quot;</span> + canonicalName, modelClass);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String key, <span class=\"meta\">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFactory <span class=\"keyword\">instanceof</span> OnRequeryFactory) &#123;</span><br><span class=\"line\">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//noinspection StatementWithEmptyBody</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (viewModel != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> log a warning.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mFactory <span class=\"keyword\">instanceof</span> KeyedFactory) &#123;</span><br><span class=\"line\">        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        viewModel = mFactory.create(modelClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mViewModelStore.put(key, viewModel);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结下，ViewModelStoreOwner 提供负责存储ViewModel的类：ViewModelStore，ViewModel由Factory创建，然后放在ViewModelStore实例内，下次直接从ViewModelStore 通过get方法获取，单例。</p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/09/8a107bebc30102c8.png\" alt=\"ViewModel\"></p>\n<h1 id=\"AndroidViewModel-amp-ViewModel\"><a href=\"#AndroidViewModel-amp-ViewModel\" class=\"headerlink\" title=\"AndroidViewModel &amp; ViewModel\"></a>AndroidViewModel &amp; ViewModel</h1><p>ViewModel 不可以强引用Context，如果确实需要，则使用AndroidViewModel，它持有Application的引用。解决需要的同时，避免Activity泄漏。</p>\n<p><code>ViewModelProvider</code> 默认实例化的ViewModel 由NewInstanceFactory 创建。AndroidViewModel 由AndroidViewModelFactory 通过作为实例化<code>ViewModelProvider</code> 构造器的Factory 参数创建。</p>\n<p>Activity &amp; Fragment 也同时实现<code>HasDefaultViewModelProviderFactory</code>接口。看下<code>SavedStateViewModelFactory</code> ，区分是实例化 ViewModel 还是AndroidViewModel，并增加保存状态的处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.SavedStateViewModelFactory</span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String key, <span class=\"meta\">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);</span><br><span class=\"line\">    Constructor&lt;T&gt; constructor;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isAndroidViewModel &amp;&amp; mApplication != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// doesn&#x27;t need SavedStateHandle</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (constructor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mFactory.create(modelClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SavedStateHandleController controller = SavedStateHandleController.create(</span><br><span class=\"line\">            mSavedStateRegistry, mLifecycle, key, mDefaultArgs);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        T viewmodel;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAndroidViewModel &amp;&amp; mApplication != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            viewmodel = constructor.newInstance(mApplication, controller.getHandle());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            viewmodel = constructor.newInstance(controller.getHandle());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> viewmodel;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Failed to access &quot;</span> + modelClass, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;A &quot;</span> + modelClass + <span class=\"string\">&quot; cannot be instantiated.&quot;</span>, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;An exception happened in constructor of &quot;</span></span><br><span class=\"line\">                + modelClass, e.getCause());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ViewModel就是一个壳，与ViewModelStoreOwner共存亡。但Activity因onConfigurationChanged重建后，会获取上一个Activity ViewModelStore，恢复上一个ViewModel。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.activity.<span class=\"function\">ComponentActivity</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ensureViewModelStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        NonConfigurationInstances nc =</span><br><span class=\"line\">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Restore the ViewModelStore from NonConfigurationInstances</span></span><br><span class=\"line\">            mViewModelStore = nc.viewModelStore;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mViewModelStore = <span class=\"keyword\">new</span> ViewModelStore();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"OnRequeryFactory-接口\"><a href=\"#OnRequeryFactory-接口\" class=\"headerlink\" title=\"OnRequeryFactory 接口\"></a>OnRequeryFactory 接口</h1><p>用途：提供从ViewModelProvider get 返回ViewModel实例前的回调，可以在返回前对ViewModel做些预处理。SavedStateViewModelFactory实现此接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.SavedStateViewModelFactory</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onRequery</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ViewModel viewModel)</span> </span>&#123;</span><br><span class=\"line\">    attachHandleIfNeeded(viewModel, mSavedStateRegistry, mLifecycle);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.ViewModelProvider</span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String key, <span class=\"meta\">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// ViewModel返回前处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFactory <span class=\"keyword\">instanceof</span> OnRequeryFactory) &#123;</span><br><span class=\"line\">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//noinspection StatementWithEmptyBody</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (viewModel != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> log a warning.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mFactory <span class=\"keyword\">instanceof</span> KeyedFactory) &#123;</span><br><span class=\"line\">        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        viewModel = mFactory.create(modelClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mViewModelStore.put(key, viewModel);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"ViewModel-源码剖析\"><a href=\"#ViewModel-源码剖析\" class=\"headerlink\" title=\"ViewModel 源码剖析\"></a>ViewModel 源码剖析</h1><h1 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h1><p>ViewModel负责数据存储，借助LiveData，实现异步获取数据，完成后，通知UI观察者，更新UI</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (users == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            users = <span class=\"keyword\">new</span> MutableLiveData&lt;List&lt;User&gt;&gt;();</span><br><span class=\"line\">            loadUsers();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> users;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadUsers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Do an asynchronous operation to fetch users.</span></span><br><span class=\"line\">\t\t\t\tList&lt;User&gt; requestResult = requestUsers();</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Once value changes, observer will be notified.</span></span><br><span class=\"line\">\t\t\t\tusers.set(requestResult);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>UI层注册数据变更监听。注意ViewModelProvider构造器参数是哪个Activity，Fragment实例，ViewModel实例化后，其引用寄存在该实例内。他们都实现ViewModelStoreOwner接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create a ViewModel the first time the system calls an activity&#x27;s onCreate() method.</span></span><br><span class=\"line\">        <span class=\"comment\">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 1. ViewModel实例挂载在this实例里，有点相当于是this实例的成员变量</span></span><br><span class=\"line\">        MyViewModel model = <span class=\"keyword\">new</span> ViewModelProvider(<span class=\"keyword\">this</span>).get(MyViewModel.class);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 这里的this参数，决定观察者的生命周期。注意，如果此参数是activity实例，而当前类是fragment，则fragment实例内存泄漏</span></span><br><span class=\"line\">        model.getUsers().observe(<span class=\"keyword\">this</span>, users -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// update UI</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>注意，observe这里第一个参数，决定观察者的生命周期。所以，如下示例代码，此参数是activity实例，而当前类是fragment，则fragment实例内存泄漏，因为监听实例生命周期和Activity一致，而它持有Fragment实例引用，导致Fragment在Activity生命周期内无法被回收。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create a ViewModel the first time the system calls an activity&#x27;s onCreate() method.</span></span><br><span class=\"line\">        <span class=\"comment\">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class=\"line\">        MyViewModel model = <span class=\"keyword\">new</span> ViewModelProvider(<span class=\"keyword\">this</span>).get(MyViewModel.class);</span><br><span class=\"line\">        </span><br><span class=\"line\">        model.getUsers().observe(requireActivity(), users -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// update UI</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"源码剖析\"><a href=\"#源码剖析\" class=\"headerlink\" title=\"源码剖析\"></a>源码剖析</h1><p>先从ViewModel实例化开始，首先要解决ViewModel如何实例化，并存放实例，便后续获取实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.ViewModelProvider.java</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates &#123;<span class=\"doctag\">@code</span> ViewModelProvider&#125;. This will create &#123;<span class=\"doctag\">@code</span> ViewModels&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * and retain them in a store of the given &#123;<span class=\"doctag\">@code</span> ViewModelStoreOwner&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * This method will use the</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> HasDefaultViewModelProviderFactory#getDefaultViewModelProviderFactory() default factory&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * if the owner implements &#123;<span class=\"doctag\">@link</span> HasDefaultViewModelProviderFactory&#125;. Otherwise, a</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> NewInstanceFactory&#125; will be used.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewModelProvider</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ViewModelStoreOwner owner)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(owner.getViewModelStore(), owner <span class=\"keyword\">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class=\"line\">            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class=\"line\">            : NewInstanceFactory.getInstance());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates &#123;<span class=\"doctag\">@code</span> ViewModelProvider&#125;, which will create &#123;<span class=\"doctag\">@code</span> ViewModels&#125; via the given</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> Factory&#125; and retain them in a store of the given &#123;<span class=\"doctag\">@code</span> ViewModelStoreOwner&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> owner   a &#123;<span class=\"doctag\">@code</span> ViewModelStoreOwner&#125; whose &#123;<span class=\"doctag\">@link</span> ViewModelStore&#125; will be used to</span></span><br><span class=\"line\"><span class=\"comment\"> *                retain &#123;<span class=\"doctag\">@code</span> ViewModels&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> factory a &#123;<span class=\"doctag\">@code</span> Factory&#125; which will be used to instantiate</span></span><br><span class=\"line\"><span class=\"comment\"> *                new &#123;<span class=\"doctag\">@code</span> ViewModels&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewModelProvider</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ViewModelStoreOwner owner, <span class=\"meta\">@NonNull</span> Factory factory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(owner.getViewModelStore(), factory);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates &#123;<span class=\"doctag\">@code</span> ViewModelProvider&#125;, which will create &#123;<span class=\"doctag\">@code</span> ViewModels&#125; via the given</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> Factory&#125; and retain them in the given &#123;<span class=\"doctag\">@code</span> store&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> store   &#123;<span class=\"doctag\">@code</span> ViewModelStore&#125; where ViewModels will be stored.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> factory factory a &#123;<span class=\"doctag\">@code</span> Factory&#125; which will be used to instantiate</span></span><br><span class=\"line\"><span class=\"comment\"> *                new &#123;<span class=\"doctag\">@code</span> ViewModels&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewModelProvider</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ViewModelStore store, <span class=\"meta\">@NonNull</span> Factory factory)</span> </span>&#123;</span><br><span class=\"line\">    mFactory = factory;</span><br><span class=\"line\">    mViewModelStore = store;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Activity，Fragment实例，他们都实现ViewModelStoreOwner接口，看这名字，顾名思义，就是提供存放ViewModel实例的地方。同时，ViewModelStoreOwner 可能自带ViewModel构造工厂，没有的话，就使用ViewModelProvider 内的NewInstanceFactory实例。</p>\n<p>ViewModelStoreOwner 返回ViewModelStore，内部就是一个Map，key是<code>ViewModelProvider(this).get(MyViewModel.class);</code>get方法传入ViewModel class的canonicalName，value就是对应的ViewModel实例啦。Activity 或者 Fragment 持有ViewModelStore引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.ViewModelProvider</span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    String canonicalName = modelClass.getCanonicalName();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canonicalName == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Local and anonymous classes can not be ViewModels&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get(DEFAULT_KEY + <span class=\"string\">&quot;:&quot;</span> + canonicalName, modelClass);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String key, <span class=\"meta\">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFactory <span class=\"keyword\">instanceof</span> OnRequeryFactory) &#123;</span><br><span class=\"line\">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//noinspection StatementWithEmptyBody</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (viewModel != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> log a warning.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mFactory <span class=\"keyword\">instanceof</span> KeyedFactory) &#123;</span><br><span class=\"line\">        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        viewModel = mFactory.create(modelClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mViewModelStore.put(key, viewModel);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结下，ViewModelStoreOwner 提供负责存储ViewModel的类：ViewModelStore，ViewModel由Factory创建，然后放在ViewModelStore实例内，下次直接从ViewModelStore 通过get方法获取，单例。</p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2021/09/8a107bebc30102c8.png\" alt=\"ViewModel\"></p>\n<h1 id=\"AndroidViewModel-amp-ViewModel\"><a href=\"#AndroidViewModel-amp-ViewModel\" class=\"headerlink\" title=\"AndroidViewModel &amp; ViewModel\"></a>AndroidViewModel &amp; ViewModel</h1><p>ViewModel 不可以强引用Context，如果确实需要，则使用AndroidViewModel，它持有Application的引用。解决需要的同时，避免Activity泄漏。</p>\n<p><code>ViewModelProvider</code> 默认实例化的ViewModel 由NewInstanceFactory 创建。AndroidViewModel 由AndroidViewModelFactory 通过作为实例化<code>ViewModelProvider</code> 构造器的Factory 参数创建。</p>\n<p>Activity &amp; Fragment 也同时实现<code>HasDefaultViewModelProviderFactory</code>接口。看下<code>SavedStateViewModelFactory</code> ，区分是实例化 ViewModel 还是AndroidViewModel，并增加保存状态的处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.SavedStateViewModelFactory</span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String key, <span class=\"meta\">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);</span><br><span class=\"line\">    Constructor&lt;T&gt; constructor;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isAndroidViewModel &amp;&amp; mApplication != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// doesn&#x27;t need SavedStateHandle</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (constructor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mFactory.create(modelClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SavedStateHandleController controller = SavedStateHandleController.create(</span><br><span class=\"line\">            mSavedStateRegistry, mLifecycle, key, mDefaultArgs);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        T viewmodel;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAndroidViewModel &amp;&amp; mApplication != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            viewmodel = constructor.newInstance(mApplication, controller.getHandle());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            viewmodel = constructor.newInstance(controller.getHandle());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> viewmodel;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Failed to access &quot;</span> + modelClass, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;A &quot;</span> + modelClass + <span class=\"string\">&quot; cannot be instantiated.&quot;</span>, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;An exception happened in constructor of &quot;</span></span><br><span class=\"line\">                + modelClass, e.getCause());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ViewModel就是一个壳，与ViewModelStoreOwner共存亡。但Activity因onConfigurationChanged重建后，会获取上一个Activity ViewModelStore，恢复上一个ViewModel。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.activity.<span class=\"function\">ComponentActivity</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ensureViewModelStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        NonConfigurationInstances nc =</span><br><span class=\"line\">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Restore the ViewModelStore from NonConfigurationInstances</span></span><br><span class=\"line\">            mViewModelStore = nc.viewModelStore;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mViewModelStore = <span class=\"keyword\">new</span> ViewModelStore();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"OnRequeryFactory-接口\"><a href=\"#OnRequeryFactory-接口\" class=\"headerlink\" title=\"OnRequeryFactory 接口\"></a>OnRequeryFactory 接口</h1><p>用途：提供从ViewModelProvider get 返回ViewModel实例前的回调，可以在返回前对ViewModel做些预处理。SavedStateViewModelFactory实现此接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.SavedStateViewModelFactory</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onRequery</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ViewModel viewModel)</span> </span>&#123;</span><br><span class=\"line\">    attachHandleIfNeeded(viewModel, mSavedStateRegistry, mLifecycle);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.ViewModelProvider</span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String key, <span class=\"meta\">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// ViewModel返回前处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFactory <span class=\"keyword\">instanceof</span> OnRequeryFactory) &#123;</span><br><span class=\"line\">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//noinspection StatementWithEmptyBody</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (viewModel != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> log a warning.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mFactory <span class=\"keyword\">instanceof</span> KeyedFactory) &#123;</span><br><span class=\"line\">        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        viewModel = mFactory.create(modelClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mViewModelStore.put(key, viewModel);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"FragmentManager源码剖析一","date":"2021-10-18T13:23:33.000Z","_content":"\n\n\n# 总结\n\n1. 使用Fragment的Activity需要继承`FragmentActivity` 这里有派发生命周期方法给FragmentManager，再派发给旗下Fragment。\n2. 加入Fragment时，需要判断`savedInstanceState == null` ，避免重复创建实例。\n3. add Fragment，初始时，其Fragment生命周期方法会被升级到onStart 状态，随后与FragmentManager的状态同步，如果宿主Activity是Resume状态，则同步至onResume状态。\n4. detach fragment，其生命周期方法会被降级到onDestroyView。\n5. remove fragment，其生命周期方法会被降级到onDestroyView 或者onDestroy。\n6. show or hide fragment，生命周期方法不会回调，只是切换fragment 根view的可见性。\n\n# Sample codes\n\n```java\npublic class ExampleActivity extends AppCompatActivity {\n    public ExampleActivity() {\n        super(R.layout.example_activity);\n    }\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (savedInstanceState == null) {\n            getSupportFragmentManager().beginTransaction()\n                .setReorderingAllowed(true)\n                .add(R.id.fragment_container_view, ExampleFragment.class)\n\t\t\t\t\t\t\t\t// name can be null\n\t\t\t\t\t\t\t\t.addToBackStack(\"name\") \n                .commit();\n        }\n    }\n}\n```\n\nNote: the fragment transaction is only created when savedInstanceState is null. This is to ensure that the fragment is added only once, when the activity is first created. When a configuration change occurs and the activity is recreated, savedInstanceState is no longer null, and the fragment does not need to be added a second time, as the fragment is automatically restored from the savedInstanceState.\n\nNote: You should always use setReorderingAllowed(true) when performing a FragmentTransaction. For more information on reordered transactions, see Fragment transactions.\n\n## beginTransaction\n\n```java\n@NonNull\n@Override\npublic FragmentTransaction beginTransaction() {\n    return new BackStackRecord(this);\n}\n```\n\n## setReorderingAllowed\n\n```java\n/**\n * Sets whether or not to allow optimizing operations within and across\n * transactions. This will remove redundant operations, eliminating\n * operations that cancel. For example, if two transactions are executed\n * together, one that adds a fragment A and the next replaces it with fragment B,\n * the operations will cancel and only fragment B will be added. That means that\n * fragment A may not go through the creation/destruction lifecycle.\n * <p>\n * The side effect of removing redundant operations is that fragments may have state changes\n * out of the expected order. For example, one transaction adds fragment A,\n * a second adds fragment B, then a third removes fragment A. Without removing the redundant\n * operations, fragment B could expect that while it is being created, fragment A will also\n * exist because fragment A will be removed after fragment B was added.\n * With removing redundant operations, fragment B cannot expect fragment A to exist when\n * it has been created because fragment A's add/remove will be optimized out.\n * <p>\n * It can also reorder the state changes of Fragments to allow for better Transitions.\n * Added Fragments may have {@link Fragment#onCreate(Bundle)} called before replaced\n * Fragments have {@link Fragment#onDestroy()} called.\n * <p>\n * {@link Fragment#postponeEnterTransition()} requires {@code setReorderingAllowed(true)}.\n * <p>\n * The default is {@code false}.\n *\n * @param reorderingAllowed {@code true} to enable optimizing out redundant operations\n *                          or {@code false} to disable optimizing out redundant\n *                          operations on this transaction.\n */\n@NonNull\npublic FragmentTransaction setReorderingAllowed(boolean reorderingAllowed) {\n    mReorderingAllowed = reorderingAllowed;\n    return this;\n}\n```\n\n## add\n\n```java\n/**\n * Calls {@link #add(int, Fragment, String)} with a 0 containerViewId.\n */\n@NonNull\npublic FragmentTransaction add(@NonNull Fragment fragment, @Nullable String tag)  {\n    doAddOp(0, fragment, tag, OP_ADD);\n    return this;\n}\n```\n\n```java\nvoid doAddOp(int containerViewId, Fragment fragment, @Nullable String tag, int opcmd) {\n    final Class<?> fragmentClass = fragment.getClass();\n    final int modifiers = fragmentClass.getModifiers();\n    if (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers)\n            || (fragmentClass.isMemberClass() && !Modifier.isStatic(modifiers))) {\n        throw new IllegalStateException(\"Fragment \" + fragmentClass.getCanonicalName()\n                + \" must be a public static class to be  properly recreated from\"\n                + \" instance state.\");\n    }\n\n    if (tag != null) {\n        if (fragment.mTag != null && !tag.equals(fragment.mTag)) {\n            throw new IllegalStateException(\"Can't change tag of fragment \"\n                    + fragment + \": was \" + fragment.mTag\n                    + \" now \" + tag);\n        }\n        fragment.mTag = tag;\n    }\n\n    if (containerViewId != 0) {\n        if (containerViewId == View.NO_ID) {\n            throw new IllegalArgumentException(\"Can't add fragment \"\n                    + fragment + \" with tag \" + tag + \" to container view with no id\");\n        }\n        if (fragment.mFragmentId != 0 && fragment.mFragmentId != containerViewId) {\n            throw new IllegalStateException(\"Can't change container ID of fragment \"\n                    + fragment + \": was \" + fragment.mFragmentId\n                    + \" now \" + containerViewId);\n        }\n        fragment.mContainerId = fragment.mFragmentId = containerViewId;\n    }\n\n    addOp(new Op(opcmd, fragment));\n}\n```\n\n```java\nvoid addOp(Op op) {\n    mOps.add(op);\n    op.mEnterAnim = mEnterAnim;\n    op.mExitAnim = mExitAnim;\n    op.mPopEnterAnim = mPopEnterAnim;\n    op.mPopExitAnim = mPopExitAnim;\n}\n```\n\n传入fragment实例，将对fragment的增删换，显示隐藏等操作封装成op，并加入op列表集合，作为一个操作事物。\n\n## addToBackStack\n\n```java\n/**\n * Add this transaction to the back stack.  This means that the transaction\n * will be remembered after it is committed, and will reverse its operation\n * when later popped off the stack.\n * <p>\n * {@link #setReorderingAllowed(boolean)} must be set to <code>true</code>\n * in the same transaction as addToBackStack() to allow the pop of that\n * transaction to be reordered.\n *\n * @param name An optional name for this back stack state, or null.\n */\n@NonNull\npublic FragmentTransaction addToBackStack(@Nullable String name) {\n    if (!mAllowAddToBackStack) {\n        throw new IllegalStateException(\n                \"This FragmentTransaction is not allowed to be added to the back stack.\");\n    }\n    mAddToBackStack = true;\n    mName = name;\n    return this;\n}\n```\n\naddToBackStack更新mAddToBackStack标记位，并保存backStack名字，作为未来回退到此backStack的标示。\n\n## commit\n\n```java\nandroidx.fragment.app.BackStackRecord#commitInternal\n\nint commitInternal(boolean allowStateLoss) {\n    if (mCommitted) throw new IllegalStateException(\"commit already called\");\n    mCommitted = true;\n    if (mAddToBackStack) {\n        mIndex = mManager.allocBackStackIndex(this);\n    } else {\n        mIndex = -1;\n    }\n    mManager.enqueueAction(this, allowStateLoss);\n    return mIndex;\n}\n```\n\n如果加入backStack，则分配一个在backStack的索引，然后将此事务加入提交队列，等待主线程调度提交。\n\n```java\nandroidx.fragment.app.FragmentManager#enqueueAction\n\n/**\n * Adds an action to the queue of pending actions.\n *\n * @param action the action to add\n * @param allowStateLoss whether to allow loss of state information\n * @throws IllegalStateException if the activity has been destroyed\n */\npublic void enqueueAction(OpGenerator action, boolean allowStateLoss) {\n    if (!allowStateLoss) {\n        checkStateLoss();\n    }\n    synchronized (this) {\n        if (mDestroyed || mHost == null) {\n            if (allowStateLoss) {\n                // This FragmentManager isn't attached, so drop the entire transaction.\n                return;\n            }\n            throw new IllegalStateException(\"Activity has been destroyed\");\n        }\n        if (mPendingActions == null) {\n            mPendingActions = new ArrayList<>();\n        }\n        mPendingActions.add(action);\n        scheduleCommit();\n    }\n}\n```\n\n## OpGenerator\n\nBackStackRecord实现OpGenerator接口，先看下方法实现内容：将本次事务加入事务集合。并且判断如果要支持回退栈，则加入回退栈集合。\n\n```java\nandroidx.fragment.app.BackStackRecord#generateOps\n\n/**\n * Implementation of {@link FragmentManagerImpl.OpGenerator}.\n * This operation is added to the list of pending actions during {@link #commit()}, and\n * will be executed on the UI thread to run this FragmentTransaction.\n *\n * @param records Modified to add this BackStackRecord\n * @param isRecordPop Modified to add a false (this isn't a pop)\n * @return true always because the records and isRecordPop will always be changed\n */\n@Override\npublic boolean generateOps(ArrayList<BackStackRecord> records, ArrayList<Boolean> isRecordPop) {\n    if (FragmentManagerImpl.DEBUG) {\n        Log.v(TAG, \"Run: \" + this);\n    }\n\n    records.add(this);\n    isRecordPop.add(false);\n    if (mAddToBackStack) {\n        mManager.addBackStackState(this);\n    }\n    return true;\n}\n```\n\n```java\nandroidx.fragment.app.FragmentManager#addBackStackState\n\nvoid addBackStackState(BackStackRecord state) {\n    if (mBackStack == null) {\n        mBackStack = new ArrayList<BackStackRecord>();\n    }\n    mBackStack.add(state);\n}\n```\n\n# scheduleCommit\n\n## ensureExecReady\n\n条件检查，并实例化mTmpRecords & mTmpIsPop。\n\n```java\nandroidx.fragment.app.FragmentManager#execPendingActions\n\n/**\n * Only call from main thread!\n */\npublic boolean execPendingActions() {\n    ensureExecReady(true);// 1. Init mTmpRecords & mTmpIsPop\n\n    boolean didSomething = false;\n    // 2. Copy BackStackRecord  in mPendingActions into mTmpRecords， so does mTmpIsPop \n    while (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) {\n        mExecutingActions = true;\n        try {\n\t\t\t\t\t\t// 3. \n            removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop);\n        } finally {\n            cleanupExec();\n        }\n        didSomething = true;\n    }\n\n    updateOnBackPressedCallbackEnabled();\n    doPendingDeferredStart();\n    burpActive();\n\n    return didSomething;\n}\n```\n\n## generateOpsForPendingActions\n\n将mPendingActions的BackStackRecord，即我们提交的事务集合，复制到records（即成员变量mTmpRecords，mTmpIsPop同理）\n\n```java\nandroidx.fragment.app.FragmentManager#generateOpsForPendingActions\n\n/**\n * Adds all records in the pending actions to records and whether they are add or pop\n * operations to isPop. After executing, the pending actions will be empty.\n *\n * @param records All pending actions will generate BackStackRecords added to this.\n *                This contains the transactions, in order, to execute.\n * @param isPop All pending actions will generate booleans to add to this. This contains\n *              an entry for each entry in records to indicate whether or not it is a\n *              pop action.\n */\nprivate boolean generateOpsForPendingActions(ArrayList<BackStackRecord> records,\n                                             ArrayList<Boolean> isPop) {\n    boolean didSomething = false;\n    synchronized (this) {\n        if (mPendingActions == null || mPendingActions.size() == 0) {\n            return false;\n        }\n\n        final int numActions = mPendingActions.size();\n        for (int i = 0; i < numActions; i++) {\n            didSomething |= mPendingActions.get(i).generateOps(records, isPop);\n        }\n        mPendingActions.clear();\n        mHost.getHandler().removeCallbacks(mExecCommit);\n    }\n    return didSomething;\n}\n```\n\n## removeRedundantOperationsAndExecute\n\n```java\nandroidx.fragment.app.FragmentManager#removeRedundantOperationsAndExecute\n\n/**\n * Remove redundant BackStackRecord operations and executes them. This method merges operations\n * of proximate records that allow reordering. See\n * {@link FragmentTransaction#setReorderingAllowed(boolean)}.\n * <p>\n * For example, a transaction that adds to the back stack and then another that pops that\n * back stack record will be optimized to remove the unnecessary operation.\n * <p>\n * Likewise, two transactions committed that are executed at the same time will be optimized\n * to remove the redundant operations as well as two pop operations executed together.\n *\n * @param records The records pending execution\n * @param isRecordPop The direction that these records are being run.\n */\nprivate void removeRedundantOperationsAndExecute(ArrayList<BackStackRecord> records,\n                                                 ArrayList<Boolean> isRecordPop) {\n    if (records == null || records.isEmpty()) {\n        return;\n    }\n\n    if (isRecordPop == null || records.size() != isRecordPop.size()) {\n        throw new IllegalStateException(\"Internal error with the back stack records\");\n    }\n\n    // Force start of any postponed transactions that interact with scheduled transactions:\n    executePostponedTransaction(records, isRecordPop);\n\n    final int numRecords = records.size();\n    int startIndex = 0;\n    for (int recordNum = 0; recordNum < numRecords; recordNum++) {\n        final boolean canReorder = records.get(recordNum).mReorderingAllowed;\n        if (!canReorder) {\n            // execute all previous transactions\n            if (startIndex != recordNum) {\n                executeOpsTogether(records, isRecordPop, startIndex, recordNum);\n            }\n            // execute all pop operations that don't allow reordering together or\n            // one add operation\n            int reorderingEnd = recordNum + 1;\n            if (isRecordPop.get(recordNum)) {\n                while (reorderingEnd < numRecords\n                        && isRecordPop.get(reorderingEnd)\n                        && !records.get(reorderingEnd).mReorderingAllowed) {\n                    reorderingEnd++;\n                }\n            }\n            executeOpsTogether(records, isRecordPop, recordNum, reorderingEnd);\n            startIndex = reorderingEnd;\n            recordNum = reorderingEnd - 1;\n        }\n    }\n\t\t// Reorder is true as example code. Pay attention here.\n    if (startIndex != numRecords) {\n\t\t\t\t// startIndex 为0， numRecords为批处理的事务个数。\n        executeOpsTogether(records, isRecordPop, startIndex, numRecords);\n    }\n}\n```\n\n## executeOpsTogether\n\n一般推荐允许重排序，看最后一行方法调用executeOpsTogether。从API描述看，它执行事务集合的子集，子集里事务要么是允许重排序，要么不允许。\n\n```java\nandroidx.fragment.app.FragmentManager#executeOpsTogether\n\n/**\n * Executes a subset of a list of BackStackRecords, all of which either allow reordering or\n * do not allow ordering.\n * @param records A list of BackStackRecords that are to be executed\n * @param isRecordPop The direction that these records are being run.\n * @param startIndex The index of the first record in <code>records</code> to be executed\n * @param endIndex One more than the final record index in <code>records</code> to executed.\n */\nprivate void executeOpsTogether(@NonNull ArrayList<BackStackRecord> records,\n        @NonNull ArrayList<Boolean> isRecordPop, int startIndex, int endIndex) {\n    final boolean allowReordering = records.get(startIndex).mReorderingAllowed;\n    boolean addToBackStack = false;\n    if (mTmpAddedFragments == null) {\n        mTmpAddedFragments = new ArrayList<>();\n    } else {\n        mTmpAddedFragments.clear();\n    }\n\t\t// 执行transaction.add(fragment)，事务完成后，fragment会加入mAdded集合内，\n\t\t// activity生命周期方法派发给FragmentManager，继而派发给mAdded集合内的Fragment\n\t\t// 此处复制已添加Fragment集合到临时变量，\n    mTmpAddedFragments.addAll(mFragmentStore.getFragments());\n    Fragment oldPrimaryNav = getPrimaryNavigationFragment();\n    for (int recordNum = startIndex; recordNum < endIndex; recordNum++) {\n        final BackStackRecord record = records.get(recordNum);\n        final boolean isPop = isRecordPop.get(recordNum);\n        if (!isPop) {\n\t\t\t\t\t\t// 这里将op替换为更原子的操作，如replace拆解为remove & add，并将ops内的fragment\n\t\t\t\t\t\t// 依照op的cmd命令，从mTmpAddedFragments add 或 remove op里的fragment，\n            oldPrimaryNav = record.expandOps(mTmpAddedFragments, oldPrimaryNav);\n        } else {\n            oldPrimaryNav = record.trackAddedFragmentsInPop(mTmpAddedFragments, oldPrimaryNav);\n        }\n        addToBackStack = addToBackStack || record.mAddToBackStack;\n    }\n    mTmpAddedFragments.clear();\n\n    if (!allowReordering && mCurState >= Fragment.CREATED) {\n        // 一般推荐重排序，此处代码省略\n    }\n    // 1. 遍历BackStackRecord集合，逐个执行事务：将Fragment发送给FragmentManager管理，并更新Fragment标记。\n    executeOps(records, isRecordPop, startIndex, endIndex);\n\n    if (USE_STATE_MANAGER) {\n        // The last operation determines the overall direction, this ensures that operations\n        // such as push, push, pop, push are correctly considered a push\n        boolean isPop = isRecordPop.get(endIndex - 1);\n        // Ensure that Fragments directly affected by operations\n        // are moved to their expected state in operation order\n        for (int index = startIndex; index < endIndex; index++) {\n            BackStackRecord record = records.get(index);\n            if (isPop) {\n                // Pop operations get applied in reverse order\n                for (int opIndex = record.mOps.size() - 1; opIndex >= 0; opIndex--) {\n                    FragmentTransaction.Op op = record.mOps.get(opIndex);\n                    Fragment fragment = op.mFragment;\n                    if (fragment != null) {\n                        FragmentStateManager fragmentStateManager =\n                                createOrGetFragmentStateManager(fragment);\n                        fragmentStateManager.moveToExpectedState();\n                    }\n                }\n            } else {\n                for (FragmentTransaction.Op op : record.mOps) {\n                    Fragment fragment = op.mFragment;\n                    if (fragment != null) {\n                        FragmentStateManager fragmentStateManager =\n                                createOrGetFragmentStateManager(fragment);\n\t\t\t\t\t\t\t\t\t\t\t\t// 2. 事务内的Fragment推送至默认状态\n                        fragmentStateManager.moveToExpectedState();\n                    }\n                }\n            }\n\n        }\n        // And only then do we move all other fragments to the current state\n\t\t\t\t// 3. 将Fragment全部推送到当前FragmentManager的状态。\n        moveToState(mCurState, true);\n        Set<SpecialEffectsController> changedControllers = collectChangedControllers(\n                records, startIndex, endIndex);\n        for (SpecialEffectsController controller : changedControllers) {\n            controller.updateOperationDirection(isPop);\n            controller.markPostponedState();\n            controller.executePendingOperations();\n        }\n    } else {\n        // USE_STATE_MANAGER 默认为true，此处代码省略\n    }\n\t\t// 调用每个事务的提交监听回掉\n    for (int recordNum = startIndex; recordNum < endIndex; recordNum++) {\n        final BackStackRecord record = records.get(recordNum);\n        final boolean isPop = isRecordPop.get(recordNum);\n        if (isPop && record.mIndex >= 0) {\n            record.mIndex = -1;\n        }\n        record.runOnCommitRunnables();\n    }\n\t\t// // 通知backStack变更的监听回掉\n    if (addToBackStack) {\n        reportBackStackChanged();\n    }\n}\n```\n\n### executeOps\n\n```java\nandroidx.fragment.app.FragmentManager#executeOps\n\n/**\n * Run the operations in the BackStackRecords, either to push or pop.\n *\n * @param records The list of records whose operations should be run.\n * @param isRecordPop The direction that these records are being run.\n * @param startIndex The index of the first entry in records to run.\n * @param endIndex One past the index of the final entry in records to run.\n */\nprivate static void executeOps(ArrayList<BackStackRecord> records,\n                               ArrayList<Boolean> isRecordPop, int startIndex, int endIndex) {\n    for (int i = startIndex; i < endIndex; i++) {\n        final BackStackRecord record = records.get(i);\n        final boolean isPop = isRecordPop.get(i);\n        if (isPop) {\n            record.bumpBackStackNesting(-1);\n            // Only execute the add operations at the end of\n            // all transactions.\n            boolean moveToState = i == (endIndex - 1);\n            record.executePopOps(moveToState);\n        } else {\n            record.bumpBackStackNesting(1);\n            record.executeOps();\n        }\n    }\n}\n```\n\n遍历事务Op集合，逐个执行事务里的Op\n\n```java\nandroidx.fragment.app.BackStackRecord#executeOps\n\n/**\n * Executes the operations contained within this transaction. The Fragment states will only\n * be modified if optimizations are not allowed.\n */\nvoid executeOps() {\n    final int numOps = mOps.size();\n    for (int opNum = 0; opNum < numOps; opNum++) {\n        final Op op = mOps.get(opNum);\n        final Fragment f = op.mFragment;\n        if (f != null) {\n            f.setPopDirection(false);\n            f.setAnimations(op.mEnterAnim, op.mExitAnim, op.mPopEnterAnim, op.mPopExitAnim);\n            f.setNextTransition(mTransition);\n            f.setSharedElementNames(mSharedElementSourceNames, mSharedElementTargetNames);\n        }\n        switch (op.mCmd) {\n            case OP_ADD:\n                mManager.setExitAnimationOrder(f, false);\n                mManager.addFragment(f);\n                break;\n            case OP_REMOVE:\n                mManager.removeFragment(f);\n                break;\n            case OP_HIDE:\n                mManager.hideFragment(f);\n                break;\n            case OP_SHOW:\n                mManager.setExitAnimationOrder(f, false);\n                mManager.showFragment(f);\n                break;\n            case OP_DETACH:\n                mManager.detachFragment(f);\n                break;\n            case OP_ATTACH:\n                mManager.setExitAnimationOrder(f, false);\n                mManager.attachFragment(f);\n                break;\n            case OP_SET_PRIMARY_NAV:\n                mManager.setPrimaryNavigationFragment(f);\n                break;\n            case OP_UNSET_PRIMARY_NAV:\n                mManager.setPrimaryNavigationFragment(null);\n                break;\n            case OP_SET_MAX_LIFECYCLE:\n                mManager.setMaxLifecycle(f, op.mCurrentMaxState);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown cmd: \" + op.mCmd);\n        }\n\t\t\t\t// 允许排序，以下代码不执行\n        if (!mReorderingAllowed && op.mCmd != OP_ADD && f != null) {\n            if (!FragmentManager.USE_STATE_MANAGER) {\n                mManager.moveFragmentToExpectedState(f);\n            }\n        }\n    }\n    if (!mReorderingAllowed && !FragmentManager.USE_STATE_MANAGER) {\n        // Added fragments are added at the end to comply with prior behavior.\n        mManager.moveToState(mManager.mCurState, true);\n    }\n}\n```\n\naddFragment & removeFragment 主要是操作mAdded fragment集合并更新fragment.mRemoving & fragment.mAdded 标记\n\n```java\nandroidx.fragment.app.FragmentManager#removeFragment\nvoid removeFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) {\n        Log.v(TAG, \"remove: \" + fragment + \" nesting=\" + fragment.mBackStackNesting);\n    }\n    final boolean inactive = !fragment.isInBackStack();\n    if (!fragment.mDetached || inactive) {\n        mFragmentStore.removeFragment(fragment);\n        if (isMenuAvailable(fragment)) {\n            mNeedMenuInvalidate = true;\n        }\n        fragment.mRemoving = true;\n        setVisibleRemovingFragment(fragment);\n    }\n}\n\nandroidx.fragment.app.FragmentManager#addFragment\nFragmentStateManager addFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"add: \" + fragment);\n    FragmentStateManager fragmentStateManager = createOrGetFragmentStateManager(fragment);\n    fragment.mFragmentManager = this;\n    mFragmentStore.makeActive(fragmentStateManager);\n    if (!fragment.mDetached) {\n        mFragmentStore.addFragment(fragment);\n        fragment.mRemoving = false;\n        if (fragment.mView == null) {\n            fragment.mHiddenChanged = false;\n        }\n        if (isMenuAvailable(fragment)) {\n            mNeedMenuInvalidate = true;\n        }\n    }\n    return fragmentStateManager;\n}\n```\n\nattachFragment 与addFragment的差异： \n\n1. 无makeActive(fragment)，这个差异导致两者的Fragment默认升级到started状态后，只有add fragment会继续与FragmentManager状态同步，接收FragmentManager生命周期方法的派发，attach fragment则到此戛然而止。也没有moveToState(fragment)操作（addFragment下，此方法不调用，传入moveToStateNow参数值为false）\n2. 只有之前detach操作过，attach才有效果。\n\n```java\nandroidx.fragment.app.FragmentManager#attachFragment\nvoid attachFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"attach: \" + fragment);\n    if (fragment.mDetached) {\n\t\t\t\t// 初始化时，mDetached为false，只有detachFragment才置为true。\n        fragment.mDetached = false;\n        if (!fragment.mAdded) {\n            mFragmentStore.addFragment(fragment);\n            if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"add from attach: \" + fragment);\n            if (isMenuAvailable(fragment)) {\n                mNeedMenuInvalidate = true;\n            }\n        }\n    }\n}\n\nandroidx.fragment.app.FragmentStore#addFragment\nvoid addFragment(@NonNull Fragment fragment) {\n    if (mAdded.contains(fragment)) {\n        throw new IllegalStateException(\"Fragment already added: \" + fragment);\n    }\n    synchronized (mAdded) {\n        mAdded.add(fragment);\n    }\n    fragment.mAdded = true;\n}\n```\n\nremove & detachFragment都将fragment从mAdded集合移除fragment，不同的是分别标记mRemoving & mDetached 为true。\n\n```java\nvoid removeFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) {\n        Log.v(TAG, \"remove: \" + fragment + \" nesting=\" + fragment.mBackStackNesting);\n    }\n    final boolean inactive = !fragment.isInBackStack();\n    if (!fragment.mDetached || inactive) {\n        mFragmentStore.removeFragment(fragment);\n        if (isMenuAvailable(fragment)) {\n            mNeedMenuInvalidate = true;\n        }\n        fragment.mRemoving = true;\n        setVisibleRemovingFragment(fragment);\n    }\n}\n\nvoid removeFragment(@NonNull Fragment fragment) {\n    synchronized (mAdded) {\n        mAdded.remove(fragment);\n    }\n    fragment.mAdded = false;\n}\n```\n\n```java\nvoid detachFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"detach: \" + fragment);\n    if (!fragment.mDetached) {\n        fragment.mDetached = true;\n        if (fragment.mAdded) {\n            // We are not already in back stack, so need to remove the fragment.\n            if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"remove from detach: \" + fragment);\n            mFragmentStore.removeFragment(fragment);\n            if (isMenuAvailable(fragment)) {\n                mNeedMenuInvalidate = true;\n            }\n            setVisibleRemovingFragment(fragment);\n        }\n    }\n}\n```\n\nshowFrament & hideFragment 主要更新mHidden标记\n\n```java\n/**\n * Marks a fragment as hidden to be later animated in with\n * {@link #completeShowHideFragment(Fragment)}.\n *\n * @param fragment The fragment to be shown.\n */\nvoid hideFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"hide: \" + fragment);\n    if (!fragment.mHidden) {\n        fragment.mHidden = true;\n        // Toggle hidden changed so that if a fragment goes through show/hide/show\n        // it doesn't go through the animation.\n        fragment.mHiddenChanged = !fragment.mHiddenChanged;\n        setVisibleRemovingFragment(fragment);\n    }\n}\n\n/**\n * Marks a fragment as shown to be later animated in with\n * {@link #completeShowHideFragment(Fragment)}.\n *\n * @param fragment The fragment to be shown.\n */\nvoid showFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"show: \" + fragment);\n    if (fragment.mHidden) {\n        fragment.mHidden = false;\n        // Toggle hidden changed so that if a fragment goes through show/hide/show\n        // it doesn't go through the animation.\n        fragment.mHiddenChanged = !fragment.mHiddenChanged;\n    }\n}\n```\n\nFragment 主要标记\n\n```java\n// True if the fragment is in the list of added fragments.\nboolean mAdded;\n\n// If set this fragment is being removed from its activity.\nboolean mRemoving;\n\n// Set to true when the app has requested that this fragment be hidden\n// from the user.\nboolean mHidden;\n\n// Set to true when the app has requested that this fragment be deactivated.\nboolean mDetached;\n```\n\n### moveToExpectedState\n\n遍历事务集合，将事务内每个op 对应的Fragment推送到合适的状态，具体状态值在computeExpectedState计算。默认是当前FragmentManager的状态。但会根据Fragment标记重算。\n\n```java\n// Assume the Fragment can go as high as the FragmentManager's state\nint maxState = mFragmentManagerState;\n// Fragments that are not currently added will sit in the CREATED state.\n// detach & remove 操作的fragment，目标状态是CREATED\nif (!mFragment.mAdded) {\n    maxState = Math.min(maxState, Fragment.CREATED);\n}\n\nif (mFragment.mRemoving) {\n    if (mFragment.isInBackStack()) {\n        // Fragments on the back stack shouldn't go higher than CREATED\n        maxState = Math.min(maxState, Fragment.CREATED);\n    } else {\n        // While removing a fragment, we always move to INITIALIZING\n\t\t\t\t// remove 操作的Fragment，如果不在回退栈，目标状态是INITIALIZING\n        maxState = Math.min(maxState, Fragment.INITIALIZING);\n    }\n}\n```\n\n```java\nvoid moveToExpectedState() {\n        if (mMovingToState) {\n            if (FragmentManager.isLoggingEnabled(Log.VERBOSE)) {\n                Log.v(FragmentManager.TAG, \"Ignoring re-entrant call to \"\n                        + \"moveToExpectedState() for \" + getFragment());\n            }\n            return;\n        }\n        try {\n            mMovingToState = true;\n\n            int newState;\n            while ((newState = computeExpectedState()) != mFragment.mState) {\n                if (newState > mFragment.mState) {\n                    // Moving upward\n                    int nextStep = mFragment.mState + 1;\n                    switch (nextStep) {\n                        case Fragment.ATTACHED:\n                            attach();\n                            break;\n                        case Fragment.CREATED:\n                            create();\n                            break;\n                        case Fragment.VIEW_CREATED:\n                            ensureInflatedView();\n                            createView();\n                            break;\n                        case Fragment.AWAITING_EXIT_EFFECTS:\n                            activityCreated();\n                            break;\n                        case Fragment.ACTIVITY_CREATED:\n                            if (mFragment.mView != null && mFragment.mContainer != null) {\n                                SpecialEffectsController controller = SpecialEffectsController\n                                        .getOrCreateController(mFragment.mContainer,\n                                                mFragment.getParentFragmentManager());\n                                int visibility = mFragment.mView.getVisibility();\n                                SpecialEffectsController.Operation.State finalState =\n                                        SpecialEffectsController.Operation.State.from(visibility);\n                                controller.enqueueAdd(finalState, this);\n                            }\n                            mFragment.mState = Fragment.ACTIVITY_CREATED;\n                            break;\n                        case Fragment.STARTED:\n                            start();\n                            break;\n                        case Fragment.AWAITING_ENTER_EFFECTS:\n                            mFragment.mState = Fragment.AWAITING_ENTER_EFFECTS;\n                            break;\n                        case Fragment.RESUMED:\n                            resume();\n                            break;\n                    }\n                } else {\n                    // Moving downward\n                    int nextStep = mFragment.mState - 1;\n                    switch (nextStep) {\n                        case Fragment.AWAITING_ENTER_EFFECTS:\n                            pause();\n                            break;\n                        case Fragment.STARTED:\n                            mFragment.mState = Fragment.STARTED;\n                            break;\n                        case Fragment.ACTIVITY_CREATED:\n                            stop();\n                            break;\n                        case Fragment.AWAITING_EXIT_EFFECTS:\n                            if (FragmentManager.isLoggingEnabled(Log.DEBUG)) {\n                                Log.d(TAG, \"movefrom ACTIVITY_CREATED: \" + mFragment);\n                            }\n                            if (mFragment.mView != null) {\n                                // Need to save the current view state if not done already\n                                // by saveInstanceState()\n                                if (mFragment.mSavedViewState == null) {\n                                    saveViewState();\n                                }\n                            }\n                            if (mFragment.mView != null && mFragment.mContainer != null) {\n                                SpecialEffectsController controller = SpecialEffectsController\n                                        .getOrCreateController(mFragment.mContainer,\n                                                mFragment.getParentFragmentManager());\n                                controller.enqueueRemove(this);\n                            }\n                            mFragment.mState = Fragment.AWAITING_EXIT_EFFECTS;\n                            break;\n                        case Fragment.VIEW_CREATED:\n                            mFragment.mInLayout = false;\n                            mFragment.mState = Fragment.VIEW_CREATED;\n                            break;\n                        case Fragment.CREATED:\n                            destroyFragmentView();\n                            mFragment.mState = Fragment.CREATED;\n                            break;\n                        case Fragment.ATTACHED:\n                            destroy();\n                            break;\n                        case Fragment.INITIALIZING:\n                            detach();\n                            break;\n                    }\n                }\n            }\n            if (FragmentManager.USE_STATE_MANAGER && mFragment.mHiddenChanged) {\n                if (mFragment.mView != null && mFragment.mContainer != null) {\n                    // Get the controller and enqueue the show/hide\n                    SpecialEffectsController controller = SpecialEffectsController\n                            .getOrCreateController(mFragment.mContainer,\n                                    mFragment.getParentFragmentManager());\n                    if (mFragment.mHidden) {\n                        controller.enqueueHide(this);\n                    } else {\n                        controller.enqueueShow(this);\n                    }\n                }\n                if (mFragment.mFragmentManager != null) {\n                    mFragment.mFragmentManager.invalidateMenuForFragment(mFragment);\n                }\n                mFragment.mHiddenChanged = false;\n                mFragment.onHiddenChanged(mFragment.mHidden);\n            }\n        } finally {\n            mMovingToState = false;\n        }\n    }\n```\n\n```java\nandroidx.fragment.app.FragmentManager#moveToState(int, boolean)\n/**\n * Changes the state of the fragment manager to {@code newState}. If the fragment manager\n * changes state or {@code always} is {@code true}, any fragments within it have their\n * states updated as well.\n *\n * @param newState The new state for the fragment manager\n * @param always If {@code true}, all fragments update their state, even\n *               if {@code newState} matches the current fragment manager's state.\n */\nvoid moveToState(int newState, boolean always) {\n    if (mHost == null && newState != Fragment.INITIALIZING) {\n        throw new IllegalStateException(\"No activity\");\n    }\n\n    if (!always && newState == mCurState) {\n        return;\n    }\n\n    mCurState = newState;\n\n    if (USE_STATE_MANAGER) {\n        mFragmentStore.moveToExpectedState();\n    } else {\n        // Must add them in the proper order. mActive fragments may be out of order\n        for (Fragment f : mFragmentStore.getFragments()) {\n            moveFragmentToExpectedState(f);\n        }\n\n        // Now iterate through all active fragments. These will include those that are removed\n        // and detached.\n        for (FragmentStateManager fragmentStateManager :\n                mFragmentStore.getActiveFragmentStateManagers()) {\n            Fragment f = fragmentStateManager.getFragment();\n            if (!f.mIsNewlyAdded) {\n                moveFragmentToExpectedState(f);\n            }\n            boolean beingRemoved = f.mRemoving && !f.isInBackStack();\n            if (beingRemoved) {\n                mFragmentStore.makeInactive(fragmentStateManager);\n            }\n        }\n    }\n\n    startPendingDeferredFragments();\n\n    if (mNeedMenuInvalidate && mHost != null && mCurState == Fragment.RESUMED) {\n        mHost.onSupportInvalidateOptionsMenu();\n        mNeedMenuInvalidate = false;\n    }\n}\n```\n\n同步FragmentManager的状态到mActive集合里的Fragments，mAdded集合的不同步。\n\n```java\nandroidx.fragment.app.FragmentStore#moveToExpectedState\nvoid moveToExpectedState() {\n    // Must add them in the proper order. mActive fragments may be out of order\n    for (Fragment f : mAdded) {\n        FragmentStateManager fragmentStateManager = mActive.get(f.mWho);\n        if (fragmentStateManager != null) {\n            fragmentStateManager.moveToExpectedState();\n        }\n    }\n\n    // Now iterate through all active fragments. These will include those that are removed\n    // and detached.\n    for (FragmentStateManager fragmentStateManager : mActive.values()) {\n        if (fragmentStateManager != null) {\n            fragmentStateManager.moveToExpectedState();\n\n            Fragment f = fragmentStateManager.getFragment();\n            boolean beingRemoved = f.mRemoving && !f.isInBackStack();\n            if (beingRemoved) {\n                makeInactive(fragmentStateManager);\n            }\n        }\n    }\n}\n```\n\n将当前Fragment的状态沿着下方箭头方向升级（curState < newState），或降级(curState > newState)至newState，（想象状态值是一个等腰三角形，resumed在上方顶点，created & destroyed位于下方两端。从左顶点到上顶点是升级，上顶点到右顶点是降级）状态值如下，RESUMED状态值最大。当前newState参数值为STARTED。\n\n```java\nstatic final int INITIALIZING = 0;     // Not yet created.\nstatic final int CREATED = 1;          // Created.\nstatic final int ACTIVITY_CREATED = 2; // Fully created, not started.\nstatic final int STARTED = 3;          // Created and started, not resumed.\nstatic final int RESUMED = 4;          // Created started and resumed.\n```\n\n![https://developer.android.com/images/guide/fragments/fragment-view-lifecycle.png](https://developer.android.com/images/guide/fragments/fragment-view-lifecycle.png)\n\n由上可见，Fragment 添加后，首先推送升级到STARTED状态。\n","source":"_posts/FragmentManager源码剖析1.md","raw":"---\ntitle: FragmentManager源码剖析一\ndate: 2021-10-18 21:23:33\ntags:\n---\n\n\n\n# 总结\n\n1. 使用Fragment的Activity需要继承`FragmentActivity` 这里有派发生命周期方法给FragmentManager，再派发给旗下Fragment。\n2. 加入Fragment时，需要判断`savedInstanceState == null` ，避免重复创建实例。\n3. add Fragment，初始时，其Fragment生命周期方法会被升级到onStart 状态，随后与FragmentManager的状态同步，如果宿主Activity是Resume状态，则同步至onResume状态。\n4. detach fragment，其生命周期方法会被降级到onDestroyView。\n5. remove fragment，其生命周期方法会被降级到onDestroyView 或者onDestroy。\n6. show or hide fragment，生命周期方法不会回调，只是切换fragment 根view的可见性。\n\n# Sample codes\n\n```java\npublic class ExampleActivity extends AppCompatActivity {\n    public ExampleActivity() {\n        super(R.layout.example_activity);\n    }\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (savedInstanceState == null) {\n            getSupportFragmentManager().beginTransaction()\n                .setReorderingAllowed(true)\n                .add(R.id.fragment_container_view, ExampleFragment.class)\n\t\t\t\t\t\t\t\t// name can be null\n\t\t\t\t\t\t\t\t.addToBackStack(\"name\") \n                .commit();\n        }\n    }\n}\n```\n\nNote: the fragment transaction is only created when savedInstanceState is null. This is to ensure that the fragment is added only once, when the activity is first created. When a configuration change occurs and the activity is recreated, savedInstanceState is no longer null, and the fragment does not need to be added a second time, as the fragment is automatically restored from the savedInstanceState.\n\nNote: You should always use setReorderingAllowed(true) when performing a FragmentTransaction. For more information on reordered transactions, see Fragment transactions.\n\n## beginTransaction\n\n```java\n@NonNull\n@Override\npublic FragmentTransaction beginTransaction() {\n    return new BackStackRecord(this);\n}\n```\n\n## setReorderingAllowed\n\n```java\n/**\n * Sets whether or not to allow optimizing operations within and across\n * transactions. This will remove redundant operations, eliminating\n * operations that cancel. For example, if two transactions are executed\n * together, one that adds a fragment A and the next replaces it with fragment B,\n * the operations will cancel and only fragment B will be added. That means that\n * fragment A may not go through the creation/destruction lifecycle.\n * <p>\n * The side effect of removing redundant operations is that fragments may have state changes\n * out of the expected order. For example, one transaction adds fragment A,\n * a second adds fragment B, then a third removes fragment A. Without removing the redundant\n * operations, fragment B could expect that while it is being created, fragment A will also\n * exist because fragment A will be removed after fragment B was added.\n * With removing redundant operations, fragment B cannot expect fragment A to exist when\n * it has been created because fragment A's add/remove will be optimized out.\n * <p>\n * It can also reorder the state changes of Fragments to allow for better Transitions.\n * Added Fragments may have {@link Fragment#onCreate(Bundle)} called before replaced\n * Fragments have {@link Fragment#onDestroy()} called.\n * <p>\n * {@link Fragment#postponeEnterTransition()} requires {@code setReorderingAllowed(true)}.\n * <p>\n * The default is {@code false}.\n *\n * @param reorderingAllowed {@code true} to enable optimizing out redundant operations\n *                          or {@code false} to disable optimizing out redundant\n *                          operations on this transaction.\n */\n@NonNull\npublic FragmentTransaction setReorderingAllowed(boolean reorderingAllowed) {\n    mReorderingAllowed = reorderingAllowed;\n    return this;\n}\n```\n\n## add\n\n```java\n/**\n * Calls {@link #add(int, Fragment, String)} with a 0 containerViewId.\n */\n@NonNull\npublic FragmentTransaction add(@NonNull Fragment fragment, @Nullable String tag)  {\n    doAddOp(0, fragment, tag, OP_ADD);\n    return this;\n}\n```\n\n```java\nvoid doAddOp(int containerViewId, Fragment fragment, @Nullable String tag, int opcmd) {\n    final Class<?> fragmentClass = fragment.getClass();\n    final int modifiers = fragmentClass.getModifiers();\n    if (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers)\n            || (fragmentClass.isMemberClass() && !Modifier.isStatic(modifiers))) {\n        throw new IllegalStateException(\"Fragment \" + fragmentClass.getCanonicalName()\n                + \" must be a public static class to be  properly recreated from\"\n                + \" instance state.\");\n    }\n\n    if (tag != null) {\n        if (fragment.mTag != null && !tag.equals(fragment.mTag)) {\n            throw new IllegalStateException(\"Can't change tag of fragment \"\n                    + fragment + \": was \" + fragment.mTag\n                    + \" now \" + tag);\n        }\n        fragment.mTag = tag;\n    }\n\n    if (containerViewId != 0) {\n        if (containerViewId == View.NO_ID) {\n            throw new IllegalArgumentException(\"Can't add fragment \"\n                    + fragment + \" with tag \" + tag + \" to container view with no id\");\n        }\n        if (fragment.mFragmentId != 0 && fragment.mFragmentId != containerViewId) {\n            throw new IllegalStateException(\"Can't change container ID of fragment \"\n                    + fragment + \": was \" + fragment.mFragmentId\n                    + \" now \" + containerViewId);\n        }\n        fragment.mContainerId = fragment.mFragmentId = containerViewId;\n    }\n\n    addOp(new Op(opcmd, fragment));\n}\n```\n\n```java\nvoid addOp(Op op) {\n    mOps.add(op);\n    op.mEnterAnim = mEnterAnim;\n    op.mExitAnim = mExitAnim;\n    op.mPopEnterAnim = mPopEnterAnim;\n    op.mPopExitAnim = mPopExitAnim;\n}\n```\n\n传入fragment实例，将对fragment的增删换，显示隐藏等操作封装成op，并加入op列表集合，作为一个操作事物。\n\n## addToBackStack\n\n```java\n/**\n * Add this transaction to the back stack.  This means that the transaction\n * will be remembered after it is committed, and will reverse its operation\n * when later popped off the stack.\n * <p>\n * {@link #setReorderingAllowed(boolean)} must be set to <code>true</code>\n * in the same transaction as addToBackStack() to allow the pop of that\n * transaction to be reordered.\n *\n * @param name An optional name for this back stack state, or null.\n */\n@NonNull\npublic FragmentTransaction addToBackStack(@Nullable String name) {\n    if (!mAllowAddToBackStack) {\n        throw new IllegalStateException(\n                \"This FragmentTransaction is not allowed to be added to the back stack.\");\n    }\n    mAddToBackStack = true;\n    mName = name;\n    return this;\n}\n```\n\naddToBackStack更新mAddToBackStack标记位，并保存backStack名字，作为未来回退到此backStack的标示。\n\n## commit\n\n```java\nandroidx.fragment.app.BackStackRecord#commitInternal\n\nint commitInternal(boolean allowStateLoss) {\n    if (mCommitted) throw new IllegalStateException(\"commit already called\");\n    mCommitted = true;\n    if (mAddToBackStack) {\n        mIndex = mManager.allocBackStackIndex(this);\n    } else {\n        mIndex = -1;\n    }\n    mManager.enqueueAction(this, allowStateLoss);\n    return mIndex;\n}\n```\n\n如果加入backStack，则分配一个在backStack的索引，然后将此事务加入提交队列，等待主线程调度提交。\n\n```java\nandroidx.fragment.app.FragmentManager#enqueueAction\n\n/**\n * Adds an action to the queue of pending actions.\n *\n * @param action the action to add\n * @param allowStateLoss whether to allow loss of state information\n * @throws IllegalStateException if the activity has been destroyed\n */\npublic void enqueueAction(OpGenerator action, boolean allowStateLoss) {\n    if (!allowStateLoss) {\n        checkStateLoss();\n    }\n    synchronized (this) {\n        if (mDestroyed || mHost == null) {\n            if (allowStateLoss) {\n                // This FragmentManager isn't attached, so drop the entire transaction.\n                return;\n            }\n            throw new IllegalStateException(\"Activity has been destroyed\");\n        }\n        if (mPendingActions == null) {\n            mPendingActions = new ArrayList<>();\n        }\n        mPendingActions.add(action);\n        scheduleCommit();\n    }\n}\n```\n\n## OpGenerator\n\nBackStackRecord实现OpGenerator接口，先看下方法实现内容：将本次事务加入事务集合。并且判断如果要支持回退栈，则加入回退栈集合。\n\n```java\nandroidx.fragment.app.BackStackRecord#generateOps\n\n/**\n * Implementation of {@link FragmentManagerImpl.OpGenerator}.\n * This operation is added to the list of pending actions during {@link #commit()}, and\n * will be executed on the UI thread to run this FragmentTransaction.\n *\n * @param records Modified to add this BackStackRecord\n * @param isRecordPop Modified to add a false (this isn't a pop)\n * @return true always because the records and isRecordPop will always be changed\n */\n@Override\npublic boolean generateOps(ArrayList<BackStackRecord> records, ArrayList<Boolean> isRecordPop) {\n    if (FragmentManagerImpl.DEBUG) {\n        Log.v(TAG, \"Run: \" + this);\n    }\n\n    records.add(this);\n    isRecordPop.add(false);\n    if (mAddToBackStack) {\n        mManager.addBackStackState(this);\n    }\n    return true;\n}\n```\n\n```java\nandroidx.fragment.app.FragmentManager#addBackStackState\n\nvoid addBackStackState(BackStackRecord state) {\n    if (mBackStack == null) {\n        mBackStack = new ArrayList<BackStackRecord>();\n    }\n    mBackStack.add(state);\n}\n```\n\n# scheduleCommit\n\n## ensureExecReady\n\n条件检查，并实例化mTmpRecords & mTmpIsPop。\n\n```java\nandroidx.fragment.app.FragmentManager#execPendingActions\n\n/**\n * Only call from main thread!\n */\npublic boolean execPendingActions() {\n    ensureExecReady(true);// 1. Init mTmpRecords & mTmpIsPop\n\n    boolean didSomething = false;\n    // 2. Copy BackStackRecord  in mPendingActions into mTmpRecords， so does mTmpIsPop \n    while (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) {\n        mExecutingActions = true;\n        try {\n\t\t\t\t\t\t// 3. \n            removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop);\n        } finally {\n            cleanupExec();\n        }\n        didSomething = true;\n    }\n\n    updateOnBackPressedCallbackEnabled();\n    doPendingDeferredStart();\n    burpActive();\n\n    return didSomething;\n}\n```\n\n## generateOpsForPendingActions\n\n将mPendingActions的BackStackRecord，即我们提交的事务集合，复制到records（即成员变量mTmpRecords，mTmpIsPop同理）\n\n```java\nandroidx.fragment.app.FragmentManager#generateOpsForPendingActions\n\n/**\n * Adds all records in the pending actions to records and whether they are add or pop\n * operations to isPop. After executing, the pending actions will be empty.\n *\n * @param records All pending actions will generate BackStackRecords added to this.\n *                This contains the transactions, in order, to execute.\n * @param isPop All pending actions will generate booleans to add to this. This contains\n *              an entry for each entry in records to indicate whether or not it is a\n *              pop action.\n */\nprivate boolean generateOpsForPendingActions(ArrayList<BackStackRecord> records,\n                                             ArrayList<Boolean> isPop) {\n    boolean didSomething = false;\n    synchronized (this) {\n        if (mPendingActions == null || mPendingActions.size() == 0) {\n            return false;\n        }\n\n        final int numActions = mPendingActions.size();\n        for (int i = 0; i < numActions; i++) {\n            didSomething |= mPendingActions.get(i).generateOps(records, isPop);\n        }\n        mPendingActions.clear();\n        mHost.getHandler().removeCallbacks(mExecCommit);\n    }\n    return didSomething;\n}\n```\n\n## removeRedundantOperationsAndExecute\n\n```java\nandroidx.fragment.app.FragmentManager#removeRedundantOperationsAndExecute\n\n/**\n * Remove redundant BackStackRecord operations and executes them. This method merges operations\n * of proximate records that allow reordering. See\n * {@link FragmentTransaction#setReorderingAllowed(boolean)}.\n * <p>\n * For example, a transaction that adds to the back stack and then another that pops that\n * back stack record will be optimized to remove the unnecessary operation.\n * <p>\n * Likewise, two transactions committed that are executed at the same time will be optimized\n * to remove the redundant operations as well as two pop operations executed together.\n *\n * @param records The records pending execution\n * @param isRecordPop The direction that these records are being run.\n */\nprivate void removeRedundantOperationsAndExecute(ArrayList<BackStackRecord> records,\n                                                 ArrayList<Boolean> isRecordPop) {\n    if (records == null || records.isEmpty()) {\n        return;\n    }\n\n    if (isRecordPop == null || records.size() != isRecordPop.size()) {\n        throw new IllegalStateException(\"Internal error with the back stack records\");\n    }\n\n    // Force start of any postponed transactions that interact with scheduled transactions:\n    executePostponedTransaction(records, isRecordPop);\n\n    final int numRecords = records.size();\n    int startIndex = 0;\n    for (int recordNum = 0; recordNum < numRecords; recordNum++) {\n        final boolean canReorder = records.get(recordNum).mReorderingAllowed;\n        if (!canReorder) {\n            // execute all previous transactions\n            if (startIndex != recordNum) {\n                executeOpsTogether(records, isRecordPop, startIndex, recordNum);\n            }\n            // execute all pop operations that don't allow reordering together or\n            // one add operation\n            int reorderingEnd = recordNum + 1;\n            if (isRecordPop.get(recordNum)) {\n                while (reorderingEnd < numRecords\n                        && isRecordPop.get(reorderingEnd)\n                        && !records.get(reorderingEnd).mReorderingAllowed) {\n                    reorderingEnd++;\n                }\n            }\n            executeOpsTogether(records, isRecordPop, recordNum, reorderingEnd);\n            startIndex = reorderingEnd;\n            recordNum = reorderingEnd - 1;\n        }\n    }\n\t\t// Reorder is true as example code. Pay attention here.\n    if (startIndex != numRecords) {\n\t\t\t\t// startIndex 为0， numRecords为批处理的事务个数。\n        executeOpsTogether(records, isRecordPop, startIndex, numRecords);\n    }\n}\n```\n\n## executeOpsTogether\n\n一般推荐允许重排序，看最后一行方法调用executeOpsTogether。从API描述看，它执行事务集合的子集，子集里事务要么是允许重排序，要么不允许。\n\n```java\nandroidx.fragment.app.FragmentManager#executeOpsTogether\n\n/**\n * Executes a subset of a list of BackStackRecords, all of which either allow reordering or\n * do not allow ordering.\n * @param records A list of BackStackRecords that are to be executed\n * @param isRecordPop The direction that these records are being run.\n * @param startIndex The index of the first record in <code>records</code> to be executed\n * @param endIndex One more than the final record index in <code>records</code> to executed.\n */\nprivate void executeOpsTogether(@NonNull ArrayList<BackStackRecord> records,\n        @NonNull ArrayList<Boolean> isRecordPop, int startIndex, int endIndex) {\n    final boolean allowReordering = records.get(startIndex).mReorderingAllowed;\n    boolean addToBackStack = false;\n    if (mTmpAddedFragments == null) {\n        mTmpAddedFragments = new ArrayList<>();\n    } else {\n        mTmpAddedFragments.clear();\n    }\n\t\t// 执行transaction.add(fragment)，事务完成后，fragment会加入mAdded集合内，\n\t\t// activity生命周期方法派发给FragmentManager，继而派发给mAdded集合内的Fragment\n\t\t// 此处复制已添加Fragment集合到临时变量，\n    mTmpAddedFragments.addAll(mFragmentStore.getFragments());\n    Fragment oldPrimaryNav = getPrimaryNavigationFragment();\n    for (int recordNum = startIndex; recordNum < endIndex; recordNum++) {\n        final BackStackRecord record = records.get(recordNum);\n        final boolean isPop = isRecordPop.get(recordNum);\n        if (!isPop) {\n\t\t\t\t\t\t// 这里将op替换为更原子的操作，如replace拆解为remove & add，并将ops内的fragment\n\t\t\t\t\t\t// 依照op的cmd命令，从mTmpAddedFragments add 或 remove op里的fragment，\n            oldPrimaryNav = record.expandOps(mTmpAddedFragments, oldPrimaryNav);\n        } else {\n            oldPrimaryNav = record.trackAddedFragmentsInPop(mTmpAddedFragments, oldPrimaryNav);\n        }\n        addToBackStack = addToBackStack || record.mAddToBackStack;\n    }\n    mTmpAddedFragments.clear();\n\n    if (!allowReordering && mCurState >= Fragment.CREATED) {\n        // 一般推荐重排序，此处代码省略\n    }\n    // 1. 遍历BackStackRecord集合，逐个执行事务：将Fragment发送给FragmentManager管理，并更新Fragment标记。\n    executeOps(records, isRecordPop, startIndex, endIndex);\n\n    if (USE_STATE_MANAGER) {\n        // The last operation determines the overall direction, this ensures that operations\n        // such as push, push, pop, push are correctly considered a push\n        boolean isPop = isRecordPop.get(endIndex - 1);\n        // Ensure that Fragments directly affected by operations\n        // are moved to their expected state in operation order\n        for (int index = startIndex; index < endIndex; index++) {\n            BackStackRecord record = records.get(index);\n            if (isPop) {\n                // Pop operations get applied in reverse order\n                for (int opIndex = record.mOps.size() - 1; opIndex >= 0; opIndex--) {\n                    FragmentTransaction.Op op = record.mOps.get(opIndex);\n                    Fragment fragment = op.mFragment;\n                    if (fragment != null) {\n                        FragmentStateManager fragmentStateManager =\n                                createOrGetFragmentStateManager(fragment);\n                        fragmentStateManager.moveToExpectedState();\n                    }\n                }\n            } else {\n                for (FragmentTransaction.Op op : record.mOps) {\n                    Fragment fragment = op.mFragment;\n                    if (fragment != null) {\n                        FragmentStateManager fragmentStateManager =\n                                createOrGetFragmentStateManager(fragment);\n\t\t\t\t\t\t\t\t\t\t\t\t// 2. 事务内的Fragment推送至默认状态\n                        fragmentStateManager.moveToExpectedState();\n                    }\n                }\n            }\n\n        }\n        // And only then do we move all other fragments to the current state\n\t\t\t\t// 3. 将Fragment全部推送到当前FragmentManager的状态。\n        moveToState(mCurState, true);\n        Set<SpecialEffectsController> changedControllers = collectChangedControllers(\n                records, startIndex, endIndex);\n        for (SpecialEffectsController controller : changedControllers) {\n            controller.updateOperationDirection(isPop);\n            controller.markPostponedState();\n            controller.executePendingOperations();\n        }\n    } else {\n        // USE_STATE_MANAGER 默认为true，此处代码省略\n    }\n\t\t// 调用每个事务的提交监听回掉\n    for (int recordNum = startIndex; recordNum < endIndex; recordNum++) {\n        final BackStackRecord record = records.get(recordNum);\n        final boolean isPop = isRecordPop.get(recordNum);\n        if (isPop && record.mIndex >= 0) {\n            record.mIndex = -1;\n        }\n        record.runOnCommitRunnables();\n    }\n\t\t// // 通知backStack变更的监听回掉\n    if (addToBackStack) {\n        reportBackStackChanged();\n    }\n}\n```\n\n### executeOps\n\n```java\nandroidx.fragment.app.FragmentManager#executeOps\n\n/**\n * Run the operations in the BackStackRecords, either to push or pop.\n *\n * @param records The list of records whose operations should be run.\n * @param isRecordPop The direction that these records are being run.\n * @param startIndex The index of the first entry in records to run.\n * @param endIndex One past the index of the final entry in records to run.\n */\nprivate static void executeOps(ArrayList<BackStackRecord> records,\n                               ArrayList<Boolean> isRecordPop, int startIndex, int endIndex) {\n    for (int i = startIndex; i < endIndex; i++) {\n        final BackStackRecord record = records.get(i);\n        final boolean isPop = isRecordPop.get(i);\n        if (isPop) {\n            record.bumpBackStackNesting(-1);\n            // Only execute the add operations at the end of\n            // all transactions.\n            boolean moveToState = i == (endIndex - 1);\n            record.executePopOps(moveToState);\n        } else {\n            record.bumpBackStackNesting(1);\n            record.executeOps();\n        }\n    }\n}\n```\n\n遍历事务Op集合，逐个执行事务里的Op\n\n```java\nandroidx.fragment.app.BackStackRecord#executeOps\n\n/**\n * Executes the operations contained within this transaction. The Fragment states will only\n * be modified if optimizations are not allowed.\n */\nvoid executeOps() {\n    final int numOps = mOps.size();\n    for (int opNum = 0; opNum < numOps; opNum++) {\n        final Op op = mOps.get(opNum);\n        final Fragment f = op.mFragment;\n        if (f != null) {\n            f.setPopDirection(false);\n            f.setAnimations(op.mEnterAnim, op.mExitAnim, op.mPopEnterAnim, op.mPopExitAnim);\n            f.setNextTransition(mTransition);\n            f.setSharedElementNames(mSharedElementSourceNames, mSharedElementTargetNames);\n        }\n        switch (op.mCmd) {\n            case OP_ADD:\n                mManager.setExitAnimationOrder(f, false);\n                mManager.addFragment(f);\n                break;\n            case OP_REMOVE:\n                mManager.removeFragment(f);\n                break;\n            case OP_HIDE:\n                mManager.hideFragment(f);\n                break;\n            case OP_SHOW:\n                mManager.setExitAnimationOrder(f, false);\n                mManager.showFragment(f);\n                break;\n            case OP_DETACH:\n                mManager.detachFragment(f);\n                break;\n            case OP_ATTACH:\n                mManager.setExitAnimationOrder(f, false);\n                mManager.attachFragment(f);\n                break;\n            case OP_SET_PRIMARY_NAV:\n                mManager.setPrimaryNavigationFragment(f);\n                break;\n            case OP_UNSET_PRIMARY_NAV:\n                mManager.setPrimaryNavigationFragment(null);\n                break;\n            case OP_SET_MAX_LIFECYCLE:\n                mManager.setMaxLifecycle(f, op.mCurrentMaxState);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown cmd: \" + op.mCmd);\n        }\n\t\t\t\t// 允许排序，以下代码不执行\n        if (!mReorderingAllowed && op.mCmd != OP_ADD && f != null) {\n            if (!FragmentManager.USE_STATE_MANAGER) {\n                mManager.moveFragmentToExpectedState(f);\n            }\n        }\n    }\n    if (!mReorderingAllowed && !FragmentManager.USE_STATE_MANAGER) {\n        // Added fragments are added at the end to comply with prior behavior.\n        mManager.moveToState(mManager.mCurState, true);\n    }\n}\n```\n\naddFragment & removeFragment 主要是操作mAdded fragment集合并更新fragment.mRemoving & fragment.mAdded 标记\n\n```java\nandroidx.fragment.app.FragmentManager#removeFragment\nvoid removeFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) {\n        Log.v(TAG, \"remove: \" + fragment + \" nesting=\" + fragment.mBackStackNesting);\n    }\n    final boolean inactive = !fragment.isInBackStack();\n    if (!fragment.mDetached || inactive) {\n        mFragmentStore.removeFragment(fragment);\n        if (isMenuAvailable(fragment)) {\n            mNeedMenuInvalidate = true;\n        }\n        fragment.mRemoving = true;\n        setVisibleRemovingFragment(fragment);\n    }\n}\n\nandroidx.fragment.app.FragmentManager#addFragment\nFragmentStateManager addFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"add: \" + fragment);\n    FragmentStateManager fragmentStateManager = createOrGetFragmentStateManager(fragment);\n    fragment.mFragmentManager = this;\n    mFragmentStore.makeActive(fragmentStateManager);\n    if (!fragment.mDetached) {\n        mFragmentStore.addFragment(fragment);\n        fragment.mRemoving = false;\n        if (fragment.mView == null) {\n            fragment.mHiddenChanged = false;\n        }\n        if (isMenuAvailable(fragment)) {\n            mNeedMenuInvalidate = true;\n        }\n    }\n    return fragmentStateManager;\n}\n```\n\nattachFragment 与addFragment的差异： \n\n1. 无makeActive(fragment)，这个差异导致两者的Fragment默认升级到started状态后，只有add fragment会继续与FragmentManager状态同步，接收FragmentManager生命周期方法的派发，attach fragment则到此戛然而止。也没有moveToState(fragment)操作（addFragment下，此方法不调用，传入moveToStateNow参数值为false）\n2. 只有之前detach操作过，attach才有效果。\n\n```java\nandroidx.fragment.app.FragmentManager#attachFragment\nvoid attachFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"attach: \" + fragment);\n    if (fragment.mDetached) {\n\t\t\t\t// 初始化时，mDetached为false，只有detachFragment才置为true。\n        fragment.mDetached = false;\n        if (!fragment.mAdded) {\n            mFragmentStore.addFragment(fragment);\n            if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"add from attach: \" + fragment);\n            if (isMenuAvailable(fragment)) {\n                mNeedMenuInvalidate = true;\n            }\n        }\n    }\n}\n\nandroidx.fragment.app.FragmentStore#addFragment\nvoid addFragment(@NonNull Fragment fragment) {\n    if (mAdded.contains(fragment)) {\n        throw new IllegalStateException(\"Fragment already added: \" + fragment);\n    }\n    synchronized (mAdded) {\n        mAdded.add(fragment);\n    }\n    fragment.mAdded = true;\n}\n```\n\nremove & detachFragment都将fragment从mAdded集合移除fragment，不同的是分别标记mRemoving & mDetached 为true。\n\n```java\nvoid removeFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) {\n        Log.v(TAG, \"remove: \" + fragment + \" nesting=\" + fragment.mBackStackNesting);\n    }\n    final boolean inactive = !fragment.isInBackStack();\n    if (!fragment.mDetached || inactive) {\n        mFragmentStore.removeFragment(fragment);\n        if (isMenuAvailable(fragment)) {\n            mNeedMenuInvalidate = true;\n        }\n        fragment.mRemoving = true;\n        setVisibleRemovingFragment(fragment);\n    }\n}\n\nvoid removeFragment(@NonNull Fragment fragment) {\n    synchronized (mAdded) {\n        mAdded.remove(fragment);\n    }\n    fragment.mAdded = false;\n}\n```\n\n```java\nvoid detachFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"detach: \" + fragment);\n    if (!fragment.mDetached) {\n        fragment.mDetached = true;\n        if (fragment.mAdded) {\n            // We are not already in back stack, so need to remove the fragment.\n            if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"remove from detach: \" + fragment);\n            mFragmentStore.removeFragment(fragment);\n            if (isMenuAvailable(fragment)) {\n                mNeedMenuInvalidate = true;\n            }\n            setVisibleRemovingFragment(fragment);\n        }\n    }\n}\n```\n\nshowFrament & hideFragment 主要更新mHidden标记\n\n```java\n/**\n * Marks a fragment as hidden to be later animated in with\n * {@link #completeShowHideFragment(Fragment)}.\n *\n * @param fragment The fragment to be shown.\n */\nvoid hideFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"hide: \" + fragment);\n    if (!fragment.mHidden) {\n        fragment.mHidden = true;\n        // Toggle hidden changed so that if a fragment goes through show/hide/show\n        // it doesn't go through the animation.\n        fragment.mHiddenChanged = !fragment.mHiddenChanged;\n        setVisibleRemovingFragment(fragment);\n    }\n}\n\n/**\n * Marks a fragment as shown to be later animated in with\n * {@link #completeShowHideFragment(Fragment)}.\n *\n * @param fragment The fragment to be shown.\n */\nvoid showFragment(@NonNull Fragment fragment) {\n    if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, \"show: \" + fragment);\n    if (fragment.mHidden) {\n        fragment.mHidden = false;\n        // Toggle hidden changed so that if a fragment goes through show/hide/show\n        // it doesn't go through the animation.\n        fragment.mHiddenChanged = !fragment.mHiddenChanged;\n    }\n}\n```\n\nFragment 主要标记\n\n```java\n// True if the fragment is in the list of added fragments.\nboolean mAdded;\n\n// If set this fragment is being removed from its activity.\nboolean mRemoving;\n\n// Set to true when the app has requested that this fragment be hidden\n// from the user.\nboolean mHidden;\n\n// Set to true when the app has requested that this fragment be deactivated.\nboolean mDetached;\n```\n\n### moveToExpectedState\n\n遍历事务集合，将事务内每个op 对应的Fragment推送到合适的状态，具体状态值在computeExpectedState计算。默认是当前FragmentManager的状态。但会根据Fragment标记重算。\n\n```java\n// Assume the Fragment can go as high as the FragmentManager's state\nint maxState = mFragmentManagerState;\n// Fragments that are not currently added will sit in the CREATED state.\n// detach & remove 操作的fragment，目标状态是CREATED\nif (!mFragment.mAdded) {\n    maxState = Math.min(maxState, Fragment.CREATED);\n}\n\nif (mFragment.mRemoving) {\n    if (mFragment.isInBackStack()) {\n        // Fragments on the back stack shouldn't go higher than CREATED\n        maxState = Math.min(maxState, Fragment.CREATED);\n    } else {\n        // While removing a fragment, we always move to INITIALIZING\n\t\t\t\t// remove 操作的Fragment，如果不在回退栈，目标状态是INITIALIZING\n        maxState = Math.min(maxState, Fragment.INITIALIZING);\n    }\n}\n```\n\n```java\nvoid moveToExpectedState() {\n        if (mMovingToState) {\n            if (FragmentManager.isLoggingEnabled(Log.VERBOSE)) {\n                Log.v(FragmentManager.TAG, \"Ignoring re-entrant call to \"\n                        + \"moveToExpectedState() for \" + getFragment());\n            }\n            return;\n        }\n        try {\n            mMovingToState = true;\n\n            int newState;\n            while ((newState = computeExpectedState()) != mFragment.mState) {\n                if (newState > mFragment.mState) {\n                    // Moving upward\n                    int nextStep = mFragment.mState + 1;\n                    switch (nextStep) {\n                        case Fragment.ATTACHED:\n                            attach();\n                            break;\n                        case Fragment.CREATED:\n                            create();\n                            break;\n                        case Fragment.VIEW_CREATED:\n                            ensureInflatedView();\n                            createView();\n                            break;\n                        case Fragment.AWAITING_EXIT_EFFECTS:\n                            activityCreated();\n                            break;\n                        case Fragment.ACTIVITY_CREATED:\n                            if (mFragment.mView != null && mFragment.mContainer != null) {\n                                SpecialEffectsController controller = SpecialEffectsController\n                                        .getOrCreateController(mFragment.mContainer,\n                                                mFragment.getParentFragmentManager());\n                                int visibility = mFragment.mView.getVisibility();\n                                SpecialEffectsController.Operation.State finalState =\n                                        SpecialEffectsController.Operation.State.from(visibility);\n                                controller.enqueueAdd(finalState, this);\n                            }\n                            mFragment.mState = Fragment.ACTIVITY_CREATED;\n                            break;\n                        case Fragment.STARTED:\n                            start();\n                            break;\n                        case Fragment.AWAITING_ENTER_EFFECTS:\n                            mFragment.mState = Fragment.AWAITING_ENTER_EFFECTS;\n                            break;\n                        case Fragment.RESUMED:\n                            resume();\n                            break;\n                    }\n                } else {\n                    // Moving downward\n                    int nextStep = mFragment.mState - 1;\n                    switch (nextStep) {\n                        case Fragment.AWAITING_ENTER_EFFECTS:\n                            pause();\n                            break;\n                        case Fragment.STARTED:\n                            mFragment.mState = Fragment.STARTED;\n                            break;\n                        case Fragment.ACTIVITY_CREATED:\n                            stop();\n                            break;\n                        case Fragment.AWAITING_EXIT_EFFECTS:\n                            if (FragmentManager.isLoggingEnabled(Log.DEBUG)) {\n                                Log.d(TAG, \"movefrom ACTIVITY_CREATED: \" + mFragment);\n                            }\n                            if (mFragment.mView != null) {\n                                // Need to save the current view state if not done already\n                                // by saveInstanceState()\n                                if (mFragment.mSavedViewState == null) {\n                                    saveViewState();\n                                }\n                            }\n                            if (mFragment.mView != null && mFragment.mContainer != null) {\n                                SpecialEffectsController controller = SpecialEffectsController\n                                        .getOrCreateController(mFragment.mContainer,\n                                                mFragment.getParentFragmentManager());\n                                controller.enqueueRemove(this);\n                            }\n                            mFragment.mState = Fragment.AWAITING_EXIT_EFFECTS;\n                            break;\n                        case Fragment.VIEW_CREATED:\n                            mFragment.mInLayout = false;\n                            mFragment.mState = Fragment.VIEW_CREATED;\n                            break;\n                        case Fragment.CREATED:\n                            destroyFragmentView();\n                            mFragment.mState = Fragment.CREATED;\n                            break;\n                        case Fragment.ATTACHED:\n                            destroy();\n                            break;\n                        case Fragment.INITIALIZING:\n                            detach();\n                            break;\n                    }\n                }\n            }\n            if (FragmentManager.USE_STATE_MANAGER && mFragment.mHiddenChanged) {\n                if (mFragment.mView != null && mFragment.mContainer != null) {\n                    // Get the controller and enqueue the show/hide\n                    SpecialEffectsController controller = SpecialEffectsController\n                            .getOrCreateController(mFragment.mContainer,\n                                    mFragment.getParentFragmentManager());\n                    if (mFragment.mHidden) {\n                        controller.enqueueHide(this);\n                    } else {\n                        controller.enqueueShow(this);\n                    }\n                }\n                if (mFragment.mFragmentManager != null) {\n                    mFragment.mFragmentManager.invalidateMenuForFragment(mFragment);\n                }\n                mFragment.mHiddenChanged = false;\n                mFragment.onHiddenChanged(mFragment.mHidden);\n            }\n        } finally {\n            mMovingToState = false;\n        }\n    }\n```\n\n```java\nandroidx.fragment.app.FragmentManager#moveToState(int, boolean)\n/**\n * Changes the state of the fragment manager to {@code newState}. If the fragment manager\n * changes state or {@code always} is {@code true}, any fragments within it have their\n * states updated as well.\n *\n * @param newState The new state for the fragment manager\n * @param always If {@code true}, all fragments update their state, even\n *               if {@code newState} matches the current fragment manager's state.\n */\nvoid moveToState(int newState, boolean always) {\n    if (mHost == null && newState != Fragment.INITIALIZING) {\n        throw new IllegalStateException(\"No activity\");\n    }\n\n    if (!always && newState == mCurState) {\n        return;\n    }\n\n    mCurState = newState;\n\n    if (USE_STATE_MANAGER) {\n        mFragmentStore.moveToExpectedState();\n    } else {\n        // Must add them in the proper order. mActive fragments may be out of order\n        for (Fragment f : mFragmentStore.getFragments()) {\n            moveFragmentToExpectedState(f);\n        }\n\n        // Now iterate through all active fragments. These will include those that are removed\n        // and detached.\n        for (FragmentStateManager fragmentStateManager :\n                mFragmentStore.getActiveFragmentStateManagers()) {\n            Fragment f = fragmentStateManager.getFragment();\n            if (!f.mIsNewlyAdded) {\n                moveFragmentToExpectedState(f);\n            }\n            boolean beingRemoved = f.mRemoving && !f.isInBackStack();\n            if (beingRemoved) {\n                mFragmentStore.makeInactive(fragmentStateManager);\n            }\n        }\n    }\n\n    startPendingDeferredFragments();\n\n    if (mNeedMenuInvalidate && mHost != null && mCurState == Fragment.RESUMED) {\n        mHost.onSupportInvalidateOptionsMenu();\n        mNeedMenuInvalidate = false;\n    }\n}\n```\n\n同步FragmentManager的状态到mActive集合里的Fragments，mAdded集合的不同步。\n\n```java\nandroidx.fragment.app.FragmentStore#moveToExpectedState\nvoid moveToExpectedState() {\n    // Must add them in the proper order. mActive fragments may be out of order\n    for (Fragment f : mAdded) {\n        FragmentStateManager fragmentStateManager = mActive.get(f.mWho);\n        if (fragmentStateManager != null) {\n            fragmentStateManager.moveToExpectedState();\n        }\n    }\n\n    // Now iterate through all active fragments. These will include those that are removed\n    // and detached.\n    for (FragmentStateManager fragmentStateManager : mActive.values()) {\n        if (fragmentStateManager != null) {\n            fragmentStateManager.moveToExpectedState();\n\n            Fragment f = fragmentStateManager.getFragment();\n            boolean beingRemoved = f.mRemoving && !f.isInBackStack();\n            if (beingRemoved) {\n                makeInactive(fragmentStateManager);\n            }\n        }\n    }\n}\n```\n\n将当前Fragment的状态沿着下方箭头方向升级（curState < newState），或降级(curState > newState)至newState，（想象状态值是一个等腰三角形，resumed在上方顶点，created & destroyed位于下方两端。从左顶点到上顶点是升级，上顶点到右顶点是降级）状态值如下，RESUMED状态值最大。当前newState参数值为STARTED。\n\n```java\nstatic final int INITIALIZING = 0;     // Not yet created.\nstatic final int CREATED = 1;          // Created.\nstatic final int ACTIVITY_CREATED = 2; // Fully created, not started.\nstatic final int STARTED = 3;          // Created and started, not resumed.\nstatic final int RESUMED = 4;          // Created started and resumed.\n```\n\n![https://developer.android.com/images/guide/fragments/fragment-view-lifecycle.png](https://developer.android.com/images/guide/fragments/fragment-view-lifecycle.png)\n\n由上可见，Fragment 添加后，首先推送升级到STARTED状态。\n","slug":"FragmentManager源码剖析1","published":1,"updated":"2021-10-18T13:30:59.937Z","_id":"ckuwoynln0000lff9acjaecfu","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>使用Fragment的Activity需要继承<code>FragmentActivity</code> 这里有派发生命周期方法给FragmentManager，再派发给旗下Fragment。</li>\n<li>加入Fragment时，需要判断<code>savedInstanceState == null</code> ，避免重复创建实例。</li>\n<li>add Fragment，初始时，其Fragment生命周期方法会被升级到onStart 状态，随后与FragmentManager的状态同步，如果宿主Activity是Resume状态，则同步至onResume状态。</li>\n<li>detach fragment，其生命周期方法会被降级到onDestroyView。</li>\n<li>remove fragment，其生命周期方法会被降级到onDestroyView 或者onDestroy。</li>\n<li>show or hide fragment，生命周期方法不会回调，只是切换fragment 根view的可见性。</li>\n</ol>\n<h1 id=\"Sample-codes\"><a href=\"#Sample-codes\" class=\"headerlink\" title=\"Sample codes\"></a>Sample codes</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExampleActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(R.layout.example_activity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (savedInstanceState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            getSupportFragmentManager().beginTransaction()</span><br><span class=\"line\">                .setReorderingAllowed(<span class=\"keyword\">true</span>)</span><br><span class=\"line\">                .add(R.id.fragment_container_view, ExampleFragment.class)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"comment\">// name can be null</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t.addToBackStack(<span class=\"string\">&quot;name&quot;</span>) </span><br><span class=\"line\">                .commit();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Note: the fragment transaction is only created when savedInstanceState is null. This is to ensure that the fragment is added only once, when the activity is first created. When a configuration change occurs and the activity is recreated, savedInstanceState is no longer null, and the fragment does not need to be added a second time, as the fragment is automatically restored from the savedInstanceState.</p>\n<p>Note: You should always use setReorderingAllowed(true) when performing a FragmentTransaction. For more information on reordered transactions, see Fragment transactions.</p>\n<h2 id=\"beginTransaction\"><a href=\"#beginTransaction\" class=\"headerlink\" title=\"beginTransaction\"></a>beginTransaction</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">beginTransaction</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BackStackRecord(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"setReorderingAllowed\"><a href=\"#setReorderingAllowed\" class=\"headerlink\" title=\"setReorderingAllowed\"></a>setReorderingAllowed</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Sets whether or not to allow optimizing operations within and across</span></span><br><span class=\"line\"><span class=\"comment\"> * transactions. This will remove redundant operations, eliminating</span></span><br><span class=\"line\"><span class=\"comment\"> * operations that cancel. For example, if two transactions are executed</span></span><br><span class=\"line\"><span class=\"comment\"> * together, one that adds a fragment A and the next replaces it with fragment B,</span></span><br><span class=\"line\"><span class=\"comment\"> * the operations will cancel and only fragment B will be added. That means that</span></span><br><span class=\"line\"><span class=\"comment\"> * fragment A may not go through the creation/destruction lifecycle.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * The side effect of removing redundant operations is that fragments may have state changes</span></span><br><span class=\"line\"><span class=\"comment\"> * out of the expected order. For example, one transaction adds fragment A,</span></span><br><span class=\"line\"><span class=\"comment\"> * a second adds fragment B, then a third removes fragment A. Without removing the redundant</span></span><br><span class=\"line\"><span class=\"comment\"> * operations, fragment B could expect that while it is being created, fragment A will also</span></span><br><span class=\"line\"><span class=\"comment\"> * exist because fragment A will be removed after fragment B was added.</span></span><br><span class=\"line\"><span class=\"comment\"> * With removing redundant operations, fragment B cannot expect fragment A to exist when</span></span><br><span class=\"line\"><span class=\"comment\"> * it has been created because fragment A&#x27;s add/remove will be optimized out.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * It can also reorder the state changes of Fragments to allow for better Transitions.</span></span><br><span class=\"line\"><span class=\"comment\"> * Added Fragments may have &#123;<span class=\"doctag\">@link</span> Fragment#onCreate(Bundle)&#125; called before replaced</span></span><br><span class=\"line\"><span class=\"comment\"> * Fragments have &#123;<span class=\"doctag\">@link</span> Fragment#onDestroy()&#125; called.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> Fragment#postponeEnterTransition()&#125; requires &#123;<span class=\"doctag\">@code</span> setReorderingAllowed(true)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * The default is &#123;<span class=\"doctag\">@code</span> false&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> reorderingAllowed &#123;<span class=\"doctag\">@code</span> true&#125; to enable optimizing out redundant operations</span></span><br><span class=\"line\"><span class=\"comment\"> *                          or &#123;<span class=\"doctag\">@code</span> false&#125; to disable optimizing out redundant</span></span><br><span class=\"line\"><span class=\"comment\"> *                          operations on this transaction.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">setReorderingAllowed</span><span class=\"params\">(<span class=\"keyword\">boolean</span> reorderingAllowed)</span> </span>&#123;</span><br><span class=\"line\">    mReorderingAllowed = reorderingAllowed;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Calls &#123;<span class=\"doctag\">@link</span> #add(int, Fragment, String)&#125; with a 0 containerViewId.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">add</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment, <span class=\"meta\">@Nullable</span> String tag)</span>  </span>&#123;</span><br><span class=\"line\">    doAddOp(<span class=\"number\">0</span>, fragment, tag, OP_ADD);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doAddOp</span><span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment, <span class=\"meta\">@Nullable</span> String tag, <span class=\"keyword\">int</span> opcmd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Class&lt;?&gt; fragmentClass = fragment.getClass();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> modifiers = fragmentClass.getModifiers();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers)</span><br><span class=\"line\">            || (fragmentClass.isMemberClass() &amp;&amp; !Modifier.isStatic(modifiers))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Fragment &quot;</span> + fragmentClass.getCanonicalName()</span><br><span class=\"line\">                + <span class=\"string\">&quot; must be a public static class to be  properly recreated from&quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot; instance state.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tag != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragment.mTag != <span class=\"keyword\">null</span> &amp;&amp; !tag.equals(fragment.mTag)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Can&#x27;t change tag of fragment &quot;</span></span><br><span class=\"line\">                    + fragment + <span class=\"string\">&quot;: was &quot;</span> + fragment.mTag</span><br><span class=\"line\">                    + <span class=\"string\">&quot; now &quot;</span> + tag);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fragment.mTag = tag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (containerViewId != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (containerViewId == View.NO_ID) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Can&#x27;t add fragment &quot;</span></span><br><span class=\"line\">                    + fragment + <span class=\"string\">&quot; with tag &quot;</span> + tag + <span class=\"string\">&quot; to container view with no id&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragment.mFragmentId != <span class=\"number\">0</span> &amp;&amp; fragment.mFragmentId != containerViewId) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Can&#x27;t change container ID of fragment &quot;</span></span><br><span class=\"line\">                    + fragment + <span class=\"string\">&quot;: was &quot;</span> + fragment.mFragmentId</span><br><span class=\"line\">                    + <span class=\"string\">&quot; now &quot;</span> + containerViewId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fragment.mContainerId = fragment.mFragmentId = containerViewId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    addOp(<span class=\"keyword\">new</span> Op(opcmd, fragment));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addOp</span><span class=\"params\">(Op op)</span> </span>&#123;</span><br><span class=\"line\">    mOps.add(op);</span><br><span class=\"line\">    op.mEnterAnim = mEnterAnim;</span><br><span class=\"line\">    op.mExitAnim = mExitAnim;</span><br><span class=\"line\">    op.mPopEnterAnim = mPopEnterAnim;</span><br><span class=\"line\">    op.mPopExitAnim = mPopExitAnim;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>传入fragment实例，将对fragment的增删换，显示隐藏等操作封装成op，并加入op列表集合，作为一个操作事物。</p>\n<h2 id=\"addToBackStack\"><a href=\"#addToBackStack\" class=\"headerlink\" title=\"addToBackStack\"></a>addToBackStack</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Add this transaction to the back stack.  This means that the transaction</span></span><br><span class=\"line\"><span class=\"comment\"> * will be remembered after it is committed, and will reverse its operation</span></span><br><span class=\"line\"><span class=\"comment\"> * when later popped off the stack.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #setReorderingAllowed(boolean)&#125; must be set to &lt;code&gt;true&lt;/code&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * in the same transaction as addToBackStack() to allow the pop of that</span></span><br><span class=\"line\"><span class=\"comment\"> * transaction to be reordered.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> name An optional name for this back stack state, or null.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">addToBackStack</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mAllowAddToBackStack) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                <span class=\"string\">&quot;This FragmentTransaction is not allowed to be added to the back stack.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mAddToBackStack = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    mName = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>addToBackStack更新mAddToBackStack标记位，并保存backStack名字，作为未来回退到此backStack的标示。</p>\n<h2 id=\"commit\"><a href=\"#commit\" class=\"headerlink\" title=\"commit\"></a>commit</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.BackStackRecord#<span class=\"function\">commitInternal</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">commitInternal</span><span class=\"params\">(<span class=\"keyword\">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mCommitted) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;commit already called&quot;</span>);</span><br><span class=\"line\">    mCommitted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAddToBackStack) &#123;</span><br><span class=\"line\">        mIndex = mManager.allocBackStackIndex(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mManager.enqueueAction(<span class=\"keyword\">this</span>, allowStateLoss);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mIndex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果加入backStack，则分配一个在backStack的索引，然后将此事务加入提交队列，等待主线程调度提交。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#enqueueAction</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Adds an action to the queue of pending actions.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> action the action to add</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> allowStateLoss whether to allow loss of state information</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> IllegalStateException if the activity has been destroyed</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueueAction</span><span class=\"params\">(OpGenerator action, <span class=\"keyword\">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!allowStateLoss) &#123;</span><br><span class=\"line\">        checkStateLoss();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDestroyed || mHost == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (allowStateLoss) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// This FragmentManager isn&#x27;t attached, so drop the entire transaction.</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Activity has been destroyed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mPendingActions == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mPendingActions = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mPendingActions.add(action);</span><br><span class=\"line\">        scheduleCommit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"OpGenerator\"><a href=\"#OpGenerator\" class=\"headerlink\" title=\"OpGenerator\"></a>OpGenerator</h2><p>BackStackRecord实现OpGenerator接口，先看下方法实现内容：将本次事务加入事务集合。并且判断如果要支持回退栈，则加入回退栈集合。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.BackStackRecord#generateOps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implementation of &#123;<span class=\"doctag\">@link</span> FragmentManagerImpl.OpGenerator&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * This operation is added to the list of pending actions during &#123;<span class=\"doctag\">@link</span> #commit()&#125;, and</span></span><br><span class=\"line\"><span class=\"comment\"> * will be executed on the UI thread to run this FragmentTransaction.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records Modified to add this BackStackRecord</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isRecordPop Modified to add a false (this isn&#x27;t a pop)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true always because the records and isRecordPop will always be changed</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">generateOps</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isRecordPop)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FragmentManagerImpl.DEBUG) &#123;</span><br><span class=\"line\">        Log.v(TAG, <span class=\"string\">&quot;Run: &quot;</span> + <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    records.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    isRecordPop.add(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAddToBackStack) &#123;</span><br><span class=\"line\">        mManager.addBackStackState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">addBackStackState</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBackStackState</span><span class=\"params\">(BackStackRecord state)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mBackStack == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mBackStack = <span class=\"keyword\">new</span> ArrayList&lt;BackStackRecord&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mBackStack.add(state);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"scheduleCommit\"><a href=\"#scheduleCommit\" class=\"headerlink\" title=\"scheduleCommit\"></a>scheduleCommit</h1><h2 id=\"ensureExecReady\"><a href=\"#ensureExecReady\" class=\"headerlink\" title=\"ensureExecReady\"></a>ensureExecReady</h2><p>条件检查，并实例化mTmpRecords &amp; mTmpIsPop。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#execPendingActions</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Only call from main thread!</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">execPendingActions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ensureExecReady(<span class=\"keyword\">true</span>);<span class=\"comment\">// 1. Init mTmpRecords &amp; mTmpIsPop</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> didSomething = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2. Copy BackStackRecord  in mPendingActions into mTmpRecords， so does mTmpIsPop </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) &#123;</span><br><span class=\"line\">        mExecutingActions = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 3. </span></span><br><span class=\"line\">            removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            cleanupExec();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        didSomething = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    updateOnBackPressedCallbackEnabled();</span><br><span class=\"line\">    doPendingDeferredStart();</span><br><span class=\"line\">    burpActive();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> didSomething;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"generateOpsForPendingActions\"><a href=\"#generateOpsForPendingActions\" class=\"headerlink\" title=\"generateOpsForPendingActions\"></a>generateOpsForPendingActions</h2><p>将mPendingActions的BackStackRecord，即我们提交的事务集合，复制到records（即成员变量mTmpRecords，mTmpIsPop同理）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#generateOpsForPendingActions</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Adds all records in the pending actions to records and whether they are add or pop</span></span><br><span class=\"line\"><span class=\"comment\"> * operations to isPop. After executing, the pending actions will be empty.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records All pending actions will generate BackStackRecords added to this.</span></span><br><span class=\"line\"><span class=\"comment\"> *                This contains the transactions, in order, to execute.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isPop All pending actions will generate booleans to add to this. This contains</span></span><br><span class=\"line\"><span class=\"comment\"> *              an entry for each entry in records to indicate whether or not it is a</span></span><br><span class=\"line\"><span class=\"comment\"> *              pop action.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">generateOpsForPendingActions</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                             ArrayList&lt;Boolean&gt; isPop)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> didSomething = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mPendingActions == <span class=\"keyword\">null</span> || mPendingActions.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> numActions = mPendingActions.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numActions; i++) &#123;</span><br><span class=\"line\">            didSomething |= mPendingActions.get(i).generateOps(records, isPop);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mPendingActions.clear();</span><br><span class=\"line\">        mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> didSomething;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"removeRedundantOperationsAndExecute\"><a href=\"#removeRedundantOperationsAndExecute\" class=\"headerlink\" title=\"removeRedundantOperationsAndExecute\"></a>removeRedundantOperationsAndExecute</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#removeRedundantOperationsAndExecute</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Remove redundant BackStackRecord operations and executes them. This method merges operations</span></span><br><span class=\"line\"><span class=\"comment\"> * of proximate records that allow reordering. See</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> FragmentTransaction#setReorderingAllowed(boolean)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * For example, a transaction that adds to the back stack and then another that pops that</span></span><br><span class=\"line\"><span class=\"comment\"> * back stack record will be optimized to remove the unnecessary operation.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Likewise, two transactions committed that are executed at the same time will be optimized</span></span><br><span class=\"line\"><span class=\"comment\"> * to remove the redundant operations as well as two pop operations executed together.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records The records pending execution</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isRecordPop The direction that these records are being run.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">removeRedundantOperationsAndExecute</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                                 ArrayList&lt;Boolean&gt; isRecordPop)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (records == <span class=\"keyword\">null</span> || records.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRecordPop == <span class=\"keyword\">null</span> || records.size() != isRecordPop.size()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Internal error with the back stack records&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Force start of any postponed transactions that interact with scheduled transactions:</span></span><br><span class=\"line\">    executePostponedTransaction(records, isRecordPop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> numRecords = records.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> startIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> recordNum = <span class=\"number\">0</span>; recordNum &lt; numRecords; recordNum++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> canReorder = records.get(recordNum).mReorderingAllowed;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!canReorder) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// execute all previous transactions</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (startIndex != recordNum) &#123;</span><br><span class=\"line\">                executeOpsTogether(records, isRecordPop, startIndex, recordNum);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// execute all pop operations that don&#x27;t allow reordering together or</span></span><br><span class=\"line\">            <span class=\"comment\">// one add operation</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> reorderingEnd = recordNum + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isRecordPop.get(recordNum)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (reorderingEnd &lt; numRecords</span><br><span class=\"line\">                        &amp;&amp; isRecordPop.get(reorderingEnd)</span><br><span class=\"line\">                        &amp;&amp; !records.get(reorderingEnd).mReorderingAllowed) &#123;</span><br><span class=\"line\">                    reorderingEnd++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            executeOpsTogether(records, isRecordPop, recordNum, reorderingEnd);</span><br><span class=\"line\">            startIndex = reorderingEnd;</span><br><span class=\"line\">            recordNum = reorderingEnd - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Reorder is true as example code. Pay attention here.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (startIndex != numRecords) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// startIndex 为0， numRecords为批处理的事务个数。</span></span><br><span class=\"line\">        executeOpsTogether(records, isRecordPop, startIndex, numRecords);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"executeOpsTogether\"><a href=\"#executeOpsTogether\" class=\"headerlink\" title=\"executeOpsTogether\"></a>executeOpsTogether</h2><p>一般推荐允许重排序，看最后一行方法调用executeOpsTogether。从API描述看，它执行事务集合的子集，子集里事务要么是允许重排序，要么不允许。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#executeOpsTogether</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Executes a subset of a list of BackStackRecords, all of which either allow reordering or</span></span><br><span class=\"line\"><span class=\"comment\"> * do not allow ordering.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records A list of BackStackRecords that are to be executed</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isRecordPop The direction that these records are being run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> startIndex The index of the first record in &lt;code&gt;records&lt;/code&gt; to be executed</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> endIndex One more than the final record index in &lt;code&gt;records&lt;/code&gt; to executed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeOpsTogether</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ArrayList&lt;BackStackRecord&gt; records,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"meta\">@NonNull</span> ArrayList&lt;Boolean&gt; isRecordPop, <span class=\"keyword\">int</span> startIndex, <span class=\"keyword\">int</span> endIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> allowReordering = records.get(startIndex).mReorderingAllowed;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> addToBackStack = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTmpAddedFragments == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mTmpAddedFragments = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mTmpAddedFragments.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 执行transaction.add(fragment)，事务完成后，fragment会加入mAdded集合内，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// activity生命周期方法派发给FragmentManager，继而派发给mAdded集合内的Fragment</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 此处复制已添加Fragment集合到临时变量，</span></span><br><span class=\"line\">    mTmpAddedFragments.addAll(mFragmentStore.getFragments());</span><br><span class=\"line\">    Fragment oldPrimaryNav = getPrimaryNavigationFragment();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> recordNum = startIndex; recordNum &lt; endIndex; recordNum++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BackStackRecord record = records.get(recordNum);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isPop = isRecordPop.get(recordNum);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isPop) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 这里将op替换为更原子的操作，如replace拆解为remove &amp; add，并将ops内的fragment</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 依照op的cmd命令，从mTmpAddedFragments add 或 remove op里的fragment，</span></span><br><span class=\"line\">            oldPrimaryNav = record.expandOps(mTmpAddedFragments, oldPrimaryNav);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            oldPrimaryNav = record.trackAddedFragmentsInPop(mTmpAddedFragments, oldPrimaryNav);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addToBackStack = addToBackStack || record.mAddToBackStack;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mTmpAddedFragments.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!allowReordering &amp;&amp; mCurState &gt;= Fragment.CREATED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 一般推荐重排序，此处代码省略</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 遍历BackStackRecord集合，逐个执行事务：将Fragment发送给FragmentManager管理，并更新Fragment标记。</span></span><br><span class=\"line\">    executeOps(records, isRecordPop, startIndex, endIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// The last operation determines the overall direction, this ensures that operations</span></span><br><span class=\"line\">        <span class=\"comment\">// such as push, push, pop, push are correctly considered a push</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isPop = isRecordPop.get(endIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Ensure that Fragments directly affected by operations</span></span><br><span class=\"line\">        <span class=\"comment\">// are moved to their expected state in operation order</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = startIndex; index &lt; endIndex; index++) &#123;</span><br><span class=\"line\">            BackStackRecord record = records.get(index);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isPop) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Pop operations get applied in reverse order</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> opIndex = record.mOps.size() - <span class=\"number\">1</span>; opIndex &gt;= <span class=\"number\">0</span>; opIndex--) &#123;</span><br><span class=\"line\">                    FragmentTransaction.Op op = record.mOps.get(opIndex);</span><br><span class=\"line\">                    Fragment fragment = op.mFragment;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fragment != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        FragmentStateManager fragmentStateManager =</span><br><span class=\"line\">                                createOrGetFragmentStateManager(fragment);</span><br><span class=\"line\">                        fragmentStateManager.moveToExpectedState();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (FragmentTransaction.Op op : record.mOps) &#123;</span><br><span class=\"line\">                    Fragment fragment = op.mFragment;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fragment != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        FragmentStateManager fragmentStateManager =</span><br><span class=\"line\">                                createOrGetFragmentStateManager(fragment);</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 2. 事务内的Fragment推送至默认状态</span></span><br><span class=\"line\">                        fragmentStateManager.moveToExpectedState();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// And only then do we move all other fragments to the current state</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 3. 将Fragment全部推送到当前FragmentManager的状态。</span></span><br><span class=\"line\">        moveToState(mCurState, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        Set&lt;SpecialEffectsController&gt; changedControllers = collectChangedControllers(</span><br><span class=\"line\">                records, startIndex, endIndex);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (SpecialEffectsController controller : changedControllers) &#123;</span><br><span class=\"line\">            controller.updateOperationDirection(isPop);</span><br><span class=\"line\">            controller.markPostponedState();</span><br><span class=\"line\">            controller.executePendingOperations();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// USE_STATE_MANAGER 默认为true，此处代码省略</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 调用每个事务的提交监听回掉</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> recordNum = startIndex; recordNum &lt; endIndex; recordNum++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BackStackRecord record = records.get(recordNum);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isPop = isRecordPop.get(recordNum);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isPop &amp;&amp; record.mIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            record.mIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        record.runOnCommitRunnables();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// // 通知backStack变更的监听回掉</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (addToBackStack) &#123;</span><br><span class=\"line\">        reportBackStackChanged();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"executeOps\"><a href=\"#executeOps\" class=\"headerlink\" title=\"executeOps\"></a>executeOps</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#executeOps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Run the operations in the BackStackRecords, either to push or pop.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records The list of records whose operations should be run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isRecordPop The direction that these records are being run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> startIndex The index of the first entry in records to run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> endIndex One past the index of the final entry in records to run.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">executeOps</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                               ArrayList&lt;Boolean&gt; isRecordPop, <span class=\"keyword\">int</span> startIndex, <span class=\"keyword\">int</span> endIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = startIndex; i &lt; endIndex; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BackStackRecord record = records.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isPop = isRecordPop.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isPop) &#123;</span><br><span class=\"line\">            record.bumpBackStackNesting(-<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// Only execute the add operations at the end of</span></span><br><span class=\"line\">            <span class=\"comment\">// all transactions.</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> moveToState = i == (endIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">            record.executePopOps(moveToState);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            record.bumpBackStackNesting(<span class=\"number\">1</span>);</span><br><span class=\"line\">            record.executeOps();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>遍历事务Op集合，逐个执行事务里的Op</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.BackStackRecord#executeOps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Executes the operations contained within this transaction. The Fragment states will only</span></span><br><span class=\"line\"><span class=\"comment\"> * be modified if optimizations are not allowed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">executeOps</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> numOps = mOps.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> opNum = <span class=\"number\">0</span>; opNum &lt; numOps; opNum++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Op op = mOps.get(opNum);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Fragment f = op.mFragment;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            f.setPopDirection(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            f.setAnimations(op.mEnterAnim, op.mExitAnim, op.mPopEnterAnim, op.mPopExitAnim);</span><br><span class=\"line\">            f.setNextTransition(mTransition);</span><br><span class=\"line\">            f.setSharedElementNames(mSharedElementSourceNames, mSharedElementTargetNames);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (op.mCmd) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_ADD:</span><br><span class=\"line\">                mManager.setExitAnimationOrder(f, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                mManager.addFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_REMOVE:</span><br><span class=\"line\">                mManager.removeFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_HIDE:</span><br><span class=\"line\">                mManager.hideFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_SHOW:</span><br><span class=\"line\">                mManager.setExitAnimationOrder(f, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                mManager.showFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_DETACH:</span><br><span class=\"line\">                mManager.detachFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_ATTACH:</span><br><span class=\"line\">                mManager.setExitAnimationOrder(f, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                mManager.attachFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_SET_PRIMARY_NAV:</span><br><span class=\"line\">                mManager.setPrimaryNavigationFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_UNSET_PRIMARY_NAV:</span><br><span class=\"line\">                mManager.setPrimaryNavigationFragment(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_SET_MAX_LIFECYCLE:</span><br><span class=\"line\">                mManager.setMaxLifecycle(f, op.mCurrentMaxState);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Unknown cmd: &quot;</span> + op.mCmd);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 允许排序，以下代码不执行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mReorderingAllowed &amp;&amp; op.mCmd != OP_ADD &amp;&amp; f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!FragmentManager.USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">                mManager.moveFragmentToExpectedState(f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mReorderingAllowed &amp;&amp; !FragmentManager.USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Added fragments are added at the end to comply with prior behavior.</span></span><br><span class=\"line\">        mManager.moveToState(mManager.mCurState, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>addFragment &amp; removeFragment 主要是操作mAdded fragment集合并更新fragment.mRemoving &amp; fragment.mAdded 标记</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">removeFragment</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) &#123;</span><br><span class=\"line\">        Log.v(TAG, <span class=\"string\">&quot;remove: &quot;</span> + fragment + <span class=\"string\">&quot; nesting=&quot;</span> + fragment.mBackStackNesting);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> inactive = !fragment.isInBackStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached || inactive) &#123;</span><br><span class=\"line\">        mFragmentStore.removeFragment(fragment);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">            mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fragment.mRemoving = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setVisibleRemovingFragment(fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">addFragment</span></span><br><span class=\"line\"><span class=\"function\">FragmentStateManager <span class=\"title\">addFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;add: &quot;</span> + fragment);</span><br><span class=\"line\">    FragmentStateManager fragmentStateManager = createOrGetFragmentStateManager(fragment);</span><br><span class=\"line\">    fragment.mFragmentManager = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    mFragmentStore.makeActive(fragmentStateManager);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached) &#123;</span><br><span class=\"line\">        mFragmentStore.addFragment(fragment);</span><br><span class=\"line\">        fragment.mRemoving = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragment.mView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragment.mHiddenChanged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">            mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fragmentStateManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>attachFragment 与addFragment的差异： </p>\n<ol>\n<li>无makeActive(fragment)，这个差异导致两者的Fragment默认升级到started状态后，只有add fragment会继续与FragmentManager状态同步，接收FragmentManager生命周期方法的派发，attach fragment则到此戛然而止。也没有moveToState(fragment)操作（addFragment下，此方法不调用，传入moveToStateNow参数值为false）</li>\n<li>只有之前detach操作过，attach才有效果。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">attachFragment</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attachFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;attach: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fragment.mDetached) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 初始化时，mDetached为false，只有detachFragment才置为true。</span></span><br><span class=\"line\">        fragment.mDetached = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!fragment.mAdded) &#123;</span><br><span class=\"line\">            mFragmentStore.addFragment(fragment);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;add from attach: &quot;</span> + fragment);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">                mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.fragment.app.FragmentStore#<span class=\"function\">addFragment</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAdded.contains(fragment)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Fragment already added: &quot;</span> + fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mAdded) &#123;</span><br><span class=\"line\">        mAdded.add(fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fragment.mAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>remove &amp; detachFragment都将fragment从mAdded集合移除fragment，不同的是分别标记mRemoving &amp; mDetached 为true。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) &#123;</span><br><span class=\"line\">        Log.v(TAG, <span class=\"string\">&quot;remove: &quot;</span> + fragment + <span class=\"string\">&quot; nesting=&quot;</span> + fragment.mBackStackNesting);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> inactive = !fragment.isInBackStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached || inactive) &#123;</span><br><span class=\"line\">        mFragmentStore.removeFragment(fragment);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">            mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fragment.mRemoving = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setVisibleRemovingFragment(fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mAdded) &#123;</span><br><span class=\"line\">        mAdded.remove(fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fragment.mAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;detach: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached) &#123;</span><br><span class=\"line\">        fragment.mDetached = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragment.mAdded) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We are not already in back stack, so need to remove the fragment.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;remove from detach: &quot;</span> + fragment);</span><br><span class=\"line\">            mFragmentStore.removeFragment(fragment);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">                mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            setVisibleRemovingFragment(fragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>showFrament &amp; hideFragment 主要更新mHidden标记</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Marks a fragment as hidden to be later animated in with</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #completeShowHideFragment(Fragment)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> fragment The fragment to be shown.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hideFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;hide: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mHidden) &#123;</span><br><span class=\"line\">        fragment.mHidden = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Toggle hidden changed so that if a fragment goes through show/hide/show</span></span><br><span class=\"line\">        <span class=\"comment\">// it doesn&#x27;t go through the animation.</span></span><br><span class=\"line\">        fragment.mHiddenChanged = !fragment.mHiddenChanged;</span><br><span class=\"line\">        setVisibleRemovingFragment(fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Marks a fragment as shown to be later animated in with</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #completeShowHideFragment(Fragment)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> fragment The fragment to be shown.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;show: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fragment.mHidden) &#123;</span><br><span class=\"line\">        fragment.mHidden = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Toggle hidden changed so that if a fragment goes through show/hide/show</span></span><br><span class=\"line\">        <span class=\"comment\">// it doesn&#x27;t go through the animation.</span></span><br><span class=\"line\">        fragment.mHiddenChanged = !fragment.mHiddenChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Fragment 主要标记</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// True if the fragment is in the list of added fragments.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> mAdded;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// If set this fragment is being removed from its activity.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> mRemoving;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set to true when the app has requested that this fragment be hidden</span></span><br><span class=\"line\"><span class=\"comment\">// from the user.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> mHidden;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set to true when the app has requested that this fragment be deactivated.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> mDetached;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"moveToExpectedState\"><a href=\"#moveToExpectedState\" class=\"headerlink\" title=\"moveToExpectedState\"></a>moveToExpectedState</h3><p>遍历事务集合，将事务内每个op 对应的Fragment推送到合适的状态，具体状态值在computeExpectedState计算。默认是当前FragmentManager的状态。但会根据Fragment标记重算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Assume the Fragment can go as high as the FragmentManager&#x27;s state</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> maxState = mFragmentManagerState;</span><br><span class=\"line\"><span class=\"comment\">// Fragments that are not currently added will sit in the CREATED state.</span></span><br><span class=\"line\"><span class=\"comment\">// detach &amp; remove 操作的fragment，目标状态是CREATED</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!mFragment.mAdded) &#123;</span><br><span class=\"line\">    maxState = Math.min(maxState, Fragment.CREATED);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (mFragment.mRemoving) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mFragment.isInBackStack()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Fragments on the back stack shouldn&#x27;t go higher than CREATED</span></span><br><span class=\"line\">        maxState = Math.min(maxState, Fragment.CREATED);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// While removing a fragment, we always move to INITIALIZING</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// remove 操作的Fragment，如果不在回退栈，目标状态是INITIALIZING</span></span><br><span class=\"line\">        maxState = Math.min(maxState, Fragment.INITIALIZING);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToExpectedState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mMovingToState) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (FragmentManager.isLoggingEnabled(Log.VERBOSE)) &#123;</span><br><span class=\"line\">                Log.v(FragmentManager.TAG, <span class=\"string\">&quot;Ignoring re-entrant call to &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;moveToExpectedState() for &quot;</span> + getFragment());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mMovingToState = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> newState;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((newState = computeExpectedState()) != mFragment.mState) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (newState &gt; mFragment.mState) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Moving upward</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> nextStep = mFragment.mState + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">switch</span> (nextStep) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.ATTACHED:</span><br><span class=\"line\">                            attach();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.CREATED:</span><br><span class=\"line\">                            create();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.VIEW_CREATED:</span><br><span class=\"line\">                            ensureInflatedView();</span><br><span class=\"line\">                            createView();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.AWAITING_EXIT_EFFECTS:</span><br><span class=\"line\">                            activityCreated();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (mFragment.mView != <span class=\"keyword\">null</span> &amp;&amp; mFragment.mContainer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                SpecialEffectsController controller = SpecialEffectsController</span><br><span class=\"line\">                                        .getOrCreateController(mFragment.mContainer,</span><br><span class=\"line\">                                                mFragment.getParentFragmentManager());</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> visibility = mFragment.mView.getVisibility();</span><br><span class=\"line\">                                SpecialEffectsController.Operation.State finalState =</span><br><span class=\"line\">                                        SpecialEffectsController.Operation.State.from(visibility);</span><br><span class=\"line\">                                controller.enqueueAdd(finalState, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            mFragment.mState = Fragment.ACTIVITY_CREATED;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.STARTED:</span><br><span class=\"line\">                            start();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.AWAITING_ENTER_EFFECTS:</span><br><span class=\"line\">                            mFragment.mState = Fragment.AWAITING_ENTER_EFFECTS;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.RESUMED:</span><br><span class=\"line\">                            resume();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Moving downward</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> nextStep = mFragment.mState - <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">switch</span> (nextStep) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.AWAITING_ENTER_EFFECTS:</span><br><span class=\"line\">                            pause();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.STARTED:</span><br><span class=\"line\">                            mFragment.mState = Fragment.STARTED;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class=\"line\">                            stop();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.AWAITING_EXIT_EFFECTS:</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class=\"line\">                                Log.d(TAG, <span class=\"string\">&quot;movefrom ACTIVITY_CREATED: &quot;</span> + mFragment);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (mFragment.mView != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                <span class=\"comment\">// Need to save the current view state if not done already</span></span><br><span class=\"line\">                                <span class=\"comment\">// by saveInstanceState()</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (mFragment.mSavedViewState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                    saveViewState();</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (mFragment.mView != <span class=\"keyword\">null</span> &amp;&amp; mFragment.mContainer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                SpecialEffectsController controller = SpecialEffectsController</span><br><span class=\"line\">                                        .getOrCreateController(mFragment.mContainer,</span><br><span class=\"line\">                                                mFragment.getParentFragmentManager());</span><br><span class=\"line\">                                controller.enqueueRemove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            mFragment.mState = Fragment.AWAITING_EXIT_EFFECTS;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.VIEW_CREATED:</span><br><span class=\"line\">                            mFragment.mInLayout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                            mFragment.mState = Fragment.VIEW_CREATED;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.CREATED:</span><br><span class=\"line\">                            destroyFragmentView();</span><br><span class=\"line\">                            mFragment.mState = Fragment.CREATED;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.ATTACHED:</span><br><span class=\"line\">                            destroy();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.INITIALIZING:</span><br><span class=\"line\">                            detach();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (FragmentManager.USE_STATE_MANAGER &amp;&amp; mFragment.mHiddenChanged) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mFragment.mView != <span class=\"keyword\">null</span> &amp;&amp; mFragment.mContainer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Get the controller and enqueue the show/hide</span></span><br><span class=\"line\">                    SpecialEffectsController controller = SpecialEffectsController</span><br><span class=\"line\">                            .getOrCreateController(mFragment.mContainer,</span><br><span class=\"line\">                                    mFragment.getParentFragmentManager());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mFragment.mHidden) &#123;</span><br><span class=\"line\">                        controller.enqueueHide(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        controller.enqueueShow(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mFragment.mFragmentManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mFragment.mFragmentManager.invalidateMenuForFragment(mFragment);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mFragment.mHiddenChanged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                mFragment.onHiddenChanged(mFragment.mHidden);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            mMovingToState = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#moveToState(<span class=\"keyword\">int</span>, <span class=\"keyword\">boolean</span>)</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Changes the state of the fragment manager to &#123;<span class=\"doctag\">@code</span> newState&#125;. If the fragment manager</span></span><br><span class=\"line\"><span class=\"comment\"> * changes state or &#123;<span class=\"doctag\">@code</span> always&#125; is &#123;<span class=\"doctag\">@code</span> true&#125;, any fragments within it have their</span></span><br><span class=\"line\"><span class=\"comment\"> * states updated as well.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> newState The new state for the fragment manager</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> always If &#123;<span class=\"doctag\">@code</span> true&#125;, all fragments update their state, even</span></span><br><span class=\"line\"><span class=\"comment\"> *               if &#123;<span class=\"doctag\">@code</span> newState&#125; matches the current fragment manager&#x27;s state.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(<span class=\"keyword\">int</span> newState, <span class=\"keyword\">boolean</span> always)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHost == <span class=\"keyword\">null</span> &amp;&amp; newState != Fragment.INITIALIZING) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;No activity&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!always &amp;&amp; newState == mCurState) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mCurState = newState;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">        mFragmentStore.moveToExpectedState();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Must add them in the proper order. mActive fragments may be out of order</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Fragment f : mFragmentStore.getFragments()) &#123;</span><br><span class=\"line\">            moveFragmentToExpectedState(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Now iterate through all active fragments. These will include those that are removed</span></span><br><span class=\"line\">        <span class=\"comment\">// and detached.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (FragmentStateManager fragmentStateManager :</span><br><span class=\"line\">                mFragmentStore.getActiveFragmentStateManagers()) &#123;</span><br><span class=\"line\">            Fragment f = fragmentStateManager.getFragment();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!f.mIsNewlyAdded) &#123;</span><br><span class=\"line\">                moveFragmentToExpectedState(f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (beingRemoved) &#123;</span><br><span class=\"line\">                mFragmentStore.makeInactive(fragmentStateManager);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    startPendingDeferredFragments();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mNeedMenuInvalidate &amp;&amp; mHost != <span class=\"keyword\">null</span> &amp;&amp; mCurState == Fragment.RESUMED) &#123;</span><br><span class=\"line\">        mHost.onSupportInvalidateOptionsMenu();</span><br><span class=\"line\">        mNeedMenuInvalidate = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同步FragmentManager的状态到mActive集合里的Fragments，mAdded集合的不同步。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentStore#<span class=\"function\">moveToExpectedState</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToExpectedState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Must add them in the proper order. mActive fragments may be out of order</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Fragment f : mAdded) &#123;</span><br><span class=\"line\">        FragmentStateManager fragmentStateManager = mActive.get(f.mWho);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragmentStateManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragmentStateManager.moveToExpectedState();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Now iterate through all active fragments. These will include those that are removed</span></span><br><span class=\"line\">    <span class=\"comment\">// and detached.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (FragmentStateManager fragmentStateManager : mActive.values()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragmentStateManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragmentStateManager.moveToExpectedState();</span><br><span class=\"line\"></span><br><span class=\"line\">            Fragment f = fragmentStateManager.getFragment();</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (beingRemoved) &#123;</span><br><span class=\"line\">                makeInactive(fragmentStateManager);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将当前Fragment的状态沿着下方箭头方向升级（curState &lt; newState），或降级(curState &gt; newState)至newState，（想象状态值是一个等腰三角形，resumed在上方顶点，created &amp; destroyed位于下方两端。从左顶点到上顶点是升级，上顶点到右顶点是降级）状态值如下，RESUMED状态值最大。当前newState参数值为STARTED。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIALIZING = <span class=\"number\">0</span>;     <span class=\"comment\">// Not yet created.</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CREATED = <span class=\"number\">1</span>;          <span class=\"comment\">// Created.</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ACTIVITY_CREATED = <span class=\"number\">2</span>; <span class=\"comment\">// Fully created, not started.</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STARTED = <span class=\"number\">3</span>;          <span class=\"comment\">// Created and started, not resumed.</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RESUMED = <span class=\"number\">4</span>;          <span class=\"comment\">// Created started and resumed.</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://developer.android.com/images/guide/fragments/fragment-view-lifecycle.png\" alt=\"https://developer.android.com/images/guide/fragments/fragment-view-lifecycle.png\"></p>\n<p>由上可见，Fragment 添加后，首先推送升级到STARTED状态。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>使用Fragment的Activity需要继承<code>FragmentActivity</code> 这里有派发生命周期方法给FragmentManager，再派发给旗下Fragment。</li>\n<li>加入Fragment时，需要判断<code>savedInstanceState == null</code> ，避免重复创建实例。</li>\n<li>add Fragment，初始时，其Fragment生命周期方法会被升级到onStart 状态，随后与FragmentManager的状态同步，如果宿主Activity是Resume状态，则同步至onResume状态。</li>\n<li>detach fragment，其生命周期方法会被降级到onDestroyView。</li>\n<li>remove fragment，其生命周期方法会被降级到onDestroyView 或者onDestroy。</li>\n<li>show or hide fragment，生命周期方法不会回调，只是切换fragment 根view的可见性。</li>\n</ol>\n<h1 id=\"Sample-codes\"><a href=\"#Sample-codes\" class=\"headerlink\" title=\"Sample codes\"></a>Sample codes</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExampleActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(R.layout.example_activity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (savedInstanceState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            getSupportFragmentManager().beginTransaction()</span><br><span class=\"line\">                .setReorderingAllowed(<span class=\"keyword\">true</span>)</span><br><span class=\"line\">                .add(R.id.fragment_container_view, ExampleFragment.class)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"comment\">// name can be null</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t.addToBackStack(<span class=\"string\">&quot;name&quot;</span>) </span><br><span class=\"line\">                .commit();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Note: the fragment transaction is only created when savedInstanceState is null. This is to ensure that the fragment is added only once, when the activity is first created. When a configuration change occurs and the activity is recreated, savedInstanceState is no longer null, and the fragment does not need to be added a second time, as the fragment is automatically restored from the savedInstanceState.</p>\n<p>Note: You should always use setReorderingAllowed(true) when performing a FragmentTransaction. For more information on reordered transactions, see Fragment transactions.</p>\n<h2 id=\"beginTransaction\"><a href=\"#beginTransaction\" class=\"headerlink\" title=\"beginTransaction\"></a>beginTransaction</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">beginTransaction</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BackStackRecord(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"setReorderingAllowed\"><a href=\"#setReorderingAllowed\" class=\"headerlink\" title=\"setReorderingAllowed\"></a>setReorderingAllowed</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Sets whether or not to allow optimizing operations within and across</span></span><br><span class=\"line\"><span class=\"comment\"> * transactions. This will remove redundant operations, eliminating</span></span><br><span class=\"line\"><span class=\"comment\"> * operations that cancel. For example, if two transactions are executed</span></span><br><span class=\"line\"><span class=\"comment\"> * together, one that adds a fragment A and the next replaces it with fragment B,</span></span><br><span class=\"line\"><span class=\"comment\"> * the operations will cancel and only fragment B will be added. That means that</span></span><br><span class=\"line\"><span class=\"comment\"> * fragment A may not go through the creation/destruction lifecycle.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * The side effect of removing redundant operations is that fragments may have state changes</span></span><br><span class=\"line\"><span class=\"comment\"> * out of the expected order. For example, one transaction adds fragment A,</span></span><br><span class=\"line\"><span class=\"comment\"> * a second adds fragment B, then a third removes fragment A. Without removing the redundant</span></span><br><span class=\"line\"><span class=\"comment\"> * operations, fragment B could expect that while it is being created, fragment A will also</span></span><br><span class=\"line\"><span class=\"comment\"> * exist because fragment A will be removed after fragment B was added.</span></span><br><span class=\"line\"><span class=\"comment\"> * With removing redundant operations, fragment B cannot expect fragment A to exist when</span></span><br><span class=\"line\"><span class=\"comment\"> * it has been created because fragment A&#x27;s add/remove will be optimized out.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * It can also reorder the state changes of Fragments to allow for better Transitions.</span></span><br><span class=\"line\"><span class=\"comment\"> * Added Fragments may have &#123;<span class=\"doctag\">@link</span> Fragment#onCreate(Bundle)&#125; called before replaced</span></span><br><span class=\"line\"><span class=\"comment\"> * Fragments have &#123;<span class=\"doctag\">@link</span> Fragment#onDestroy()&#125; called.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> Fragment#postponeEnterTransition()&#125; requires &#123;<span class=\"doctag\">@code</span> setReorderingAllowed(true)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * The default is &#123;<span class=\"doctag\">@code</span> false&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> reorderingAllowed &#123;<span class=\"doctag\">@code</span> true&#125; to enable optimizing out redundant operations</span></span><br><span class=\"line\"><span class=\"comment\"> *                          or &#123;<span class=\"doctag\">@code</span> false&#125; to disable optimizing out redundant</span></span><br><span class=\"line\"><span class=\"comment\"> *                          operations on this transaction.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">setReorderingAllowed</span><span class=\"params\">(<span class=\"keyword\">boolean</span> reorderingAllowed)</span> </span>&#123;</span><br><span class=\"line\">    mReorderingAllowed = reorderingAllowed;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Calls &#123;<span class=\"doctag\">@link</span> #add(int, Fragment, String)&#125; with a 0 containerViewId.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">add</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment, <span class=\"meta\">@Nullable</span> String tag)</span>  </span>&#123;</span><br><span class=\"line\">    doAddOp(<span class=\"number\">0</span>, fragment, tag, OP_ADD);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doAddOp</span><span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment, <span class=\"meta\">@Nullable</span> String tag, <span class=\"keyword\">int</span> opcmd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Class&lt;?&gt; fragmentClass = fragment.getClass();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> modifiers = fragmentClass.getModifiers();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers)</span><br><span class=\"line\">            || (fragmentClass.isMemberClass() &amp;&amp; !Modifier.isStatic(modifiers))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Fragment &quot;</span> + fragmentClass.getCanonicalName()</span><br><span class=\"line\">                + <span class=\"string\">&quot; must be a public static class to be  properly recreated from&quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot; instance state.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tag != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragment.mTag != <span class=\"keyword\">null</span> &amp;&amp; !tag.equals(fragment.mTag)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Can&#x27;t change tag of fragment &quot;</span></span><br><span class=\"line\">                    + fragment + <span class=\"string\">&quot;: was &quot;</span> + fragment.mTag</span><br><span class=\"line\">                    + <span class=\"string\">&quot; now &quot;</span> + tag);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fragment.mTag = tag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (containerViewId != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (containerViewId == View.NO_ID) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Can&#x27;t add fragment &quot;</span></span><br><span class=\"line\">                    + fragment + <span class=\"string\">&quot; with tag &quot;</span> + tag + <span class=\"string\">&quot; to container view with no id&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragment.mFragmentId != <span class=\"number\">0</span> &amp;&amp; fragment.mFragmentId != containerViewId) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Can&#x27;t change container ID of fragment &quot;</span></span><br><span class=\"line\">                    + fragment + <span class=\"string\">&quot;: was &quot;</span> + fragment.mFragmentId</span><br><span class=\"line\">                    + <span class=\"string\">&quot; now &quot;</span> + containerViewId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fragment.mContainerId = fragment.mFragmentId = containerViewId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    addOp(<span class=\"keyword\">new</span> Op(opcmd, fragment));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addOp</span><span class=\"params\">(Op op)</span> </span>&#123;</span><br><span class=\"line\">    mOps.add(op);</span><br><span class=\"line\">    op.mEnterAnim = mEnterAnim;</span><br><span class=\"line\">    op.mExitAnim = mExitAnim;</span><br><span class=\"line\">    op.mPopEnterAnim = mPopEnterAnim;</span><br><span class=\"line\">    op.mPopExitAnim = mPopExitAnim;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>传入fragment实例，将对fragment的增删换，显示隐藏等操作封装成op，并加入op列表集合，作为一个操作事物。</p>\n<h2 id=\"addToBackStack\"><a href=\"#addToBackStack\" class=\"headerlink\" title=\"addToBackStack\"></a>addToBackStack</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Add this transaction to the back stack.  This means that the transaction</span></span><br><span class=\"line\"><span class=\"comment\"> * will be remembered after it is committed, and will reverse its operation</span></span><br><span class=\"line\"><span class=\"comment\"> * when later popped off the stack.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #setReorderingAllowed(boolean)&#125; must be set to &lt;code&gt;true&lt;/code&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * in the same transaction as addToBackStack() to allow the pop of that</span></span><br><span class=\"line\"><span class=\"comment\"> * transaction to be reordered.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> name An optional name for this back stack state, or null.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">addToBackStack</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mAllowAddToBackStack) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                <span class=\"string\">&quot;This FragmentTransaction is not allowed to be added to the back stack.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mAddToBackStack = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    mName = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>addToBackStack更新mAddToBackStack标记位，并保存backStack名字，作为未来回退到此backStack的标示。</p>\n<h2 id=\"commit\"><a href=\"#commit\" class=\"headerlink\" title=\"commit\"></a>commit</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.BackStackRecord#<span class=\"function\">commitInternal</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">commitInternal</span><span class=\"params\">(<span class=\"keyword\">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mCommitted) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;commit already called&quot;</span>);</span><br><span class=\"line\">    mCommitted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAddToBackStack) &#123;</span><br><span class=\"line\">        mIndex = mManager.allocBackStackIndex(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mManager.enqueueAction(<span class=\"keyword\">this</span>, allowStateLoss);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mIndex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果加入backStack，则分配一个在backStack的索引，然后将此事务加入提交队列，等待主线程调度提交。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#enqueueAction</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Adds an action to the queue of pending actions.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> action the action to add</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> allowStateLoss whether to allow loss of state information</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> IllegalStateException if the activity has been destroyed</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueueAction</span><span class=\"params\">(OpGenerator action, <span class=\"keyword\">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!allowStateLoss) &#123;</span><br><span class=\"line\">        checkStateLoss();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDestroyed || mHost == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (allowStateLoss) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// This FragmentManager isn&#x27;t attached, so drop the entire transaction.</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Activity has been destroyed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mPendingActions == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mPendingActions = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mPendingActions.add(action);</span><br><span class=\"line\">        scheduleCommit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"OpGenerator\"><a href=\"#OpGenerator\" class=\"headerlink\" title=\"OpGenerator\"></a>OpGenerator</h2><p>BackStackRecord实现OpGenerator接口，先看下方法实现内容：将本次事务加入事务集合。并且判断如果要支持回退栈，则加入回退栈集合。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.BackStackRecord#generateOps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implementation of &#123;<span class=\"doctag\">@link</span> FragmentManagerImpl.OpGenerator&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * This operation is added to the list of pending actions during &#123;<span class=\"doctag\">@link</span> #commit()&#125;, and</span></span><br><span class=\"line\"><span class=\"comment\"> * will be executed on the UI thread to run this FragmentTransaction.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records Modified to add this BackStackRecord</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isRecordPop Modified to add a false (this isn&#x27;t a pop)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true always because the records and isRecordPop will always be changed</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">generateOps</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isRecordPop)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FragmentManagerImpl.DEBUG) &#123;</span><br><span class=\"line\">        Log.v(TAG, <span class=\"string\">&quot;Run: &quot;</span> + <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    records.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    isRecordPop.add(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAddToBackStack) &#123;</span><br><span class=\"line\">        mManager.addBackStackState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">addBackStackState</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBackStackState</span><span class=\"params\">(BackStackRecord state)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mBackStack == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mBackStack = <span class=\"keyword\">new</span> ArrayList&lt;BackStackRecord&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mBackStack.add(state);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"scheduleCommit\"><a href=\"#scheduleCommit\" class=\"headerlink\" title=\"scheduleCommit\"></a>scheduleCommit</h1><h2 id=\"ensureExecReady\"><a href=\"#ensureExecReady\" class=\"headerlink\" title=\"ensureExecReady\"></a>ensureExecReady</h2><p>条件检查，并实例化mTmpRecords &amp; mTmpIsPop。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#execPendingActions</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Only call from main thread!</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">execPendingActions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ensureExecReady(<span class=\"keyword\">true</span>);<span class=\"comment\">// 1. Init mTmpRecords &amp; mTmpIsPop</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> didSomething = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2. Copy BackStackRecord  in mPendingActions into mTmpRecords， so does mTmpIsPop </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) &#123;</span><br><span class=\"line\">        mExecutingActions = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 3. </span></span><br><span class=\"line\">            removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            cleanupExec();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        didSomething = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    updateOnBackPressedCallbackEnabled();</span><br><span class=\"line\">    doPendingDeferredStart();</span><br><span class=\"line\">    burpActive();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> didSomething;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"generateOpsForPendingActions\"><a href=\"#generateOpsForPendingActions\" class=\"headerlink\" title=\"generateOpsForPendingActions\"></a>generateOpsForPendingActions</h2><p>将mPendingActions的BackStackRecord，即我们提交的事务集合，复制到records（即成员变量mTmpRecords，mTmpIsPop同理）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#generateOpsForPendingActions</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Adds all records in the pending actions to records and whether they are add or pop</span></span><br><span class=\"line\"><span class=\"comment\"> * operations to isPop. After executing, the pending actions will be empty.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records All pending actions will generate BackStackRecords added to this.</span></span><br><span class=\"line\"><span class=\"comment\"> *                This contains the transactions, in order, to execute.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isPop All pending actions will generate booleans to add to this. This contains</span></span><br><span class=\"line\"><span class=\"comment\"> *              an entry for each entry in records to indicate whether or not it is a</span></span><br><span class=\"line\"><span class=\"comment\"> *              pop action.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">generateOpsForPendingActions</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                             ArrayList&lt;Boolean&gt; isPop)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> didSomething = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mPendingActions == <span class=\"keyword\">null</span> || mPendingActions.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> numActions = mPendingActions.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numActions; i++) &#123;</span><br><span class=\"line\">            didSomething |= mPendingActions.get(i).generateOps(records, isPop);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mPendingActions.clear();</span><br><span class=\"line\">        mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> didSomething;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"removeRedundantOperationsAndExecute\"><a href=\"#removeRedundantOperationsAndExecute\" class=\"headerlink\" title=\"removeRedundantOperationsAndExecute\"></a>removeRedundantOperationsAndExecute</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#removeRedundantOperationsAndExecute</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Remove redundant BackStackRecord operations and executes them. This method merges operations</span></span><br><span class=\"line\"><span class=\"comment\"> * of proximate records that allow reordering. See</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> FragmentTransaction#setReorderingAllowed(boolean)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * For example, a transaction that adds to the back stack and then another that pops that</span></span><br><span class=\"line\"><span class=\"comment\"> * back stack record will be optimized to remove the unnecessary operation.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Likewise, two transactions committed that are executed at the same time will be optimized</span></span><br><span class=\"line\"><span class=\"comment\"> * to remove the redundant operations as well as two pop operations executed together.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records The records pending execution</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isRecordPop The direction that these records are being run.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">removeRedundantOperationsAndExecute</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                                 ArrayList&lt;Boolean&gt; isRecordPop)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (records == <span class=\"keyword\">null</span> || records.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRecordPop == <span class=\"keyword\">null</span> || records.size() != isRecordPop.size()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Internal error with the back stack records&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Force start of any postponed transactions that interact with scheduled transactions:</span></span><br><span class=\"line\">    executePostponedTransaction(records, isRecordPop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> numRecords = records.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> startIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> recordNum = <span class=\"number\">0</span>; recordNum &lt; numRecords; recordNum++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> canReorder = records.get(recordNum).mReorderingAllowed;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!canReorder) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// execute all previous transactions</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (startIndex != recordNum) &#123;</span><br><span class=\"line\">                executeOpsTogether(records, isRecordPop, startIndex, recordNum);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// execute all pop operations that don&#x27;t allow reordering together or</span></span><br><span class=\"line\">            <span class=\"comment\">// one add operation</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> reorderingEnd = recordNum + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isRecordPop.get(recordNum)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (reorderingEnd &lt; numRecords</span><br><span class=\"line\">                        &amp;&amp; isRecordPop.get(reorderingEnd)</span><br><span class=\"line\">                        &amp;&amp; !records.get(reorderingEnd).mReorderingAllowed) &#123;</span><br><span class=\"line\">                    reorderingEnd++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            executeOpsTogether(records, isRecordPop, recordNum, reorderingEnd);</span><br><span class=\"line\">            startIndex = reorderingEnd;</span><br><span class=\"line\">            recordNum = reorderingEnd - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Reorder is true as example code. Pay attention here.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (startIndex != numRecords) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// startIndex 为0， numRecords为批处理的事务个数。</span></span><br><span class=\"line\">        executeOpsTogether(records, isRecordPop, startIndex, numRecords);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"executeOpsTogether\"><a href=\"#executeOpsTogether\" class=\"headerlink\" title=\"executeOpsTogether\"></a>executeOpsTogether</h2><p>一般推荐允许重排序，看最后一行方法调用executeOpsTogether。从API描述看，它执行事务集合的子集，子集里事务要么是允许重排序，要么不允许。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#executeOpsTogether</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Executes a subset of a list of BackStackRecords, all of which either allow reordering or</span></span><br><span class=\"line\"><span class=\"comment\"> * do not allow ordering.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records A list of BackStackRecords that are to be executed</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isRecordPop The direction that these records are being run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> startIndex The index of the first record in &lt;code&gt;records&lt;/code&gt; to be executed</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> endIndex One more than the final record index in &lt;code&gt;records&lt;/code&gt; to executed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeOpsTogether</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ArrayList&lt;BackStackRecord&gt; records,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"meta\">@NonNull</span> ArrayList&lt;Boolean&gt; isRecordPop, <span class=\"keyword\">int</span> startIndex, <span class=\"keyword\">int</span> endIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> allowReordering = records.get(startIndex).mReorderingAllowed;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> addToBackStack = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTmpAddedFragments == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mTmpAddedFragments = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mTmpAddedFragments.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 执行transaction.add(fragment)，事务完成后，fragment会加入mAdded集合内，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// activity生命周期方法派发给FragmentManager，继而派发给mAdded集合内的Fragment</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 此处复制已添加Fragment集合到临时变量，</span></span><br><span class=\"line\">    mTmpAddedFragments.addAll(mFragmentStore.getFragments());</span><br><span class=\"line\">    Fragment oldPrimaryNav = getPrimaryNavigationFragment();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> recordNum = startIndex; recordNum &lt; endIndex; recordNum++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BackStackRecord record = records.get(recordNum);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isPop = isRecordPop.get(recordNum);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isPop) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 这里将op替换为更原子的操作，如replace拆解为remove &amp; add，并将ops内的fragment</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 依照op的cmd命令，从mTmpAddedFragments add 或 remove op里的fragment，</span></span><br><span class=\"line\">            oldPrimaryNav = record.expandOps(mTmpAddedFragments, oldPrimaryNav);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            oldPrimaryNav = record.trackAddedFragmentsInPop(mTmpAddedFragments, oldPrimaryNav);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addToBackStack = addToBackStack || record.mAddToBackStack;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mTmpAddedFragments.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!allowReordering &amp;&amp; mCurState &gt;= Fragment.CREATED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 一般推荐重排序，此处代码省略</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 遍历BackStackRecord集合，逐个执行事务：将Fragment发送给FragmentManager管理，并更新Fragment标记。</span></span><br><span class=\"line\">    executeOps(records, isRecordPop, startIndex, endIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// The last operation determines the overall direction, this ensures that operations</span></span><br><span class=\"line\">        <span class=\"comment\">// such as push, push, pop, push are correctly considered a push</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isPop = isRecordPop.get(endIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Ensure that Fragments directly affected by operations</span></span><br><span class=\"line\">        <span class=\"comment\">// are moved to their expected state in operation order</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = startIndex; index &lt; endIndex; index++) &#123;</span><br><span class=\"line\">            BackStackRecord record = records.get(index);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isPop) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Pop operations get applied in reverse order</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> opIndex = record.mOps.size() - <span class=\"number\">1</span>; opIndex &gt;= <span class=\"number\">0</span>; opIndex--) &#123;</span><br><span class=\"line\">                    FragmentTransaction.Op op = record.mOps.get(opIndex);</span><br><span class=\"line\">                    Fragment fragment = op.mFragment;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fragment != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        FragmentStateManager fragmentStateManager =</span><br><span class=\"line\">                                createOrGetFragmentStateManager(fragment);</span><br><span class=\"line\">                        fragmentStateManager.moveToExpectedState();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (FragmentTransaction.Op op : record.mOps) &#123;</span><br><span class=\"line\">                    Fragment fragment = op.mFragment;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fragment != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        FragmentStateManager fragmentStateManager =</span><br><span class=\"line\">                                createOrGetFragmentStateManager(fragment);</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 2. 事务内的Fragment推送至默认状态</span></span><br><span class=\"line\">                        fragmentStateManager.moveToExpectedState();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// And only then do we move all other fragments to the current state</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 3. 将Fragment全部推送到当前FragmentManager的状态。</span></span><br><span class=\"line\">        moveToState(mCurState, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        Set&lt;SpecialEffectsController&gt; changedControllers = collectChangedControllers(</span><br><span class=\"line\">                records, startIndex, endIndex);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (SpecialEffectsController controller : changedControllers) &#123;</span><br><span class=\"line\">            controller.updateOperationDirection(isPop);</span><br><span class=\"line\">            controller.markPostponedState();</span><br><span class=\"line\">            controller.executePendingOperations();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// USE_STATE_MANAGER 默认为true，此处代码省略</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 调用每个事务的提交监听回掉</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> recordNum = startIndex; recordNum &lt; endIndex; recordNum++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BackStackRecord record = records.get(recordNum);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isPop = isRecordPop.get(recordNum);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isPop &amp;&amp; record.mIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            record.mIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        record.runOnCommitRunnables();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// // 通知backStack变更的监听回掉</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (addToBackStack) &#123;</span><br><span class=\"line\">        reportBackStackChanged();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"executeOps\"><a href=\"#executeOps\" class=\"headerlink\" title=\"executeOps\"></a>executeOps</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#executeOps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Run the operations in the BackStackRecords, either to push or pop.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records The list of records whose operations should be run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isRecordPop The direction that these records are being run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> startIndex The index of the first entry in records to run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> endIndex One past the index of the final entry in records to run.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">executeOps</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                               ArrayList&lt;Boolean&gt; isRecordPop, <span class=\"keyword\">int</span> startIndex, <span class=\"keyword\">int</span> endIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = startIndex; i &lt; endIndex; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BackStackRecord record = records.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isPop = isRecordPop.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isPop) &#123;</span><br><span class=\"line\">            record.bumpBackStackNesting(-<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// Only execute the add operations at the end of</span></span><br><span class=\"line\">            <span class=\"comment\">// all transactions.</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> moveToState = i == (endIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">            record.executePopOps(moveToState);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            record.bumpBackStackNesting(<span class=\"number\">1</span>);</span><br><span class=\"line\">            record.executeOps();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>遍历事务Op集合，逐个执行事务里的Op</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.BackStackRecord#executeOps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Executes the operations contained within this transaction. The Fragment states will only</span></span><br><span class=\"line\"><span class=\"comment\"> * be modified if optimizations are not allowed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">executeOps</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> numOps = mOps.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> opNum = <span class=\"number\">0</span>; opNum &lt; numOps; opNum++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Op op = mOps.get(opNum);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Fragment f = op.mFragment;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            f.setPopDirection(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            f.setAnimations(op.mEnterAnim, op.mExitAnim, op.mPopEnterAnim, op.mPopExitAnim);</span><br><span class=\"line\">            f.setNextTransition(mTransition);</span><br><span class=\"line\">            f.setSharedElementNames(mSharedElementSourceNames, mSharedElementTargetNames);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (op.mCmd) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_ADD:</span><br><span class=\"line\">                mManager.setExitAnimationOrder(f, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                mManager.addFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_REMOVE:</span><br><span class=\"line\">                mManager.removeFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_HIDE:</span><br><span class=\"line\">                mManager.hideFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_SHOW:</span><br><span class=\"line\">                mManager.setExitAnimationOrder(f, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                mManager.showFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_DETACH:</span><br><span class=\"line\">                mManager.detachFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_ATTACH:</span><br><span class=\"line\">                mManager.setExitAnimationOrder(f, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                mManager.attachFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_SET_PRIMARY_NAV:</span><br><span class=\"line\">                mManager.setPrimaryNavigationFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_UNSET_PRIMARY_NAV:</span><br><span class=\"line\">                mManager.setPrimaryNavigationFragment(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_SET_MAX_LIFECYCLE:</span><br><span class=\"line\">                mManager.setMaxLifecycle(f, op.mCurrentMaxState);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Unknown cmd: &quot;</span> + op.mCmd);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 允许排序，以下代码不执行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mReorderingAllowed &amp;&amp; op.mCmd != OP_ADD &amp;&amp; f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!FragmentManager.USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">                mManager.moveFragmentToExpectedState(f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mReorderingAllowed &amp;&amp; !FragmentManager.USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Added fragments are added at the end to comply with prior behavior.</span></span><br><span class=\"line\">        mManager.moveToState(mManager.mCurState, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>addFragment &amp; removeFragment 主要是操作mAdded fragment集合并更新fragment.mRemoving &amp; fragment.mAdded 标记</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">removeFragment</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) &#123;</span><br><span class=\"line\">        Log.v(TAG, <span class=\"string\">&quot;remove: &quot;</span> + fragment + <span class=\"string\">&quot; nesting=&quot;</span> + fragment.mBackStackNesting);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> inactive = !fragment.isInBackStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached || inactive) &#123;</span><br><span class=\"line\">        mFragmentStore.removeFragment(fragment);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">            mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fragment.mRemoving = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setVisibleRemovingFragment(fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">addFragment</span></span><br><span class=\"line\"><span class=\"function\">FragmentStateManager <span class=\"title\">addFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;add: &quot;</span> + fragment);</span><br><span class=\"line\">    FragmentStateManager fragmentStateManager = createOrGetFragmentStateManager(fragment);</span><br><span class=\"line\">    fragment.mFragmentManager = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    mFragmentStore.makeActive(fragmentStateManager);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached) &#123;</span><br><span class=\"line\">        mFragmentStore.addFragment(fragment);</span><br><span class=\"line\">        fragment.mRemoving = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragment.mView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragment.mHiddenChanged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">            mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fragmentStateManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>attachFragment 与addFragment的差异： </p>\n<ol>\n<li>无makeActive(fragment)，这个差异导致两者的Fragment默认升级到started状态后，只有add fragment会继续与FragmentManager状态同步，接收FragmentManager生命周期方法的派发，attach fragment则到此戛然而止。也没有moveToState(fragment)操作（addFragment下，此方法不调用，传入moveToStateNow参数值为false）</li>\n<li>只有之前detach操作过，attach才有效果。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">attachFragment</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attachFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;attach: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fragment.mDetached) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 初始化时，mDetached为false，只有detachFragment才置为true。</span></span><br><span class=\"line\">        fragment.mDetached = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!fragment.mAdded) &#123;</span><br><span class=\"line\">            mFragmentStore.addFragment(fragment);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;add from attach: &quot;</span> + fragment);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">                mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.fragment.app.FragmentStore#<span class=\"function\">addFragment</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAdded.contains(fragment)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Fragment already added: &quot;</span> + fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mAdded) &#123;</span><br><span class=\"line\">        mAdded.add(fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fragment.mAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>remove &amp; detachFragment都将fragment从mAdded集合移除fragment，不同的是分别标记mRemoving &amp; mDetached 为true。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) &#123;</span><br><span class=\"line\">        Log.v(TAG, <span class=\"string\">&quot;remove: &quot;</span> + fragment + <span class=\"string\">&quot; nesting=&quot;</span> + fragment.mBackStackNesting);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> inactive = !fragment.isInBackStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached || inactive) &#123;</span><br><span class=\"line\">        mFragmentStore.removeFragment(fragment);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">            mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fragment.mRemoving = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setVisibleRemovingFragment(fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mAdded) &#123;</span><br><span class=\"line\">        mAdded.remove(fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fragment.mAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;detach: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached) &#123;</span><br><span class=\"line\">        fragment.mDetached = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragment.mAdded) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We are not already in back stack, so need to remove the fragment.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;remove from detach: &quot;</span> + fragment);</span><br><span class=\"line\">            mFragmentStore.removeFragment(fragment);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">                mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            setVisibleRemovingFragment(fragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>showFrament &amp; hideFragment 主要更新mHidden标记</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Marks a fragment as hidden to be later animated in with</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #completeShowHideFragment(Fragment)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> fragment The fragment to be shown.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hideFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;hide: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mHidden) &#123;</span><br><span class=\"line\">        fragment.mHidden = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Toggle hidden changed so that if a fragment goes through show/hide/show</span></span><br><span class=\"line\">        <span class=\"comment\">// it doesn&#x27;t go through the animation.</span></span><br><span class=\"line\">        fragment.mHiddenChanged = !fragment.mHiddenChanged;</span><br><span class=\"line\">        setVisibleRemovingFragment(fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Marks a fragment as shown to be later animated in with</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #completeShowHideFragment(Fragment)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> fragment The fragment to be shown.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, <span class=\"string\">&quot;show: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fragment.mHidden) &#123;</span><br><span class=\"line\">        fragment.mHidden = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Toggle hidden changed so that if a fragment goes through show/hide/show</span></span><br><span class=\"line\">        <span class=\"comment\">// it doesn&#x27;t go through the animation.</span></span><br><span class=\"line\">        fragment.mHiddenChanged = !fragment.mHiddenChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Fragment 主要标记</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// True if the fragment is in the list of added fragments.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> mAdded;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// If set this fragment is being removed from its activity.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> mRemoving;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set to true when the app has requested that this fragment be hidden</span></span><br><span class=\"line\"><span class=\"comment\">// from the user.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> mHidden;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set to true when the app has requested that this fragment be deactivated.</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> mDetached;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"moveToExpectedState\"><a href=\"#moveToExpectedState\" class=\"headerlink\" title=\"moveToExpectedState\"></a>moveToExpectedState</h3><p>遍历事务集合，将事务内每个op 对应的Fragment推送到合适的状态，具体状态值在computeExpectedState计算。默认是当前FragmentManager的状态。但会根据Fragment标记重算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Assume the Fragment can go as high as the FragmentManager&#x27;s state</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> maxState = mFragmentManagerState;</span><br><span class=\"line\"><span class=\"comment\">// Fragments that are not currently added will sit in the CREATED state.</span></span><br><span class=\"line\"><span class=\"comment\">// detach &amp; remove 操作的fragment，目标状态是CREATED</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!mFragment.mAdded) &#123;</span><br><span class=\"line\">    maxState = Math.min(maxState, Fragment.CREATED);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (mFragment.mRemoving) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mFragment.isInBackStack()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Fragments on the back stack shouldn&#x27;t go higher than CREATED</span></span><br><span class=\"line\">        maxState = Math.min(maxState, Fragment.CREATED);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// While removing a fragment, we always move to INITIALIZING</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// remove 操作的Fragment，如果不在回退栈，目标状态是INITIALIZING</span></span><br><span class=\"line\">        maxState = Math.min(maxState, Fragment.INITIALIZING);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToExpectedState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mMovingToState) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (FragmentManager.isLoggingEnabled(Log.VERBOSE)) &#123;</span><br><span class=\"line\">                Log.v(FragmentManager.TAG, <span class=\"string\">&quot;Ignoring re-entrant call to &quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;moveToExpectedState() for &quot;</span> + getFragment());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mMovingToState = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> newState;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((newState = computeExpectedState()) != mFragment.mState) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (newState &gt; mFragment.mState) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Moving upward</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> nextStep = mFragment.mState + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">switch</span> (nextStep) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.ATTACHED:</span><br><span class=\"line\">                            attach();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.CREATED:</span><br><span class=\"line\">                            create();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.VIEW_CREATED:</span><br><span class=\"line\">                            ensureInflatedView();</span><br><span class=\"line\">                            createView();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.AWAITING_EXIT_EFFECTS:</span><br><span class=\"line\">                            activityCreated();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (mFragment.mView != <span class=\"keyword\">null</span> &amp;&amp; mFragment.mContainer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                SpecialEffectsController controller = SpecialEffectsController</span><br><span class=\"line\">                                        .getOrCreateController(mFragment.mContainer,</span><br><span class=\"line\">                                                mFragment.getParentFragmentManager());</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> visibility = mFragment.mView.getVisibility();</span><br><span class=\"line\">                                SpecialEffectsController.Operation.State finalState =</span><br><span class=\"line\">                                        SpecialEffectsController.Operation.State.from(visibility);</span><br><span class=\"line\">                                controller.enqueueAdd(finalState, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            mFragment.mState = Fragment.ACTIVITY_CREATED;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.STARTED:</span><br><span class=\"line\">                            start();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.AWAITING_ENTER_EFFECTS:</span><br><span class=\"line\">                            mFragment.mState = Fragment.AWAITING_ENTER_EFFECTS;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.RESUMED:</span><br><span class=\"line\">                            resume();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Moving downward</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> nextStep = mFragment.mState - <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">switch</span> (nextStep) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.AWAITING_ENTER_EFFECTS:</span><br><span class=\"line\">                            pause();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.STARTED:</span><br><span class=\"line\">                            mFragment.mState = Fragment.STARTED;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class=\"line\">                            stop();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.AWAITING_EXIT_EFFECTS:</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class=\"line\">                                Log.d(TAG, <span class=\"string\">&quot;movefrom ACTIVITY_CREATED: &quot;</span> + mFragment);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (mFragment.mView != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                <span class=\"comment\">// Need to save the current view state if not done already</span></span><br><span class=\"line\">                                <span class=\"comment\">// by saveInstanceState()</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (mFragment.mSavedViewState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                    saveViewState();</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (mFragment.mView != <span class=\"keyword\">null</span> &amp;&amp; mFragment.mContainer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                SpecialEffectsController controller = SpecialEffectsController</span><br><span class=\"line\">                                        .getOrCreateController(mFragment.mContainer,</span><br><span class=\"line\">                                                mFragment.getParentFragmentManager());</span><br><span class=\"line\">                                controller.enqueueRemove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            mFragment.mState = Fragment.AWAITING_EXIT_EFFECTS;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.VIEW_CREATED:</span><br><span class=\"line\">                            mFragment.mInLayout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                            mFragment.mState = Fragment.VIEW_CREATED;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.CREATED:</span><br><span class=\"line\">                            destroyFragmentView();</span><br><span class=\"line\">                            mFragment.mState = Fragment.CREATED;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.ATTACHED:</span><br><span class=\"line\">                            destroy();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">case</span> Fragment.INITIALIZING:</span><br><span class=\"line\">                            detach();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (FragmentManager.USE_STATE_MANAGER &amp;&amp; mFragment.mHiddenChanged) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mFragment.mView != <span class=\"keyword\">null</span> &amp;&amp; mFragment.mContainer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Get the controller and enqueue the show/hide</span></span><br><span class=\"line\">                    SpecialEffectsController controller = SpecialEffectsController</span><br><span class=\"line\">                            .getOrCreateController(mFragment.mContainer,</span><br><span class=\"line\">                                    mFragment.getParentFragmentManager());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mFragment.mHidden) &#123;</span><br><span class=\"line\">                        controller.enqueueHide(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        controller.enqueueShow(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mFragment.mFragmentManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mFragment.mFragmentManager.invalidateMenuForFragment(mFragment);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mFragment.mHiddenChanged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                mFragment.onHiddenChanged(mFragment.mHidden);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            mMovingToState = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#moveToState(<span class=\"keyword\">int</span>, <span class=\"keyword\">boolean</span>)</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Changes the state of the fragment manager to &#123;<span class=\"doctag\">@code</span> newState&#125;. If the fragment manager</span></span><br><span class=\"line\"><span class=\"comment\"> * changes state or &#123;<span class=\"doctag\">@code</span> always&#125; is &#123;<span class=\"doctag\">@code</span> true&#125;, any fragments within it have their</span></span><br><span class=\"line\"><span class=\"comment\"> * states updated as well.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> newState The new state for the fragment manager</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> always If &#123;<span class=\"doctag\">@code</span> true&#125;, all fragments update their state, even</span></span><br><span class=\"line\"><span class=\"comment\"> *               if &#123;<span class=\"doctag\">@code</span> newState&#125; matches the current fragment manager&#x27;s state.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(<span class=\"keyword\">int</span> newState, <span class=\"keyword\">boolean</span> always)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHost == <span class=\"keyword\">null</span> &amp;&amp; newState != Fragment.INITIALIZING) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;No activity&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!always &amp;&amp; newState == mCurState) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mCurState = newState;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">        mFragmentStore.moveToExpectedState();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Must add them in the proper order. mActive fragments may be out of order</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Fragment f : mFragmentStore.getFragments()) &#123;</span><br><span class=\"line\">            moveFragmentToExpectedState(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Now iterate through all active fragments. These will include those that are removed</span></span><br><span class=\"line\">        <span class=\"comment\">// and detached.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (FragmentStateManager fragmentStateManager :</span><br><span class=\"line\">                mFragmentStore.getActiveFragmentStateManagers()) &#123;</span><br><span class=\"line\">            Fragment f = fragmentStateManager.getFragment();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!f.mIsNewlyAdded) &#123;</span><br><span class=\"line\">                moveFragmentToExpectedState(f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (beingRemoved) &#123;</span><br><span class=\"line\">                mFragmentStore.makeInactive(fragmentStateManager);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    startPendingDeferredFragments();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mNeedMenuInvalidate &amp;&amp; mHost != <span class=\"keyword\">null</span> &amp;&amp; mCurState == Fragment.RESUMED) &#123;</span><br><span class=\"line\">        mHost.onSupportInvalidateOptionsMenu();</span><br><span class=\"line\">        mNeedMenuInvalidate = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同步FragmentManager的状态到mActive集合里的Fragments，mAdded集合的不同步。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentStore#<span class=\"function\">moveToExpectedState</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToExpectedState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Must add them in the proper order. mActive fragments may be out of order</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Fragment f : mAdded) &#123;</span><br><span class=\"line\">        FragmentStateManager fragmentStateManager = mActive.get(f.mWho);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragmentStateManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragmentStateManager.moveToExpectedState();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Now iterate through all active fragments. These will include those that are removed</span></span><br><span class=\"line\">    <span class=\"comment\">// and detached.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (FragmentStateManager fragmentStateManager : mActive.values()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragmentStateManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragmentStateManager.moveToExpectedState();</span><br><span class=\"line\"></span><br><span class=\"line\">            Fragment f = fragmentStateManager.getFragment();</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (beingRemoved) &#123;</span><br><span class=\"line\">                makeInactive(fragmentStateManager);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将当前Fragment的状态沿着下方箭头方向升级（curState &lt; newState），或降级(curState &gt; newState)至newState，（想象状态值是一个等腰三角形，resumed在上方顶点，created &amp; destroyed位于下方两端。从左顶点到上顶点是升级，上顶点到右顶点是降级）状态值如下，RESUMED状态值最大。当前newState参数值为STARTED。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIALIZING = <span class=\"number\">0</span>;     <span class=\"comment\">// Not yet created.</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CREATED = <span class=\"number\">1</span>;          <span class=\"comment\">// Created.</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ACTIVITY_CREATED = <span class=\"number\">2</span>; <span class=\"comment\">// Fully created, not started.</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STARTED = <span class=\"number\">3</span>;          <span class=\"comment\">// Created and started, not resumed.</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RESUMED = <span class=\"number\">4</span>;          <span class=\"comment\">// Created started and resumed.</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://developer.android.com/images/guide/fragments/fragment-view-lifecycle.png\" alt=\"https://developer.android.com/images/guide/fragments/fragment-view-lifecycle.png\"></p>\n<p>由上可见，Fragment 添加后，首先推送升级到STARTED状态。</p>\n"},{"title":"FragmentManager源码剖析二","date":"2021-10-18T13:27:09.000Z","_content":"\n\n\n# remove & detach Fragment差别\n\n```java\npublic void removeFragment(Fragment fragment) {\n    if (DEBUG) Log.v(TAG, \"remove: \" + fragment + \" nesting=\" + fragment.mBackStackNesting);\n    final boolean inactive = !fragment.isInBackStack();\n    if (!fragment.mDetached || inactive) {\n        synchronized (mAdded) {\n            mAdded.remove(fragment);\n        }\n        if (isMenuAvailable(fragment)) {\n            mNeedMenuInvalidate = true;\n        }\n        fragment.mAdded = false;\n        fragment.mRemoving = true;\n    }\n}\n```\n\n```java\npublic void detachFragment(Fragment fragment) {\n    if (DEBUG) Log.v(TAG, \"detach: \" + fragment);\n    if (!fragment.mDetached) {\n        fragment.mDetached = true;\n        if (fragment.mAdded) {\n            // We are not already in back stack, so need to remove the fragment.\n            if (DEBUG) Log.v(TAG, \"remove from detach: \" + fragment);\n            synchronized (mAdded) {\n                mAdded.remove(fragment);\n            }\n            if (isMenuAvailable(fragment)) {\n                mNeedMenuInvalidate = true;\n            }\n            fragment.mAdded = false;\n        }\n    }\n}\n```\n\n都是移出mAdded集合，并将mAdded置为false，区别在更新的标记不同mRemoving & mDetached。在FragmentManager同步状态调用时，有对remove & detach的状态同步。\n\n```java\n/**\n * Changes the state of the fragment manager to {@code newState}. If the fragment manager\n * changes state or {@code always} is {@code true}, any fragments within it have their\n * states updated as well.\n *\n * @param newState The new state for the fragment manager\n * @param always If {@code true}, all fragments update their state, even\n *               if {@code newState} matches the current fragment manager's state.\n */\nvoid moveToState(int newState, boolean always) {\n    if (mHost == null && newState != Fragment.INITIALIZING) {\n        throw new IllegalStateException(\"No activity\");\n    }\n\n    if (!always && newState == mCurState) {\n        return;\n    }\n\n    mCurState = newState;\n\n    if (mActive != null) {\n\n        // Must add them in the proper order. mActive fragments may be out of order\n\t\t\t\t// Fragment add & attach 后的状态同步\n        final int numAdded = mAdded.size();\n        for (int i = 0; i < numAdded; i++) {\n            Fragment f = mAdded.get(i);\n            moveFragmentToExpectedState(f);\n        }\n\n        // Now iterate through all active fragments. These will include those that are removed\n        // and detached.\n        final int numActive = mActive.size();\n        for (int i = 0; i < numActive; i++) {\n            Fragment f = mActive.valueAt(i);\n\t\t\t\t\t\t// Fragment 激活后执行remove 或者 detach，同步状态。\n            if (f != null && (f.mRemoving || f.mDetached) && !f.mIsNewlyAdded) {\n                moveFragmentToExpectedState(f);\n            }\n        }\n\n        startPendingDeferredFragments();\n\n        if (mNeedMenuInvalidate && mHost != null && mCurState == Fragment.RESUMED) {\n            mHost.onSupportInvalidateOptionsMenu();\n            mNeedMenuInvalidate = false;\n        }\n    }\n}\n```\n\n```java\n/**\n * Moves a fragment to its expected final state or the fragment manager's state, depending\n * on whether the fragment manager's state is raised properly.\n *\n * @param f The fragment to change.\n */\nvoid moveFragmentToExpectedState(Fragment f) {\n    if (f == null) {\n        return;\n    }\n    if (!mActive.containsKey(f.mWho)) {\n        if (DEBUG) {\n            Log.v(TAG, \"Ignoring moving \" + f + \" to state \" + mCurState\n                    + \"since it is not added to \" + this);\n        }\n        return;\n    }\n    int nextState = mCurState;\n    if (f.mRemoving) {\n        if (f.isInBackStack()) {\n            nextState = Math.min(nextState, Fragment.CREATED);\n        } else {\n            nextState = Math.min(nextState, Fragment.INITIALIZING);\n        }\n    }\n    moveToState(f, nextState, f.getNextTransition(), f.getNextTransitionStyle(), false);\n}\n```\n\n对于Remove如果nextState 是CREATED，Fragment只会`f.performDestroyView()`，但如果是INITIALIZING，分两种情况：\n\n1. 不在回退栈，执行`f.performDestroy()`;\n2. 在回退栈，执行`f.performDetach()`;并`makeInactive(f);`\n\n对于detach，nextState是CREATED，也即只执行`f.performDestroyView()`\n\n```java\n@SuppressWarnings(\"ReferenceEquality\")\nvoid moveToState(Fragment f, int newState, int transit, int transitionStyle,\n        boolean keepActive) {\n    // Fragments that are not currently added will sit in the onCreate() state.\n    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {\n        newState = Fragment.CREATED;\n    }\n}\n```\n\n# add & attach Fragment区别\n\n由于addFragment 有activate调用，fragment 已经在mActive映射里，允许状态同步，但attach没有activate 调用，于是状态不同步。\n\n```java\n/**\n * Moves a fragment to its expected final state or the fragment manager's state, depending\n * on whether the fragment manager's state is raised properly.\n *\n * @param f The fragment to change.\n */\nvoid moveFragmentToExpectedState(Fragment f) {\n    if (f == null) {\n        return;\n    }\n    if (!mActive.containsKey(f.mWho)) {\n        if (DEBUG) {\n            Log.v(TAG, \"Ignoring moving \" + f + \" to state \" + mCurState\n                    + \"since it is not added to \" + this);\n        }\n        return;\n    }\n    int nextState = mCurState;\n    if (f.mRemoving) {\n        if (f.isInBackStack()) {\n            nextState = Math.min(nextState, Fragment.CREATED);\n        } else {\n            nextState = Math.min(nextState, Fragment.INITIALIZING);\n        }\n    }\n    moveToState(f, nextState, f.getNextTransition(), f.getNextTransitionStyle(), false);\n}\n```\n\n```java\npublic void addFragment(Fragment fragment, boolean moveToStateNow) {\n    if (DEBUG) Log.v(TAG, \"add: \" + fragment);\n    **makeActive(fragment);// 这是主要区别**\n    if (!fragment.mDetached) {\n        if (mAdded.contains(fragment)) {\n            throw new IllegalStateException(\"Fragment already added: \" + fragment);\n        }\n        synchronized (mAdded) {\n            mAdded.add(fragment);\n        }\n        fragment.mAdded = true;\n        fragment.mRemoving = false;\n        if (fragment.mView == null) {\n            fragment.mHiddenChanged = false;\n        }\n        if (isMenuAvailable(fragment)) {\n            mNeedMenuInvalidate = true;\n        }\n        if (moveToStateNow) {\n            moveToState(fragment);\n        }\n    }\n}\n```\n\n```java\npublic void attachFragment(Fragment fragment) {\n    if (DEBUG) Log.v(TAG, \"attach: \" + fragment);\n    if (fragment.mDetached) {\n        fragment.mDetached = false;\n        if (!fragment.mAdded) {\n            if (mAdded.contains(fragment)) {\n                throw new IllegalStateException(\"Fragment already added: \" + fragment);\n            }\n            if (DEBUG) Log.v(TAG, \"add from attach: \" + fragment);\n            synchronized (mAdded) {\n                mAdded.add(fragment);\n            }\n            fragment.mAdded = true;\n            if (isMenuAvailable(fragment)) {\n                mNeedMenuInvalidate = true;\n            }\n        }\n    }\n}\n```\n\n# Show和hide Fragment区别\n\n首先，更新mHidden标记。\n\n```java\n/**\n * Marks a fragment as hidden to be later animated in with\n * {@link #completeShowHideFragment(Fragment)}.\n *\n * @param fragment The fragment to be shown.\n */\npublic void hideFragment(Fragment fragment) {\n    if (DEBUG) Log.v(TAG, \"hide: \" + fragment);\n    if (!fragment.mHidden) {\n        fragment.mHidden = true;\n        // Toggle hidden changed so that if a fragment goes through show/hide/show\n        // it doesn't go through the animation.\n        fragment.mHiddenChanged = !fragment.mHiddenChanged;\n    }\n}\n\n/**\n * Marks a fragment as shown to be later animated in with\n * {@link #completeShowHideFragment(Fragment)}.\n *\n * @param fragment The fragment to be shown.\n */\npublic void showFragment(Fragment fragment) {\n    if (DEBUG) Log.v(TAG, \"show: \" + fragment);\n    if (fragment.mHidden) {\n        fragment.mHidden = false;\n        // Toggle hidden changed so that if a fragment goes through show/hide/show\n        // it doesn't go through the animation.\n        fragment.mHiddenChanged = !fragment.mHiddenChanged;\n    }\n}\n```\n\n故事并没有就此结束，看下这个标记如何使用。\n\n首先，hidden后，Fragment下的View为Gone，不贡献视图。\n\n```java\nandroidx.fragment.app.FragmentStateManager#moveToExpectedState\nif (FragmentManager.USE_STATE_MANAGER && mFragment.mHiddenChanged) {\n    if (mFragment.mView != null && mFragment.mContainer != null) {\n        // Get the controller and enqueue the show/hide\n        SpecialEffectsController controller = SpecialEffectsController\n                .getOrCreateController(mFragment.mContainer,\n                        mFragment.getParentFragmentManager());\n        if (mFragment.mHidden) {\n            controller.enqueueHide(this);\n        } else {\n            controller.enqueueShow(this);\n        }\n    }\n    if (mFragment.mFragmentManager != null) {\n        mFragment.mFragmentManager.invalidateMenuForFragment(mFragment);\n    }\n    mFragment.mHiddenChanged = false;\n    mFragment.onHiddenChanged(mFragment.mHidden);\n}\n```\n\n其次，hidden后，Fragment不再贡献菜单项\n\n```java\nandroidx.fragment.app.FragmentManager#dispatchPrepareOptionsMenu\nboolean dispatchPrepareOptionsMenu(@NonNull Menu menu) {\n    if (mCurState < Fragment.CREATED) {\n        return false;\n    }\n    boolean show = false;\n    for (Fragment f : mFragmentStore.getFragments()) {\n        if (f != null) {\n            if (isParentMenuVisible(f) && f.performPrepareOptionsMenu(menu)) {\n                show = true;\n            }\n        }\n    }\n    return show;\n}\n\nandroidx.fragment.app.Fragment#performPrepareOptionsMenu\nboolean performPrepareOptionsMenu(@NonNull Menu menu) {\n    boolean show = false;\n    if (!mHidden) {\n        if (mHasMenu && mMenuVisible) {\n            show = true;\n            onPrepareOptionsMenu(menu);\n        }\n        show |= mChildFragmentManager.dispatchPrepareOptionsMenu(menu);\n    }\n    return show;\n}\n```\n\n显隐切换完成后，androidx.fragment.app.Fragment#onHiddenChanged会得到通知调用。\n\n```java\nandroidx.fragment.app.FragmentManager#completeShowHideFragment\nandroidx.fragment.app.FragmentStateManager#moveToExpectedState\n\n```\n\n# FragmentManager 派发生命周期方法\n\n```java\npublic class FragmentActivity extends ComponentActivity {\n    final FragmentController mFragments = FragmentController.createController(\n\t\t\t\t\tnew HostCallbacks());\n}\n```\n\nmFragments 负责Activity 生命周期方法，派发给FragmentManager，再遍历逐个派发给旗下的Fragment。\n\n```java\n/**\n * Perform initialization of all fragments.\n */\n@SuppressWarnings(\"deprecation\")\n@Override\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    mFragments.attachHost(null /*parent*/);\n\n    if (savedInstanceState != null) {\n        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);\n        mFragments.restoreSaveState(p);\n    }\n\n    super.onCreate(savedInstanceState);\n\n    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);\n    mFragments.dispatchCreate();\n}\n```\n\n```java\n/**\n * Moves all Fragments managed by the controller's FragmentManager\n * into the create state.\n * <p>Call when Fragments should be created.\n *\n * @see Fragment#onCreate(Bundle)\n */\npublic void dispatchCreate() {\n    mHost.mFragmentManager.dispatchCreate();\n}\n```\n\ndispatchCreate 终导致FragmentManagerImpl的当前状态`mCurState` 变更。\n\n```java\nandroidx.fragment.app.FragmentManager#dispatchCreate\nvoid dispatchCreate() {\n    mStateSaved = false;\n    mStopped = false;\n    mNonConfig.setIsStateSaved(false);\n    dispatchStateChange(Fragment.CREATED);\n}\n\nandroidx.fragment.app.FragmentManager#dispatchStateChange\nprivate void dispatchStateChange(int nextState) {\n    try {\n        mExecutingActions = true;\n        mFragmentStore.dispatchStateChange(nextState);\n        moveToState(nextState, false);\n        if (USE_STATE_MANAGER) {\n            Set<SpecialEffectsController> controllers = collectAllSpecialEffectsController();\n            for (SpecialEffectsController controller : controllers) {\n                controller.forceCompleteAllOperations();\n            }\n        }\n    } finally {\n        mExecutingActions = false;\n    }\n    execPendingActions(true);\n}\n\n// 同步生命周期状态给mActive内fragment集合\nvoid dispatchStateChange(int state) {\n    for (FragmentStateManager fragmentStateManager : mActive.values()) {\n        if (fragmentStateManager != null) {\n            fragmentStateManager.setFragmentManagerState(state);\n        }\n    }\n}\n```\n\n```java\nandroidx.fragment.app.FragmentManager#moveToState(int, boolean)\n/**\n * Changes the state of the fragment manager to {@code newState}. If the fragment manager\n * changes state or {@code always} is {@code true}, any fragments within it have their\n * states updated as well.\n *\n * @param newState The new state for the fragment manager\n * @param always If {@code true}, all fragments update their state, even\n *               if {@code newState} matches the current fragment manager's state.\n */\nvoid moveToState(int newState, boolean always) {\n    if (mHost == null && newState != Fragment.INITIALIZING) {\n        throw new IllegalStateException(\"No activity\");\n    }\n\n    if (!always && newState == mCurState) {\n        return;\n    }\n\n    mCurState = newState;\n\n    if (USE_STATE_MANAGER) {\n        mFragmentStore.moveToExpectedState();\n    } else {\n        // Must add them in the proper order. mActive fragments may be out of order\n        for (Fragment f : mFragmentStore.getFragments()) {\n            moveFragmentToExpectedState(f);\n        }\n\n        // Now iterate through all active fragments. These will include those that are removed\n        // and detached.\n        for (FragmentStateManager fragmentStateManager :\n                mFragmentStore.getActiveFragmentStateManagers()) {\n            Fragment f = fragmentStateManager.getFragment();\n            if (!f.mIsNewlyAdded) {\n                moveFragmentToExpectedState(f);\n            }\n            boolean beingRemoved = f.mRemoving && !f.isInBackStack();\n            if (beingRemoved) {\n                mFragmentStore.makeInactive(fragmentStateManager);\n            }\n        }\n    }\n\n    startPendingDeferredFragments();\n\n    if (mNeedMenuInvalidate && mHost != null && mCurState == Fragment.RESUMED) {\n        mHost.onSupportInvalidateOptionsMenu();\n        mNeedMenuInvalidate = false;\n    }\n}\n```\n\n```java\nandroidx.fragment.app.FragmentManager#moveFragmentToExpectedState\nvoid moveToExpectedState() {\n    // Must add them in the proper order. mActive fragments may be out of order\n    for (Fragment f : mAdded) {\n        FragmentStateManager fragmentStateManager = mActive.get(f.mWho);\n        if (fragmentStateManager != null) {\n            fragmentStateManager.moveToExpectedState();\n        }\n    }\n\n    // Now iterate through all active fragments. These will include those that are removed\n    // and detached.\n    for (FragmentStateManager fragmentStateManager : mActive.values()) {\n        if (fragmentStateManager != null) {\n            fragmentStateManager.moveToExpectedState();\n\n            Fragment f = fragmentStateManager.getFragment();\n            boolean beingRemoved = f.mRemoving && !f.isInBackStack();\n            if (beingRemoved) {\n                makeInactive(fragmentStateManager);\n            }\n        }\n    }\n}\n```\n\n注意只有在mActive集合的Fragment才可以`moveToExpectedState` ，attach阶段的Fragment 并未进入此集合，add之后才进入，此后Fragment接收生命周期方法派发。\n\n# BackStack\n\n```java\n/**\n * Implementation of {@link FragmentManagerImpl.OpGenerator}.\n * This operation is added to the list of pending actions during {@link #commit()}, and\n * will be executed on the UI thread to run this FragmentTransaction.\n *\n * @param records Modified to add this BackStackRecord\n * @param isRecordPop Modified to add a false (this isn't a pop)\n * @return true always because the records and isRecordPop will always be changed\n */\n@Override\npublic boolean generateOps(ArrayList<BackStackRecord> records, ArrayList<Boolean> isRecordPop) {\n    if (FragmentManagerImpl.DEBUG) {\n        Log.v(TAG, \"Run: \" + this);\n    }\n\n    records.add(this);\n    isRecordPop.add(false);\n    if (mAddToBackStack) {\n        mManager.addBackStackState(this);\n    }\n    return true;\n}\n```\n\n```java\nvoid addBackStackState(BackStackRecord state) {\n    if (mBackStack == null) {\n        mBackStack = new ArrayList<BackStackRecord>();\n    }\n    mBackStack.add(state);\n}\n```\n\n把当前backStackRecord 即事务加入mBackStack 集合。此处可以猜想：当接收back事件时，activity先派发back事件给FragmentManager，如果mBackStack存在元素，则将列表末尾的事务revert，并移出集合，指针向左偏移一位，并直接返回。如果FragmentManager不回应back event，那么由Activity继续回应。我们看下具体实现是否这样。\n\n```java\nandroidx.activity.ComponentActivity#onBackPressed\n/**\n * Called when the activity has detected the user's press of the back\n * key. The {@link #getOnBackPressedDispatcher() OnBackPressedDispatcher} will be given a\n * chance to handle the back button before the default behavior of\n * {@link android.app.Activity#onBackPressed()} is invoked.\n *\n * @see #getOnBackPressedDispatcher()\n */\n@Override\n@MainThread\npublic void onBackPressed() {\n    mOnBackPressedDispatcher.onBackPressed();\n}\n\nprivate final OnBackPressedDispatcher mOnBackPressedDispatcher =\n      new OnBackPressedDispatcher(new Runnable() {\n          @Override\n          public void run() {\n              ComponentActivity.super.onBackPressed();\n          }\n      });\n\nandroidx.activity.OnBackPressedDispatcher#onBackPressed\n/**\n * Trigger a call to the currently added {@link OnBackPressedCallback callbacks} in reverse\n * order in which they were added. Only if the most recently added callback is not\n * {@link OnBackPressedCallback#isEnabled() enabled}\n * will any previously added callback be called.\n * <p>\n * It is strongly recommended to call {@link #hasEnabledCallbacks()} prior to calling\n * this method to determine if there are any enabled callbacks that will be triggered\n * by this method as calling this method.\n */\n@MainThread\npublic void onBackPressed() {\n    Iterator<OnBackPressedCallback> iterator =\n            mOnBackPressedCallbacks.descendingIterator();\n    while (iterator.hasNext()) {\n        OnBackPressedCallback callback = iterator.next();\n        if (callback.isEnabled()) {\n\t\t\t\t\t\t// 如果回调回应back事件，则返回\n            callback.handleOnBackPressed();\n            return;\n        }\n    }\n\t\t// FragmentManager 没回应，则继续走这里\n    if (mFallbackOnBackPressed != null) {\n\t\t\t\t// 为OnBackPressedDispatcher初始化时，传入的回调方法，其实现是\n\t\t\t\t// 调用Activity的onBackPressed()\n        mFallbackOnBackPressed.run();\n    }\n}\n\n```\n\nFragmentManager如何注册callback\n\n→androidx.fragment.app.FragmentActivity#init\n\n→androidx.fragment.app.FragmentController#attachHost\n\n→androidx.fragment.app.FragmentManager#attachController\n\n```java\n@SuppressWarnings(\"deprecation\")\n@SuppressLint(\"SyntheticAccessor\")\nvoid attachController(@NonNull FragmentHostCallback<?> host,\n        @NonNull FragmentContainer container, @Nullable final Fragment parent) {\n    if (mHost != null) throw new IllegalStateException(\"Already attached\");\n    mHost = host;\n    mContainer = container;\n    mParent = parent;\n\n    // Add a FragmentOnAttachListener to the parent fragment / host to support\n    // backward compatibility with the deprecated onAttachFragment() APIs\n    if (mParent != null) {\n        addFragmentOnAttachListener(new FragmentOnAttachListener() {\n            @SuppressWarnings(\"deprecation\")\n            @Override\n            public void onAttachFragment(@NonNull FragmentManager fragmentManager,\n                    @NonNull Fragment fragment) {\n                parent.onAttachFragment(fragment);\n            }\n        });\n    } else if (host instanceof FragmentOnAttachListener) {\n        addFragmentOnAttachListener((FragmentOnAttachListener) host);\n    }\n\n    if (mParent != null) {\n        // Since the callback depends on us being the primary navigation fragment,\n        // update our callback now that we have a parent so that we have the correct\n        // state by default\n        updateOnBackPressedCallbackEnabled();\n    }\n    // Set up the OnBackPressedCallback\n    if (host instanceof OnBackPressedDispatcherOwner) {\n        OnBackPressedDispatcherOwner dispatcherOwner = ((OnBackPressedDispatcherOwner) host);\n        mOnBackPressedDispatcher = dispatcherOwner.getOnBackPressedDispatcher();\n        LifecycleOwner owner = parent != null ? parent : dispatcherOwner;\n        mOnBackPressedDispatcher.addCallback(owner, mOnBackPressedCallback);\n    }\n\t\t// 代码省略\n}\n```\n\n```java\nprivate final OnBackPressedCallback mOnBackPressedCallback =\n    new OnBackPressedCallback(false) {\n        @Override\n        public void handleOnBackPressed() {\n            FragmentManager.this.handleOnBackPressed();\n        }\n    };\n```\n\n```java\nandroidx.fragment.app.FragmentManager#handleOnBackPressed\n@SuppressWarnings(\"WeakerAccess\") /* synthetic access */\nvoid handleOnBackPressed() {\n    // First, execute any pending actions to make sure we're in an\n    // up to date view of the world just in case anyone is queuing\n    // up transactions that change the back stack then immediately\n    // calling onBackPressed()\n    execPendingActions(true);\n    if (mOnBackPressedCallback.isEnabled()) {\n        // We still have a back stack, so we can pop\n        popBackStackImmediate();\n    } else {\n        // Sigh. Due to FragmentManager's asynchronicity, we can\n        // get into cases where we *think* we can handle the back\n        // button but because of frame perfect dispatch, we fell\n        // on our face. Since our callback is disabled, we can\n        // re-trigger the onBackPressed() to dispatch to the next\n        // enabled callback\n        mOnBackPressedDispatcher.onBackPressed();\n    }\n}\n```\n\n看fragmentManager.popBackStackImmediate()\n\n```java\n@Override\npublic boolean popBackStackImmediate() {\n    checkStateLoss();\n    return popBackStackImmediate(null, -1, 0);\n}\n```\n\n```java\n/**\n * Used by all public popBackStackImmediate methods, this executes pending transactions and\n * returns true if the pop action did anything, regardless of what other pending\n * transactions did.\n *\n * @return true if the pop operation did anything or false otherwise.\n */\nprivate boolean popBackStackImmediate(String name, int id, int flags) {\n    execPendingActions();\n    ensureExecReady(true);\n\n    if (mPrimaryNav != null // We have a primary nav fragment\n            && id < 0 // No valid id (since they're local)\n            && name == null) { // no name to pop to (since they're local)\n        final FragmentManager childManager = mPrimaryNav.getChildFragmentManager();\n        if (childManager.popBackStackImmediate()) {\n            // We did something, just not to this specific FragmentManager. Return true.\n            return true;\n        }\n    }\n\n    boolean executePop = popBackStackState(mTmpRecords, mTmpIsPop, name, id, flags);\n    if (executePop) {\n        mExecutingActions = true;\n        try {\n            removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop);\n        } finally {\n            cleanupExec();\n        }\n    }\n\n    updateOnBackPressedCallbackEnabled();\n    doPendingDeferredStart();\n    burpActive();\n    return executePop;\n}\n```\n\npopBackStackState获取回退事务集合，交由removeRedundantOperationsAndExecute执行事务回退。\n\n```java\nboolean popBackStackState(ArrayList<BackStackRecord> records, ArrayList<Boolean> isRecordPop,\n                              String name, int id, int flags) {\n    if (mBackStack == null) {\n        return false;\n    }\n\t\t// 无参数回退，只回退一个事务\n    if (name == null && id < 0 && (flags & POP_BACK_STACK_INCLUSIVE) == 0) {\n        int last = mBackStack.size() - 1;\n        if (last < 0) {\n            return false;\n        }\n        records.add(mBackStack.remove(last));\n        isRecordPop.add(true);\n    } else {\n\t\t\t\t// 指定id或者backStack name回退，可以一次回退多个事务。\n        int index = -1;\n        if (name != null || id >= 0) {\n            // If a name or ID is specified, look for that place in\n            // the stack.\n            index = mBackStack.size()-1;\n            while (index >= 0) {\n                BackStackRecord bss = mBackStack.get(index);\n                if (name != null && name.equals(bss.getName())) {\n                    break;\n                }\n                if (id >= 0 && id == bss.mIndex) {\n                    break;\n                }\n                index--;\n            }\n            if (index < 0) {\n                return false;\n            }\n            if ((flags&POP_BACK_STACK_INCLUSIVE) != 0) {\n                index--;\n                // Consume all following entries that match.\n                while (index >= 0) {\n                    BackStackRecord bss = mBackStack.get(index);\n                    if ((name != null && name.equals(bss.getName()))\n                            || (id >= 0 && id == bss.mIndex)) {\n                        index--;\n                        continue;\n                    }\n                    break;\n                }\n            }\n        }\n        if (index == mBackStack.size()-1) {\n            return false;\n        }\n        for (int i = mBackStack.size() - 1; i > index; i--) {\n            records.add(mBackStack.remove(i));\n            isRecordPop.add(true);\n        }\n    }\n    return true;\n}\n```\n\n事务从mBackStack回退栈管理集合移出，并加入records用于执行事务，对应的isRecordPop元素设置为true，标记位回退事务，最后执行逆向操作，实现回退。\n\n→androidx.fragment.app.FragmentManagerImpl#removeRedundantOperationsAndExecute\n\n→androidx.fragment.app.FragmentManagerImpl#executeOpsTogether\n\n→androidx.fragment.app.FragmentManager#executeOps\n\n→androidx.fragment.app.BackStackRecord#executePopOps\n\n```java\nandroidx.fragment.app.FragmentManager#executeOps\n/**\n * Run the operations in the BackStackRecords, either to push or pop.\n *\n * @param records The list of records whose operations should be run.\n * @param isRecordPop The direction that these records are being run.\n * @param startIndex The index of the first entry in records to run.\n * @param endIndex One past the index of the final entry in records to run.\n */\nprivate static void executeOps(@NonNull ArrayList<BackStackRecord> records,\n        @NonNull ArrayList<Boolean> isRecordPop, int startIndex, int endIndex) {\n    for (int i = startIndex; i < endIndex; i++) {\n        final BackStackRecord record = records.get(i);\n        final boolean isPop = isRecordPop.get(i);\n        if (isPop) {\n            record.bumpBackStackNesting(-1);\n            // Only execute the add operations at the end of\n            // all transactions.\n            boolean moveToState = i == (endIndex - 1);\n            record.executePopOps(moveToState);\n        } else {\n            record.bumpBackStackNesting(1);\n            record.executeOps();\n        }\n    }\n}\n\nandroidx.fragment.app.BackStackRecord#executePopOps\n/**\n * Reverses the execution of the operations within this transaction. The Fragment states will\n * only be modified if reordering is not allowed.\n *\n * @param moveToState {@code true} if added fragments should be moved to their final state\n *                    in ordered transactions\n */\nvoid executePopOps(boolean moveToState) {\n    for (int opNum = mOps.size() - 1; opNum >= 0; opNum--) {\n        final Op op = mOps.get(opNum);\n        Fragment f = op.mFragment;\n        if (f != null) {\n            f.setPopDirection(true);\n            f.setAnimations(op.mEnterAnim, op.mExitAnim, op.mPopEnterAnim, op.mPopExitAnim);\n            f.setNextTransition(FragmentManager.reverseTransit(mTransition));\n            // Reverse the target and source names for pop operations\n            f.setSharedElementNames(mSharedElementTargetNames, mSharedElementSourceNames);\n        }\n        switch (op.mCmd) {\n            case OP_ADD:\n                mManager.setExitAnimationOrder(f, true);\n                mManager.removeFragment(f);\n                break;\n            case OP_REMOVE:\n                mManager.addFragment(f);\n                break;\n            case OP_HIDE:\n                mManager.showFragment(f);\n                break;\n            case OP_SHOW:\n                mManager.setExitAnimationOrder(f, true);\n                mManager.hideFragment(f);\n                break;\n            case OP_DETACH:\n                mManager.attachFragment(f);\n                break;\n            case OP_ATTACH:\n                mManager.setExitAnimationOrder(f, true);\n                mManager.detachFragment(f);\n                break;\n            case OP_SET_PRIMARY_NAV:\n                mManager.setPrimaryNavigationFragment(null);\n                break;\n            case OP_UNSET_PRIMARY_NAV:\n                mManager.setPrimaryNavigationFragment(f);\n                break;\n            case OP_SET_MAX_LIFECYCLE:\n                mManager.setMaxLifecycle(f, op.mOldMaxState);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown cmd: \" + op.mCmd);\n        }\n        if (!mReorderingAllowed && op.mCmd != OP_REMOVE && f != null) {\n            if (!FragmentManager.USE_STATE_MANAGER) {\n                mManager.moveFragmentToExpectedState(f);\n            }\n        }\n    }\n    if (!mReorderingAllowed && moveToState && !FragmentManager.USE_STATE_MANAGER) {\n        mManager.moveToState(mManager.mCurState, true);\n    }\n}\n```\n\n# BackPressedCallback注册和反注册\n\n注册和反注册有些值得揣摩，它和以往的模式略有不同。一般而言，注册和反注册都是提供一对API，add & remove 或者 register & unregister。但这里mOnBackPressedDispatcher只提供addCallback，反注册是mOnBackPressedCallback自己调用cancel 方法实现。\n\n## 注册\n\n```java\nandroidx.fragment.app.FragmentManager#attachController\n@SuppressLint(\"SyntheticAccessor\")\nvoid attachController(@NonNull FragmentHostCallback<?> host,\n        @NonNull FragmentContainer container, @Nullable final Fragment parent) {\n    if (mHost != null) throw new IllegalStateException(\"Already attached\");\n    mHost = host;\n    mContainer = container;\n    mParent = parent;\n\n    // Set up the OnBackPressedCallback\n    if (host instanceof OnBackPressedDispatcherOwner) {\n        OnBackPressedDispatcherOwner dispatcherOwner = ((OnBackPressedDispatcherOwner) host);\n        mOnBackPressedDispatcher = dispatcherOwner.getOnBackPressedDispatcher();\n        LifecycleOwner owner = parent != null ? parent : dispatcherOwner;\n\t\t\t\t// 注册\n        mOnBackPressedDispatcher.addCallback(owner, mOnBackPressedCallback);\n    }\n}\n```\n\n## 反注册\n\n```java\nvoid dispatchDestroy() {\n    mDestroyed = true;\n    execPendingActions(true);\n    endAnimatingAwayFragments();\n    dispatchStateChange(Fragment.INITIALIZING);\n    mHost = null;\n    mContainer = null;\n    mParent = null;\n    if (mOnBackPressedDispatcher != null) {\n        // mOnBackPressedDispatcher can hold a reference to the host\n        // so we need to null it out to prevent memory leaks\n\t\t\t\t// 反注册\n        mOnBackPressedCallback.remove();\n        mOnBackPressedDispatcher = null;\n    }\n}\n```\n\n注册实现\n\n```java\nandroidx.activity.OnBackPressedDispatcher#addCallback(androidx.lifecycle.LifecycleOwner, androidx.activity.OnBackPressedCallback)\n/**\n * Receive callbacks to a new {@link OnBackPressedCallback} when the given\n * {@link LifecycleOwner} is at least {@link Lifecycle.State#STARTED started}.\n * <p>\n * This will automatically call {@link #addCallback(OnBackPressedCallback)} and\n * remove the callback as the lifecycle state changes.\n * As a corollary, if your lifecycle is already at least\n * {@link Lifecycle.State#STARTED started}, calling this method will result in an immediate\n * call to {@link #addCallback(OnBackPressedCallback)}.\n * <p>\n * When the {@link LifecycleOwner} is {@link Lifecycle.State#DESTROYED destroyed}, it will\n * automatically be removed from the list of callbacks. The only time you would need to\n * manually call {@link OnBackPressedCallback#remove()} is if\n * you'd like to remove the callback prior to destruction of the associated lifecycle.\n *\n * <p>\n * If the Lifecycle is already {@link Lifecycle.State#DESTROYED destroyed}\n * when this method is called, the callback will not be added.\n *\n * @param owner The LifecycleOwner which controls when the callback should be invoked\n * @param onBackPressedCallback The callback to add\n *\n * @see #onBackPressed()\n */\n@SuppressLint(\"LambdaLast\")\n@MainThread\npublic void addCallback(@NonNull LifecycleOwner owner,\n        @NonNull OnBackPressedCallback onBackPressedCallback) {\n    Lifecycle lifecycle = owner.getLifecycle();\n    if (lifecycle.getCurrentState() == Lifecycle.State.DESTROYED) {\n        return;\n    }\n\t\t// 注册 action2\n    onBackPressedCallback.addCancellable(\n            new LifecycleOnBackPressedCancellable(lifecycle, onBackPressedCallback));\n}\n```\n\nonBackPressedCallback的注册委托给LifecycleOnBackPressedCancellable，同时，持有LifecycleOnBackPressedCancellable的实例引用，但反注册时，onBackPressedCallback调用cancel方法，通知LifecycleOnBackPressedCancellable实例反注册。也就是A 向C注册，其实是委托给B实现注册，反注册通过A持有B的引用，也由B负责完成。\n\n```java\nprivate class LifecycleOnBackPressedCancellable implements LifecycleEventObserver,\n        Cancellable {\n    private final Lifecycle mLifecycle;\n    private final OnBackPressedCallback mOnBackPressedCallback;\n\n    @Nullable\n    private Cancellable mCurrentCancellable;\n\n    LifecycleOnBackPressedCancellable(@NonNull Lifecycle lifecycle,\n            @NonNull OnBackPressedCallback onBackPressedCallback) {\n        mLifecycle = lifecycle;\n        mOnBackPressedCallback = onBackPressedCallback;\n\t\t\t\t// 注册 action1\n        lifecycle.addObserver(this);\n    }\n\n    @Override\n    public void onStateChanged(@NonNull LifecycleOwner source,\n            @NonNull Lifecycle.Event event) {\n        if (event == Lifecycle.Event.ON_START) {\n\t\t\t\t\t\t// 实际注册\n            mCurrentCancellable = addCancellableCallback(mOnBackPressedCallback);\n        } else if (event == Lifecycle.Event.ON_STOP) {\n            // Should always be non-null\n            if (mCurrentCancellable != null) {\n                mCurrentCancellable.cancel();\n            }\n        } else if (event == Lifecycle.Event.ON_DESTROY) {\n            cancel();\n        }\n    }\n\n    @Override\n    public void cancel() {\n\t\t\t\t// 反注册 action1\n        mLifecycle.removeObserver(this);\n\t\t\t\t// 反注册 action2\n        mOnBackPressedCallback.removeCancellable(this);\n        if (mCurrentCancellable != null) {\n\t\t\t\t\t\t// 实际反注册\n            mCurrentCancellable.cancel();\n            mCurrentCancellable = null;\n        }\n    }\n}\n\nandroidx.activity.OnBackPressedDispatcher#addCancellableCallback\n/**\n * Internal implementation of {@link #addCallback(OnBackPressedCallback)} that gives\n * access to the {@link Cancellable} that specifically removes this callback from\n * the dispatcher without relying on {@link OnBackPressedCallback#remove()} which\n * is what external developers should be using.\n *\n * @param onBackPressedCallback The callback to add\n * @return a {@link Cancellable} which can be used to {@link Cancellable#cancel() cancel}\n * the callback and remove it from the set of OnBackPressedCallbacks.\n */\n@SuppressWarnings(\"WeakerAccess\") /* synthetic access */\n@MainThread\n@NonNull\nCancellable addCancellableCallback(@NonNull OnBackPressedCallback onBackPressedCallback) {\n    // start后，实际注册进callback列表\n\t\tmOnBackPressedCallbacks.add(onBackPressedCallback);\n\t\t// 建立OnBackPressedCancellable实例 与onBackPressedCallback的双向引用并返回\n    OnBackPressedCancellable cancellable = new OnBackPressedCancellable(onBackPressedCallback);\n    onBackPressedCallback.addCancellable(cancellable);\n    return cancellable;\n}\n\nprivate class OnBackPressedCancellable implements Cancellable {\n    private final OnBackPressedCallback mOnBackPressedCallback;\n    OnBackPressedCancellable(OnBackPressedCallback onBackPressedCallback) {\n        mOnBackPressedCallback = onBackPressedCallback;\n    }\n\n    @Override\n    public void cancel() {\n\t\t\t\t// stop后，实际反注册\n        mOnBackPressedCallbacks.remove(mOnBackPressedCallback);\n\t\t\t\t// 断开引用\n        mOnBackPressedCallback.removeCancellable(this);\n    }\n}\n```\n\n","source":"_posts/FragmentManager源码剖析2.md","raw":"---\ntitle: FragmentManager源码剖析二\ndate: 2021-10-18 21:27:09\ntags:\n---\n\n\n\n# remove & detach Fragment差别\n\n```java\npublic void removeFragment(Fragment fragment) {\n    if (DEBUG) Log.v(TAG, \"remove: \" + fragment + \" nesting=\" + fragment.mBackStackNesting);\n    final boolean inactive = !fragment.isInBackStack();\n    if (!fragment.mDetached || inactive) {\n        synchronized (mAdded) {\n            mAdded.remove(fragment);\n        }\n        if (isMenuAvailable(fragment)) {\n            mNeedMenuInvalidate = true;\n        }\n        fragment.mAdded = false;\n        fragment.mRemoving = true;\n    }\n}\n```\n\n```java\npublic void detachFragment(Fragment fragment) {\n    if (DEBUG) Log.v(TAG, \"detach: \" + fragment);\n    if (!fragment.mDetached) {\n        fragment.mDetached = true;\n        if (fragment.mAdded) {\n            // We are not already in back stack, so need to remove the fragment.\n            if (DEBUG) Log.v(TAG, \"remove from detach: \" + fragment);\n            synchronized (mAdded) {\n                mAdded.remove(fragment);\n            }\n            if (isMenuAvailable(fragment)) {\n                mNeedMenuInvalidate = true;\n            }\n            fragment.mAdded = false;\n        }\n    }\n}\n```\n\n都是移出mAdded集合，并将mAdded置为false，区别在更新的标记不同mRemoving & mDetached。在FragmentManager同步状态调用时，有对remove & detach的状态同步。\n\n```java\n/**\n * Changes the state of the fragment manager to {@code newState}. If the fragment manager\n * changes state or {@code always} is {@code true}, any fragments within it have their\n * states updated as well.\n *\n * @param newState The new state for the fragment manager\n * @param always If {@code true}, all fragments update their state, even\n *               if {@code newState} matches the current fragment manager's state.\n */\nvoid moveToState(int newState, boolean always) {\n    if (mHost == null && newState != Fragment.INITIALIZING) {\n        throw new IllegalStateException(\"No activity\");\n    }\n\n    if (!always && newState == mCurState) {\n        return;\n    }\n\n    mCurState = newState;\n\n    if (mActive != null) {\n\n        // Must add them in the proper order. mActive fragments may be out of order\n\t\t\t\t// Fragment add & attach 后的状态同步\n        final int numAdded = mAdded.size();\n        for (int i = 0; i < numAdded; i++) {\n            Fragment f = mAdded.get(i);\n            moveFragmentToExpectedState(f);\n        }\n\n        // Now iterate through all active fragments. These will include those that are removed\n        // and detached.\n        final int numActive = mActive.size();\n        for (int i = 0; i < numActive; i++) {\n            Fragment f = mActive.valueAt(i);\n\t\t\t\t\t\t// Fragment 激活后执行remove 或者 detach，同步状态。\n            if (f != null && (f.mRemoving || f.mDetached) && !f.mIsNewlyAdded) {\n                moveFragmentToExpectedState(f);\n            }\n        }\n\n        startPendingDeferredFragments();\n\n        if (mNeedMenuInvalidate && mHost != null && mCurState == Fragment.RESUMED) {\n            mHost.onSupportInvalidateOptionsMenu();\n            mNeedMenuInvalidate = false;\n        }\n    }\n}\n```\n\n```java\n/**\n * Moves a fragment to its expected final state or the fragment manager's state, depending\n * on whether the fragment manager's state is raised properly.\n *\n * @param f The fragment to change.\n */\nvoid moveFragmentToExpectedState(Fragment f) {\n    if (f == null) {\n        return;\n    }\n    if (!mActive.containsKey(f.mWho)) {\n        if (DEBUG) {\n            Log.v(TAG, \"Ignoring moving \" + f + \" to state \" + mCurState\n                    + \"since it is not added to \" + this);\n        }\n        return;\n    }\n    int nextState = mCurState;\n    if (f.mRemoving) {\n        if (f.isInBackStack()) {\n            nextState = Math.min(nextState, Fragment.CREATED);\n        } else {\n            nextState = Math.min(nextState, Fragment.INITIALIZING);\n        }\n    }\n    moveToState(f, nextState, f.getNextTransition(), f.getNextTransitionStyle(), false);\n}\n```\n\n对于Remove如果nextState 是CREATED，Fragment只会`f.performDestroyView()`，但如果是INITIALIZING，分两种情况：\n\n1. 不在回退栈，执行`f.performDestroy()`;\n2. 在回退栈，执行`f.performDetach()`;并`makeInactive(f);`\n\n对于detach，nextState是CREATED，也即只执行`f.performDestroyView()`\n\n```java\n@SuppressWarnings(\"ReferenceEquality\")\nvoid moveToState(Fragment f, int newState, int transit, int transitionStyle,\n        boolean keepActive) {\n    // Fragments that are not currently added will sit in the onCreate() state.\n    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {\n        newState = Fragment.CREATED;\n    }\n}\n```\n\n# add & attach Fragment区别\n\n由于addFragment 有activate调用，fragment 已经在mActive映射里，允许状态同步，但attach没有activate 调用，于是状态不同步。\n\n```java\n/**\n * Moves a fragment to its expected final state or the fragment manager's state, depending\n * on whether the fragment manager's state is raised properly.\n *\n * @param f The fragment to change.\n */\nvoid moveFragmentToExpectedState(Fragment f) {\n    if (f == null) {\n        return;\n    }\n    if (!mActive.containsKey(f.mWho)) {\n        if (DEBUG) {\n            Log.v(TAG, \"Ignoring moving \" + f + \" to state \" + mCurState\n                    + \"since it is not added to \" + this);\n        }\n        return;\n    }\n    int nextState = mCurState;\n    if (f.mRemoving) {\n        if (f.isInBackStack()) {\n            nextState = Math.min(nextState, Fragment.CREATED);\n        } else {\n            nextState = Math.min(nextState, Fragment.INITIALIZING);\n        }\n    }\n    moveToState(f, nextState, f.getNextTransition(), f.getNextTransitionStyle(), false);\n}\n```\n\n```java\npublic void addFragment(Fragment fragment, boolean moveToStateNow) {\n    if (DEBUG) Log.v(TAG, \"add: \" + fragment);\n    **makeActive(fragment);// 这是主要区别**\n    if (!fragment.mDetached) {\n        if (mAdded.contains(fragment)) {\n            throw new IllegalStateException(\"Fragment already added: \" + fragment);\n        }\n        synchronized (mAdded) {\n            mAdded.add(fragment);\n        }\n        fragment.mAdded = true;\n        fragment.mRemoving = false;\n        if (fragment.mView == null) {\n            fragment.mHiddenChanged = false;\n        }\n        if (isMenuAvailable(fragment)) {\n            mNeedMenuInvalidate = true;\n        }\n        if (moveToStateNow) {\n            moveToState(fragment);\n        }\n    }\n}\n```\n\n```java\npublic void attachFragment(Fragment fragment) {\n    if (DEBUG) Log.v(TAG, \"attach: \" + fragment);\n    if (fragment.mDetached) {\n        fragment.mDetached = false;\n        if (!fragment.mAdded) {\n            if (mAdded.contains(fragment)) {\n                throw new IllegalStateException(\"Fragment already added: \" + fragment);\n            }\n            if (DEBUG) Log.v(TAG, \"add from attach: \" + fragment);\n            synchronized (mAdded) {\n                mAdded.add(fragment);\n            }\n            fragment.mAdded = true;\n            if (isMenuAvailable(fragment)) {\n                mNeedMenuInvalidate = true;\n            }\n        }\n    }\n}\n```\n\n# Show和hide Fragment区别\n\n首先，更新mHidden标记。\n\n```java\n/**\n * Marks a fragment as hidden to be later animated in with\n * {@link #completeShowHideFragment(Fragment)}.\n *\n * @param fragment The fragment to be shown.\n */\npublic void hideFragment(Fragment fragment) {\n    if (DEBUG) Log.v(TAG, \"hide: \" + fragment);\n    if (!fragment.mHidden) {\n        fragment.mHidden = true;\n        // Toggle hidden changed so that if a fragment goes through show/hide/show\n        // it doesn't go through the animation.\n        fragment.mHiddenChanged = !fragment.mHiddenChanged;\n    }\n}\n\n/**\n * Marks a fragment as shown to be later animated in with\n * {@link #completeShowHideFragment(Fragment)}.\n *\n * @param fragment The fragment to be shown.\n */\npublic void showFragment(Fragment fragment) {\n    if (DEBUG) Log.v(TAG, \"show: \" + fragment);\n    if (fragment.mHidden) {\n        fragment.mHidden = false;\n        // Toggle hidden changed so that if a fragment goes through show/hide/show\n        // it doesn't go through the animation.\n        fragment.mHiddenChanged = !fragment.mHiddenChanged;\n    }\n}\n```\n\n故事并没有就此结束，看下这个标记如何使用。\n\n首先，hidden后，Fragment下的View为Gone，不贡献视图。\n\n```java\nandroidx.fragment.app.FragmentStateManager#moveToExpectedState\nif (FragmentManager.USE_STATE_MANAGER && mFragment.mHiddenChanged) {\n    if (mFragment.mView != null && mFragment.mContainer != null) {\n        // Get the controller and enqueue the show/hide\n        SpecialEffectsController controller = SpecialEffectsController\n                .getOrCreateController(mFragment.mContainer,\n                        mFragment.getParentFragmentManager());\n        if (mFragment.mHidden) {\n            controller.enqueueHide(this);\n        } else {\n            controller.enqueueShow(this);\n        }\n    }\n    if (mFragment.mFragmentManager != null) {\n        mFragment.mFragmentManager.invalidateMenuForFragment(mFragment);\n    }\n    mFragment.mHiddenChanged = false;\n    mFragment.onHiddenChanged(mFragment.mHidden);\n}\n```\n\n其次，hidden后，Fragment不再贡献菜单项\n\n```java\nandroidx.fragment.app.FragmentManager#dispatchPrepareOptionsMenu\nboolean dispatchPrepareOptionsMenu(@NonNull Menu menu) {\n    if (mCurState < Fragment.CREATED) {\n        return false;\n    }\n    boolean show = false;\n    for (Fragment f : mFragmentStore.getFragments()) {\n        if (f != null) {\n            if (isParentMenuVisible(f) && f.performPrepareOptionsMenu(menu)) {\n                show = true;\n            }\n        }\n    }\n    return show;\n}\n\nandroidx.fragment.app.Fragment#performPrepareOptionsMenu\nboolean performPrepareOptionsMenu(@NonNull Menu menu) {\n    boolean show = false;\n    if (!mHidden) {\n        if (mHasMenu && mMenuVisible) {\n            show = true;\n            onPrepareOptionsMenu(menu);\n        }\n        show |= mChildFragmentManager.dispatchPrepareOptionsMenu(menu);\n    }\n    return show;\n}\n```\n\n显隐切换完成后，androidx.fragment.app.Fragment#onHiddenChanged会得到通知调用。\n\n```java\nandroidx.fragment.app.FragmentManager#completeShowHideFragment\nandroidx.fragment.app.FragmentStateManager#moveToExpectedState\n\n```\n\n# FragmentManager 派发生命周期方法\n\n```java\npublic class FragmentActivity extends ComponentActivity {\n    final FragmentController mFragments = FragmentController.createController(\n\t\t\t\t\tnew HostCallbacks());\n}\n```\n\nmFragments 负责Activity 生命周期方法，派发给FragmentManager，再遍历逐个派发给旗下的Fragment。\n\n```java\n/**\n * Perform initialization of all fragments.\n */\n@SuppressWarnings(\"deprecation\")\n@Override\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    mFragments.attachHost(null /*parent*/);\n\n    if (savedInstanceState != null) {\n        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);\n        mFragments.restoreSaveState(p);\n    }\n\n    super.onCreate(savedInstanceState);\n\n    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);\n    mFragments.dispatchCreate();\n}\n```\n\n```java\n/**\n * Moves all Fragments managed by the controller's FragmentManager\n * into the create state.\n * <p>Call when Fragments should be created.\n *\n * @see Fragment#onCreate(Bundle)\n */\npublic void dispatchCreate() {\n    mHost.mFragmentManager.dispatchCreate();\n}\n```\n\ndispatchCreate 终导致FragmentManagerImpl的当前状态`mCurState` 变更。\n\n```java\nandroidx.fragment.app.FragmentManager#dispatchCreate\nvoid dispatchCreate() {\n    mStateSaved = false;\n    mStopped = false;\n    mNonConfig.setIsStateSaved(false);\n    dispatchStateChange(Fragment.CREATED);\n}\n\nandroidx.fragment.app.FragmentManager#dispatchStateChange\nprivate void dispatchStateChange(int nextState) {\n    try {\n        mExecutingActions = true;\n        mFragmentStore.dispatchStateChange(nextState);\n        moveToState(nextState, false);\n        if (USE_STATE_MANAGER) {\n            Set<SpecialEffectsController> controllers = collectAllSpecialEffectsController();\n            for (SpecialEffectsController controller : controllers) {\n                controller.forceCompleteAllOperations();\n            }\n        }\n    } finally {\n        mExecutingActions = false;\n    }\n    execPendingActions(true);\n}\n\n// 同步生命周期状态给mActive内fragment集合\nvoid dispatchStateChange(int state) {\n    for (FragmentStateManager fragmentStateManager : mActive.values()) {\n        if (fragmentStateManager != null) {\n            fragmentStateManager.setFragmentManagerState(state);\n        }\n    }\n}\n```\n\n```java\nandroidx.fragment.app.FragmentManager#moveToState(int, boolean)\n/**\n * Changes the state of the fragment manager to {@code newState}. If the fragment manager\n * changes state or {@code always} is {@code true}, any fragments within it have their\n * states updated as well.\n *\n * @param newState The new state for the fragment manager\n * @param always If {@code true}, all fragments update their state, even\n *               if {@code newState} matches the current fragment manager's state.\n */\nvoid moveToState(int newState, boolean always) {\n    if (mHost == null && newState != Fragment.INITIALIZING) {\n        throw new IllegalStateException(\"No activity\");\n    }\n\n    if (!always && newState == mCurState) {\n        return;\n    }\n\n    mCurState = newState;\n\n    if (USE_STATE_MANAGER) {\n        mFragmentStore.moveToExpectedState();\n    } else {\n        // Must add them in the proper order. mActive fragments may be out of order\n        for (Fragment f : mFragmentStore.getFragments()) {\n            moveFragmentToExpectedState(f);\n        }\n\n        // Now iterate through all active fragments. These will include those that are removed\n        // and detached.\n        for (FragmentStateManager fragmentStateManager :\n                mFragmentStore.getActiveFragmentStateManagers()) {\n            Fragment f = fragmentStateManager.getFragment();\n            if (!f.mIsNewlyAdded) {\n                moveFragmentToExpectedState(f);\n            }\n            boolean beingRemoved = f.mRemoving && !f.isInBackStack();\n            if (beingRemoved) {\n                mFragmentStore.makeInactive(fragmentStateManager);\n            }\n        }\n    }\n\n    startPendingDeferredFragments();\n\n    if (mNeedMenuInvalidate && mHost != null && mCurState == Fragment.RESUMED) {\n        mHost.onSupportInvalidateOptionsMenu();\n        mNeedMenuInvalidate = false;\n    }\n}\n```\n\n```java\nandroidx.fragment.app.FragmentManager#moveFragmentToExpectedState\nvoid moveToExpectedState() {\n    // Must add them in the proper order. mActive fragments may be out of order\n    for (Fragment f : mAdded) {\n        FragmentStateManager fragmentStateManager = mActive.get(f.mWho);\n        if (fragmentStateManager != null) {\n            fragmentStateManager.moveToExpectedState();\n        }\n    }\n\n    // Now iterate through all active fragments. These will include those that are removed\n    // and detached.\n    for (FragmentStateManager fragmentStateManager : mActive.values()) {\n        if (fragmentStateManager != null) {\n            fragmentStateManager.moveToExpectedState();\n\n            Fragment f = fragmentStateManager.getFragment();\n            boolean beingRemoved = f.mRemoving && !f.isInBackStack();\n            if (beingRemoved) {\n                makeInactive(fragmentStateManager);\n            }\n        }\n    }\n}\n```\n\n注意只有在mActive集合的Fragment才可以`moveToExpectedState` ，attach阶段的Fragment 并未进入此集合，add之后才进入，此后Fragment接收生命周期方法派发。\n\n# BackStack\n\n```java\n/**\n * Implementation of {@link FragmentManagerImpl.OpGenerator}.\n * This operation is added to the list of pending actions during {@link #commit()}, and\n * will be executed on the UI thread to run this FragmentTransaction.\n *\n * @param records Modified to add this BackStackRecord\n * @param isRecordPop Modified to add a false (this isn't a pop)\n * @return true always because the records and isRecordPop will always be changed\n */\n@Override\npublic boolean generateOps(ArrayList<BackStackRecord> records, ArrayList<Boolean> isRecordPop) {\n    if (FragmentManagerImpl.DEBUG) {\n        Log.v(TAG, \"Run: \" + this);\n    }\n\n    records.add(this);\n    isRecordPop.add(false);\n    if (mAddToBackStack) {\n        mManager.addBackStackState(this);\n    }\n    return true;\n}\n```\n\n```java\nvoid addBackStackState(BackStackRecord state) {\n    if (mBackStack == null) {\n        mBackStack = new ArrayList<BackStackRecord>();\n    }\n    mBackStack.add(state);\n}\n```\n\n把当前backStackRecord 即事务加入mBackStack 集合。此处可以猜想：当接收back事件时，activity先派发back事件给FragmentManager，如果mBackStack存在元素，则将列表末尾的事务revert，并移出集合，指针向左偏移一位，并直接返回。如果FragmentManager不回应back event，那么由Activity继续回应。我们看下具体实现是否这样。\n\n```java\nandroidx.activity.ComponentActivity#onBackPressed\n/**\n * Called when the activity has detected the user's press of the back\n * key. The {@link #getOnBackPressedDispatcher() OnBackPressedDispatcher} will be given a\n * chance to handle the back button before the default behavior of\n * {@link android.app.Activity#onBackPressed()} is invoked.\n *\n * @see #getOnBackPressedDispatcher()\n */\n@Override\n@MainThread\npublic void onBackPressed() {\n    mOnBackPressedDispatcher.onBackPressed();\n}\n\nprivate final OnBackPressedDispatcher mOnBackPressedDispatcher =\n      new OnBackPressedDispatcher(new Runnable() {\n          @Override\n          public void run() {\n              ComponentActivity.super.onBackPressed();\n          }\n      });\n\nandroidx.activity.OnBackPressedDispatcher#onBackPressed\n/**\n * Trigger a call to the currently added {@link OnBackPressedCallback callbacks} in reverse\n * order in which they were added. Only if the most recently added callback is not\n * {@link OnBackPressedCallback#isEnabled() enabled}\n * will any previously added callback be called.\n * <p>\n * It is strongly recommended to call {@link #hasEnabledCallbacks()} prior to calling\n * this method to determine if there are any enabled callbacks that will be triggered\n * by this method as calling this method.\n */\n@MainThread\npublic void onBackPressed() {\n    Iterator<OnBackPressedCallback> iterator =\n            mOnBackPressedCallbacks.descendingIterator();\n    while (iterator.hasNext()) {\n        OnBackPressedCallback callback = iterator.next();\n        if (callback.isEnabled()) {\n\t\t\t\t\t\t// 如果回调回应back事件，则返回\n            callback.handleOnBackPressed();\n            return;\n        }\n    }\n\t\t// FragmentManager 没回应，则继续走这里\n    if (mFallbackOnBackPressed != null) {\n\t\t\t\t// 为OnBackPressedDispatcher初始化时，传入的回调方法，其实现是\n\t\t\t\t// 调用Activity的onBackPressed()\n        mFallbackOnBackPressed.run();\n    }\n}\n\n```\n\nFragmentManager如何注册callback\n\n→androidx.fragment.app.FragmentActivity#init\n\n→androidx.fragment.app.FragmentController#attachHost\n\n→androidx.fragment.app.FragmentManager#attachController\n\n```java\n@SuppressWarnings(\"deprecation\")\n@SuppressLint(\"SyntheticAccessor\")\nvoid attachController(@NonNull FragmentHostCallback<?> host,\n        @NonNull FragmentContainer container, @Nullable final Fragment parent) {\n    if (mHost != null) throw new IllegalStateException(\"Already attached\");\n    mHost = host;\n    mContainer = container;\n    mParent = parent;\n\n    // Add a FragmentOnAttachListener to the parent fragment / host to support\n    // backward compatibility with the deprecated onAttachFragment() APIs\n    if (mParent != null) {\n        addFragmentOnAttachListener(new FragmentOnAttachListener() {\n            @SuppressWarnings(\"deprecation\")\n            @Override\n            public void onAttachFragment(@NonNull FragmentManager fragmentManager,\n                    @NonNull Fragment fragment) {\n                parent.onAttachFragment(fragment);\n            }\n        });\n    } else if (host instanceof FragmentOnAttachListener) {\n        addFragmentOnAttachListener((FragmentOnAttachListener) host);\n    }\n\n    if (mParent != null) {\n        // Since the callback depends on us being the primary navigation fragment,\n        // update our callback now that we have a parent so that we have the correct\n        // state by default\n        updateOnBackPressedCallbackEnabled();\n    }\n    // Set up the OnBackPressedCallback\n    if (host instanceof OnBackPressedDispatcherOwner) {\n        OnBackPressedDispatcherOwner dispatcherOwner = ((OnBackPressedDispatcherOwner) host);\n        mOnBackPressedDispatcher = dispatcherOwner.getOnBackPressedDispatcher();\n        LifecycleOwner owner = parent != null ? parent : dispatcherOwner;\n        mOnBackPressedDispatcher.addCallback(owner, mOnBackPressedCallback);\n    }\n\t\t// 代码省略\n}\n```\n\n```java\nprivate final OnBackPressedCallback mOnBackPressedCallback =\n    new OnBackPressedCallback(false) {\n        @Override\n        public void handleOnBackPressed() {\n            FragmentManager.this.handleOnBackPressed();\n        }\n    };\n```\n\n```java\nandroidx.fragment.app.FragmentManager#handleOnBackPressed\n@SuppressWarnings(\"WeakerAccess\") /* synthetic access */\nvoid handleOnBackPressed() {\n    // First, execute any pending actions to make sure we're in an\n    // up to date view of the world just in case anyone is queuing\n    // up transactions that change the back stack then immediately\n    // calling onBackPressed()\n    execPendingActions(true);\n    if (mOnBackPressedCallback.isEnabled()) {\n        // We still have a back stack, so we can pop\n        popBackStackImmediate();\n    } else {\n        // Sigh. Due to FragmentManager's asynchronicity, we can\n        // get into cases where we *think* we can handle the back\n        // button but because of frame perfect dispatch, we fell\n        // on our face. Since our callback is disabled, we can\n        // re-trigger the onBackPressed() to dispatch to the next\n        // enabled callback\n        mOnBackPressedDispatcher.onBackPressed();\n    }\n}\n```\n\n看fragmentManager.popBackStackImmediate()\n\n```java\n@Override\npublic boolean popBackStackImmediate() {\n    checkStateLoss();\n    return popBackStackImmediate(null, -1, 0);\n}\n```\n\n```java\n/**\n * Used by all public popBackStackImmediate methods, this executes pending transactions and\n * returns true if the pop action did anything, regardless of what other pending\n * transactions did.\n *\n * @return true if the pop operation did anything or false otherwise.\n */\nprivate boolean popBackStackImmediate(String name, int id, int flags) {\n    execPendingActions();\n    ensureExecReady(true);\n\n    if (mPrimaryNav != null // We have a primary nav fragment\n            && id < 0 // No valid id (since they're local)\n            && name == null) { // no name to pop to (since they're local)\n        final FragmentManager childManager = mPrimaryNav.getChildFragmentManager();\n        if (childManager.popBackStackImmediate()) {\n            // We did something, just not to this specific FragmentManager. Return true.\n            return true;\n        }\n    }\n\n    boolean executePop = popBackStackState(mTmpRecords, mTmpIsPop, name, id, flags);\n    if (executePop) {\n        mExecutingActions = true;\n        try {\n            removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop);\n        } finally {\n            cleanupExec();\n        }\n    }\n\n    updateOnBackPressedCallbackEnabled();\n    doPendingDeferredStart();\n    burpActive();\n    return executePop;\n}\n```\n\npopBackStackState获取回退事务集合，交由removeRedundantOperationsAndExecute执行事务回退。\n\n```java\nboolean popBackStackState(ArrayList<BackStackRecord> records, ArrayList<Boolean> isRecordPop,\n                              String name, int id, int flags) {\n    if (mBackStack == null) {\n        return false;\n    }\n\t\t// 无参数回退，只回退一个事务\n    if (name == null && id < 0 && (flags & POP_BACK_STACK_INCLUSIVE) == 0) {\n        int last = mBackStack.size() - 1;\n        if (last < 0) {\n            return false;\n        }\n        records.add(mBackStack.remove(last));\n        isRecordPop.add(true);\n    } else {\n\t\t\t\t// 指定id或者backStack name回退，可以一次回退多个事务。\n        int index = -1;\n        if (name != null || id >= 0) {\n            // If a name or ID is specified, look for that place in\n            // the stack.\n            index = mBackStack.size()-1;\n            while (index >= 0) {\n                BackStackRecord bss = mBackStack.get(index);\n                if (name != null && name.equals(bss.getName())) {\n                    break;\n                }\n                if (id >= 0 && id == bss.mIndex) {\n                    break;\n                }\n                index--;\n            }\n            if (index < 0) {\n                return false;\n            }\n            if ((flags&POP_BACK_STACK_INCLUSIVE) != 0) {\n                index--;\n                // Consume all following entries that match.\n                while (index >= 0) {\n                    BackStackRecord bss = mBackStack.get(index);\n                    if ((name != null && name.equals(bss.getName()))\n                            || (id >= 0 && id == bss.mIndex)) {\n                        index--;\n                        continue;\n                    }\n                    break;\n                }\n            }\n        }\n        if (index == mBackStack.size()-1) {\n            return false;\n        }\n        for (int i = mBackStack.size() - 1; i > index; i--) {\n            records.add(mBackStack.remove(i));\n            isRecordPop.add(true);\n        }\n    }\n    return true;\n}\n```\n\n事务从mBackStack回退栈管理集合移出，并加入records用于执行事务，对应的isRecordPop元素设置为true，标记位回退事务，最后执行逆向操作，实现回退。\n\n→androidx.fragment.app.FragmentManagerImpl#removeRedundantOperationsAndExecute\n\n→androidx.fragment.app.FragmentManagerImpl#executeOpsTogether\n\n→androidx.fragment.app.FragmentManager#executeOps\n\n→androidx.fragment.app.BackStackRecord#executePopOps\n\n```java\nandroidx.fragment.app.FragmentManager#executeOps\n/**\n * Run the operations in the BackStackRecords, either to push or pop.\n *\n * @param records The list of records whose operations should be run.\n * @param isRecordPop The direction that these records are being run.\n * @param startIndex The index of the first entry in records to run.\n * @param endIndex One past the index of the final entry in records to run.\n */\nprivate static void executeOps(@NonNull ArrayList<BackStackRecord> records,\n        @NonNull ArrayList<Boolean> isRecordPop, int startIndex, int endIndex) {\n    for (int i = startIndex; i < endIndex; i++) {\n        final BackStackRecord record = records.get(i);\n        final boolean isPop = isRecordPop.get(i);\n        if (isPop) {\n            record.bumpBackStackNesting(-1);\n            // Only execute the add operations at the end of\n            // all transactions.\n            boolean moveToState = i == (endIndex - 1);\n            record.executePopOps(moveToState);\n        } else {\n            record.bumpBackStackNesting(1);\n            record.executeOps();\n        }\n    }\n}\n\nandroidx.fragment.app.BackStackRecord#executePopOps\n/**\n * Reverses the execution of the operations within this transaction. The Fragment states will\n * only be modified if reordering is not allowed.\n *\n * @param moveToState {@code true} if added fragments should be moved to their final state\n *                    in ordered transactions\n */\nvoid executePopOps(boolean moveToState) {\n    for (int opNum = mOps.size() - 1; opNum >= 0; opNum--) {\n        final Op op = mOps.get(opNum);\n        Fragment f = op.mFragment;\n        if (f != null) {\n            f.setPopDirection(true);\n            f.setAnimations(op.mEnterAnim, op.mExitAnim, op.mPopEnterAnim, op.mPopExitAnim);\n            f.setNextTransition(FragmentManager.reverseTransit(mTransition));\n            // Reverse the target and source names for pop operations\n            f.setSharedElementNames(mSharedElementTargetNames, mSharedElementSourceNames);\n        }\n        switch (op.mCmd) {\n            case OP_ADD:\n                mManager.setExitAnimationOrder(f, true);\n                mManager.removeFragment(f);\n                break;\n            case OP_REMOVE:\n                mManager.addFragment(f);\n                break;\n            case OP_HIDE:\n                mManager.showFragment(f);\n                break;\n            case OP_SHOW:\n                mManager.setExitAnimationOrder(f, true);\n                mManager.hideFragment(f);\n                break;\n            case OP_DETACH:\n                mManager.attachFragment(f);\n                break;\n            case OP_ATTACH:\n                mManager.setExitAnimationOrder(f, true);\n                mManager.detachFragment(f);\n                break;\n            case OP_SET_PRIMARY_NAV:\n                mManager.setPrimaryNavigationFragment(null);\n                break;\n            case OP_UNSET_PRIMARY_NAV:\n                mManager.setPrimaryNavigationFragment(f);\n                break;\n            case OP_SET_MAX_LIFECYCLE:\n                mManager.setMaxLifecycle(f, op.mOldMaxState);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown cmd: \" + op.mCmd);\n        }\n        if (!mReorderingAllowed && op.mCmd != OP_REMOVE && f != null) {\n            if (!FragmentManager.USE_STATE_MANAGER) {\n                mManager.moveFragmentToExpectedState(f);\n            }\n        }\n    }\n    if (!mReorderingAllowed && moveToState && !FragmentManager.USE_STATE_MANAGER) {\n        mManager.moveToState(mManager.mCurState, true);\n    }\n}\n```\n\n# BackPressedCallback注册和反注册\n\n注册和反注册有些值得揣摩，它和以往的模式略有不同。一般而言，注册和反注册都是提供一对API，add & remove 或者 register & unregister。但这里mOnBackPressedDispatcher只提供addCallback，反注册是mOnBackPressedCallback自己调用cancel 方法实现。\n\n## 注册\n\n```java\nandroidx.fragment.app.FragmentManager#attachController\n@SuppressLint(\"SyntheticAccessor\")\nvoid attachController(@NonNull FragmentHostCallback<?> host,\n        @NonNull FragmentContainer container, @Nullable final Fragment parent) {\n    if (mHost != null) throw new IllegalStateException(\"Already attached\");\n    mHost = host;\n    mContainer = container;\n    mParent = parent;\n\n    // Set up the OnBackPressedCallback\n    if (host instanceof OnBackPressedDispatcherOwner) {\n        OnBackPressedDispatcherOwner dispatcherOwner = ((OnBackPressedDispatcherOwner) host);\n        mOnBackPressedDispatcher = dispatcherOwner.getOnBackPressedDispatcher();\n        LifecycleOwner owner = parent != null ? parent : dispatcherOwner;\n\t\t\t\t// 注册\n        mOnBackPressedDispatcher.addCallback(owner, mOnBackPressedCallback);\n    }\n}\n```\n\n## 反注册\n\n```java\nvoid dispatchDestroy() {\n    mDestroyed = true;\n    execPendingActions(true);\n    endAnimatingAwayFragments();\n    dispatchStateChange(Fragment.INITIALIZING);\n    mHost = null;\n    mContainer = null;\n    mParent = null;\n    if (mOnBackPressedDispatcher != null) {\n        // mOnBackPressedDispatcher can hold a reference to the host\n        // so we need to null it out to prevent memory leaks\n\t\t\t\t// 反注册\n        mOnBackPressedCallback.remove();\n        mOnBackPressedDispatcher = null;\n    }\n}\n```\n\n注册实现\n\n```java\nandroidx.activity.OnBackPressedDispatcher#addCallback(androidx.lifecycle.LifecycleOwner, androidx.activity.OnBackPressedCallback)\n/**\n * Receive callbacks to a new {@link OnBackPressedCallback} when the given\n * {@link LifecycleOwner} is at least {@link Lifecycle.State#STARTED started}.\n * <p>\n * This will automatically call {@link #addCallback(OnBackPressedCallback)} and\n * remove the callback as the lifecycle state changes.\n * As a corollary, if your lifecycle is already at least\n * {@link Lifecycle.State#STARTED started}, calling this method will result in an immediate\n * call to {@link #addCallback(OnBackPressedCallback)}.\n * <p>\n * When the {@link LifecycleOwner} is {@link Lifecycle.State#DESTROYED destroyed}, it will\n * automatically be removed from the list of callbacks. The only time you would need to\n * manually call {@link OnBackPressedCallback#remove()} is if\n * you'd like to remove the callback prior to destruction of the associated lifecycle.\n *\n * <p>\n * If the Lifecycle is already {@link Lifecycle.State#DESTROYED destroyed}\n * when this method is called, the callback will not be added.\n *\n * @param owner The LifecycleOwner which controls when the callback should be invoked\n * @param onBackPressedCallback The callback to add\n *\n * @see #onBackPressed()\n */\n@SuppressLint(\"LambdaLast\")\n@MainThread\npublic void addCallback(@NonNull LifecycleOwner owner,\n        @NonNull OnBackPressedCallback onBackPressedCallback) {\n    Lifecycle lifecycle = owner.getLifecycle();\n    if (lifecycle.getCurrentState() == Lifecycle.State.DESTROYED) {\n        return;\n    }\n\t\t// 注册 action2\n    onBackPressedCallback.addCancellable(\n            new LifecycleOnBackPressedCancellable(lifecycle, onBackPressedCallback));\n}\n```\n\nonBackPressedCallback的注册委托给LifecycleOnBackPressedCancellable，同时，持有LifecycleOnBackPressedCancellable的实例引用，但反注册时，onBackPressedCallback调用cancel方法，通知LifecycleOnBackPressedCancellable实例反注册。也就是A 向C注册，其实是委托给B实现注册，反注册通过A持有B的引用，也由B负责完成。\n\n```java\nprivate class LifecycleOnBackPressedCancellable implements LifecycleEventObserver,\n        Cancellable {\n    private final Lifecycle mLifecycle;\n    private final OnBackPressedCallback mOnBackPressedCallback;\n\n    @Nullable\n    private Cancellable mCurrentCancellable;\n\n    LifecycleOnBackPressedCancellable(@NonNull Lifecycle lifecycle,\n            @NonNull OnBackPressedCallback onBackPressedCallback) {\n        mLifecycle = lifecycle;\n        mOnBackPressedCallback = onBackPressedCallback;\n\t\t\t\t// 注册 action1\n        lifecycle.addObserver(this);\n    }\n\n    @Override\n    public void onStateChanged(@NonNull LifecycleOwner source,\n            @NonNull Lifecycle.Event event) {\n        if (event == Lifecycle.Event.ON_START) {\n\t\t\t\t\t\t// 实际注册\n            mCurrentCancellable = addCancellableCallback(mOnBackPressedCallback);\n        } else if (event == Lifecycle.Event.ON_STOP) {\n            // Should always be non-null\n            if (mCurrentCancellable != null) {\n                mCurrentCancellable.cancel();\n            }\n        } else if (event == Lifecycle.Event.ON_DESTROY) {\n            cancel();\n        }\n    }\n\n    @Override\n    public void cancel() {\n\t\t\t\t// 反注册 action1\n        mLifecycle.removeObserver(this);\n\t\t\t\t// 反注册 action2\n        mOnBackPressedCallback.removeCancellable(this);\n        if (mCurrentCancellable != null) {\n\t\t\t\t\t\t// 实际反注册\n            mCurrentCancellable.cancel();\n            mCurrentCancellable = null;\n        }\n    }\n}\n\nandroidx.activity.OnBackPressedDispatcher#addCancellableCallback\n/**\n * Internal implementation of {@link #addCallback(OnBackPressedCallback)} that gives\n * access to the {@link Cancellable} that specifically removes this callback from\n * the dispatcher without relying on {@link OnBackPressedCallback#remove()} which\n * is what external developers should be using.\n *\n * @param onBackPressedCallback The callback to add\n * @return a {@link Cancellable} which can be used to {@link Cancellable#cancel() cancel}\n * the callback and remove it from the set of OnBackPressedCallbacks.\n */\n@SuppressWarnings(\"WeakerAccess\") /* synthetic access */\n@MainThread\n@NonNull\nCancellable addCancellableCallback(@NonNull OnBackPressedCallback onBackPressedCallback) {\n    // start后，实际注册进callback列表\n\t\tmOnBackPressedCallbacks.add(onBackPressedCallback);\n\t\t// 建立OnBackPressedCancellable实例 与onBackPressedCallback的双向引用并返回\n    OnBackPressedCancellable cancellable = new OnBackPressedCancellable(onBackPressedCallback);\n    onBackPressedCallback.addCancellable(cancellable);\n    return cancellable;\n}\n\nprivate class OnBackPressedCancellable implements Cancellable {\n    private final OnBackPressedCallback mOnBackPressedCallback;\n    OnBackPressedCancellable(OnBackPressedCallback onBackPressedCallback) {\n        mOnBackPressedCallback = onBackPressedCallback;\n    }\n\n    @Override\n    public void cancel() {\n\t\t\t\t// stop后，实际反注册\n        mOnBackPressedCallbacks.remove(mOnBackPressedCallback);\n\t\t\t\t// 断开引用\n        mOnBackPressedCallback.removeCancellable(this);\n    }\n}\n```\n\n","slug":"FragmentManager源码剖析2","published":1,"updated":"2021-10-18T13:28:53.631Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckuwp1od60000mff994lb52q2","content":"<h1 id=\"remove-amp-detach-Fragment差别\"><a href=\"#remove-amp-detach-Fragment差别\" class=\"headerlink\" title=\"remove &amp; detach Fragment差别\"></a>remove &amp; detach Fragment差别</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeFragment</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;remove: &quot;</span> + fragment + <span class=\"string\">&quot; nesting=&quot;</span> + fragment.mBackStackNesting);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> inactive = !fragment.isInBackStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached || inactive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mAdded) &#123;</span><br><span class=\"line\">            mAdded.remove(fragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">            mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fragment.mAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        fragment.mRemoving = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">detachFragment</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;detach: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached) &#123;</span><br><span class=\"line\">        fragment.mDetached = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragment.mAdded) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We are not already in back stack, so need to remove the fragment.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;remove from detach: &quot;</span> + fragment);</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mAdded) &#123;</span><br><span class=\"line\">                mAdded.remove(fragment);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">                mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fragment.mAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>都是移出mAdded集合，并将mAdded置为false，区别在更新的标记不同mRemoving &amp; mDetached。在FragmentManager同步状态调用时，有对remove &amp; detach的状态同步。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Changes the state of the fragment manager to &#123;<span class=\"doctag\">@code</span> newState&#125;. If the fragment manager</span></span><br><span class=\"line\"><span class=\"comment\"> * changes state or &#123;<span class=\"doctag\">@code</span> always&#125; is &#123;<span class=\"doctag\">@code</span> true&#125;, any fragments within it have their</span></span><br><span class=\"line\"><span class=\"comment\"> * states updated as well.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> newState The new state for the fragment manager</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> always If &#123;<span class=\"doctag\">@code</span> true&#125;, all fragments update their state, even</span></span><br><span class=\"line\"><span class=\"comment\"> *               if &#123;<span class=\"doctag\">@code</span> newState&#125; matches the current fragment manager&#x27;s state.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(<span class=\"keyword\">int</span> newState, <span class=\"keyword\">boolean</span> always)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHost == <span class=\"keyword\">null</span> &amp;&amp; newState != Fragment.INITIALIZING) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;No activity&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!always &amp;&amp; newState == mCurState) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mCurState = newState;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mActive != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Must add them in the proper order. mActive fragments may be out of order</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Fragment add &amp; attach 后的状态同步</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> numAdded = mAdded.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numAdded; i++) &#123;</span><br><span class=\"line\">            Fragment f = mAdded.get(i);</span><br><span class=\"line\">            moveFragmentToExpectedState(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Now iterate through all active fragments. These will include those that are removed</span></span><br><span class=\"line\">        <span class=\"comment\">// and detached.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> numActive = mActive.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numActive; i++) &#123;</span><br><span class=\"line\">            Fragment f = mActive.valueAt(i);</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// Fragment 激活后执行remove 或者 detach，同步状态。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span> &amp;&amp; (f.mRemoving || f.mDetached) &amp;&amp; !f.mIsNewlyAdded) &#123;</span><br><span class=\"line\">                moveFragmentToExpectedState(f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        startPendingDeferredFragments();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mNeedMenuInvalidate &amp;&amp; mHost != <span class=\"keyword\">null</span> &amp;&amp; mCurState == Fragment.RESUMED) &#123;</span><br><span class=\"line\">            mHost.onSupportInvalidateOptionsMenu();</span><br><span class=\"line\">            mNeedMenuInvalidate = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Moves a fragment to its expected final state or the fragment manager&#x27;s state, depending</span></span><br><span class=\"line\"><span class=\"comment\"> * on whether the fragment manager&#x27;s state is raised properly.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> f The fragment to change.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveFragmentToExpectedState</span><span class=\"params\">(Fragment f)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mActive.containsKey(f.mWho)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (DEBUG) &#123;</span><br><span class=\"line\">            Log.v(TAG, <span class=\"string\">&quot;Ignoring moving &quot;</span> + f + <span class=\"string\">&quot; to state &quot;</span> + mCurState</span><br><span class=\"line\">                    + <span class=\"string\">&quot;since it is not added to &quot;</span> + <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextState = mCurState;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f.mRemoving) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f.isInBackStack()) &#123;</span><br><span class=\"line\">            nextState = Math.min(nextState, Fragment.CREATED);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            nextState = Math.min(nextState, Fragment.INITIALIZING);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    moveToState(f, nextState, f.getNextTransition(), f.getNextTransitionStyle(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于Remove如果nextState 是CREATED，Fragment只会<code>f.performDestroyView()</code>，但如果是INITIALIZING，分两种情况：</p>\n<ol>\n<li>不在回退栈，执行<code>f.performDestroy()</code>;</li>\n<li>在回退栈，执行<code>f.performDetach()</code>;并<code>makeInactive(f);</code></li>\n</ol>\n<p>对于detach，nextState是CREATED，也即只执行<code>f.performDestroyView()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;ReferenceEquality&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(Fragment f, <span class=\"keyword\">int</span> newState, <span class=\"keyword\">int</span> transit, <span class=\"keyword\">int</span> transitionStyle,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"keyword\">boolean</span> keepActive)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fragments that are not currently added will sit in the onCreate() state.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((!f.mAdded || f.mDetached) &amp;&amp; newState &gt; Fragment.CREATED) &#123;</span><br><span class=\"line\">        newState = Fragment.CREATED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"add-amp-attach-Fragment区别\"><a href=\"#add-amp-attach-Fragment区别\" class=\"headerlink\" title=\"add &amp; attach Fragment区别\"></a>add &amp; attach Fragment区别</h1><p>由于addFragment 有activate调用，fragment 已经在mActive映射里，允许状态同步，但attach没有activate 调用，于是状态不同步。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Moves a fragment to its expected final state or the fragment manager&#x27;s state, depending</span></span><br><span class=\"line\"><span class=\"comment\"> * on whether the fragment manager&#x27;s state is raised properly.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> f The fragment to change.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveFragmentToExpectedState</span><span class=\"params\">(Fragment f)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mActive.containsKey(f.mWho)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (DEBUG) &#123;</span><br><span class=\"line\">            Log.v(TAG, <span class=\"string\">&quot;Ignoring moving &quot;</span> + f + <span class=\"string\">&quot; to state &quot;</span> + mCurState</span><br><span class=\"line\">                    + <span class=\"string\">&quot;since it is not added to &quot;</span> + <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextState = mCurState;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f.mRemoving) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f.isInBackStack()) &#123;</span><br><span class=\"line\">            nextState = Math.min(nextState, Fragment.CREATED);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            nextState = Math.min(nextState, Fragment.INITIALIZING);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    moveToState(f, nextState, f.getNextTransition(), f.getNextTransitionStyle(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFragment</span><span class=\"params\">(Fragment fragment, <span class=\"keyword\">boolean</span> moveToStateNow)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;add: &quot;</span> + fragment);</span><br><span class=\"line\">    **makeActive(fragment);<span class=\"comment\">// 这是主要区别**</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mAdded.contains(fragment)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Fragment already added: &quot;</span> + fragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mAdded) &#123;</span><br><span class=\"line\">            mAdded.add(fragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fragment.mAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        fragment.mRemoving = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragment.mView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragment.mHiddenChanged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">            mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (moveToStateNow) &#123;</span><br><span class=\"line\">            moveToState(fragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attachFragment</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;attach: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fragment.mDetached) &#123;</span><br><span class=\"line\">        fragment.mDetached = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!fragment.mAdded) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mAdded.contains(fragment)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Fragment already added: &quot;</span> + fragment);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;add from attach: &quot;</span> + fragment);</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mAdded) &#123;</span><br><span class=\"line\">                mAdded.add(fragment);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fragment.mAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">                mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Show和hide-Fragment区别\"><a href=\"#Show和hide-Fragment区别\" class=\"headerlink\" title=\"Show和hide Fragment区别\"></a>Show和hide Fragment区别</h1><p>首先，更新mHidden标记。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Marks a fragment as hidden to be later animated in with</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #completeShowHideFragment(Fragment)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> fragment The fragment to be shown.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hideFragment</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;hide: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mHidden) &#123;</span><br><span class=\"line\">        fragment.mHidden = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Toggle hidden changed so that if a fragment goes through show/hide/show</span></span><br><span class=\"line\">        <span class=\"comment\">// it doesn&#x27;t go through the animation.</span></span><br><span class=\"line\">        fragment.mHiddenChanged = !fragment.mHiddenChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Marks a fragment as shown to be later animated in with</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #completeShowHideFragment(Fragment)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> fragment The fragment to be shown.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showFragment</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;show: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fragment.mHidden) &#123;</span><br><span class=\"line\">        fragment.mHidden = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Toggle hidden changed so that if a fragment goes through show/hide/show</span></span><br><span class=\"line\">        <span class=\"comment\">// it doesn&#x27;t go through the animation.</span></span><br><span class=\"line\">        fragment.mHiddenChanged = !fragment.mHiddenChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>故事并没有就此结束，看下这个标记如何使用。</p>\n<p>首先，hidden后，Fragment下的View为Gone，不贡献视图。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentStateManager#<span class=\"function\">moveToExpectedState</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">if</span> <span class=\"params\">(FragmentManager.USE_STATE_MANAGER &amp;&amp; mFragment.mHiddenChanged)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mFragment.mView != <span class=\"keyword\">null</span> &amp;&amp; mFragment.mContainer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Get the controller and enqueue the show/hide</span></span><br><span class=\"line\">        SpecialEffectsController controller = SpecialEffectsController</span><br><span class=\"line\">                .getOrCreateController(mFragment.mContainer,</span><br><span class=\"line\">                        mFragment.getParentFragmentManager());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFragment.mHidden) &#123;</span><br><span class=\"line\">            controller.enqueueHide(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            controller.enqueueShow(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mFragment.mFragmentManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mFragment.mFragmentManager.invalidateMenuForFragment(mFragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mFragment.mHiddenChanged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    mFragment.onHiddenChanged(mFragment.mHidden);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其次，hidden后，Fragment不再贡献菜单项</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">dispatchPrepareOptionsMenu</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">dispatchPrepareOptionsMenu</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Menu menu)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mCurState &lt; Fragment.CREATED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> show = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Fragment f : mFragmentStore.getFragments()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isParentMenuVisible(f) &amp;&amp; f.performPrepareOptionsMenu(menu)) &#123;</span><br><span class=\"line\">                show = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> show;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.fragment.app.Fragment#<span class=\"function\">performPrepareOptionsMenu</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">performPrepareOptionsMenu</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Menu menu)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> show = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mHidden) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mHasMenu &amp;&amp; mMenuVisible) &#123;</span><br><span class=\"line\">            show = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            onPrepareOptionsMenu(menu);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        show |= mChildFragmentManager.dispatchPrepareOptionsMenu(menu);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> show;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显隐切换完成后，androidx.fragment.app.Fragment#onHiddenChanged会得到通知调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#completeShowHideFragment</span><br><span class=\"line\">androidx.fragment.app.FragmentStateManager#moveToExpectedState</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"FragmentManager-派发生命周期方法\"><a href=\"#FragmentManager-派发生命周期方法\" class=\"headerlink\" title=\"FragmentManager 派发生命周期方法\"></a>FragmentManager 派发生命周期方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">ComponentActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> FragmentController mFragments = FragmentController.createController(</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">new</span> HostCallbacks());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mFragments 负责Activity 生命周期方法，派发给FragmentManager，再遍历逐个派发给旗下的Fragment。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Perform initialization of all fragments.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    mFragments.attachHost(<span class=\"keyword\">null</span> <span class=\"comment\">/*parent*/</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (savedInstanceState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class=\"line\">        mFragments.restoreSaveState(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class=\"line\">    mFragments.dispatchCreate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Moves all Fragments managed by the controller&#x27;s FragmentManager</span></span><br><span class=\"line\"><span class=\"comment\"> * into the create state.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Call when Fragments should be created.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> Fragment#onCreate(Bundle)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mHost.mFragmentManager.dispatchCreate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>dispatchCreate 终导致FragmentManagerImpl的当前状态<code>mCurState</code> 变更。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">dispatchCreate</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mStateSaved = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    mStopped = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    mNonConfig.setIsStateSaved(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    dispatchStateChange(Fragment.CREATED);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">dispatchStateChange</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchStateChange</span><span class=\"params\">(<span class=\"keyword\">int</span> nextState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        mExecutingActions = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        mFragmentStore.dispatchStateChange(nextState);</span><br><span class=\"line\">        moveToState(nextState, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">            Set&lt;SpecialEffectsController&gt; controllers = collectAllSpecialEffectsController();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (SpecialEffectsController controller : controllers) &#123;</span><br><span class=\"line\">                controller.forceCompleteAllOperations();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mExecutingActions = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    execPendingActions(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步生命周期状态给mActive内fragment集合</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchStateChange</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (FragmentStateManager fragmentStateManager : mActive.values()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragmentStateManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragmentStateManager.setFragmentManagerState(state);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#moveToState(<span class=\"keyword\">int</span>, <span class=\"keyword\">boolean</span>)</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Changes the state of the fragment manager to &#123;<span class=\"doctag\">@code</span> newState&#125;. If the fragment manager</span></span><br><span class=\"line\"><span class=\"comment\"> * changes state or &#123;<span class=\"doctag\">@code</span> always&#125; is &#123;<span class=\"doctag\">@code</span> true&#125;, any fragments within it have their</span></span><br><span class=\"line\"><span class=\"comment\"> * states updated as well.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> newState The new state for the fragment manager</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> always If &#123;<span class=\"doctag\">@code</span> true&#125;, all fragments update their state, even</span></span><br><span class=\"line\"><span class=\"comment\"> *               if &#123;<span class=\"doctag\">@code</span> newState&#125; matches the current fragment manager&#x27;s state.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(<span class=\"keyword\">int</span> newState, <span class=\"keyword\">boolean</span> always)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHost == <span class=\"keyword\">null</span> &amp;&amp; newState != Fragment.INITIALIZING) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;No activity&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!always &amp;&amp; newState == mCurState) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mCurState = newState;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">        mFragmentStore.moveToExpectedState();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Must add them in the proper order. mActive fragments may be out of order</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Fragment f : mFragmentStore.getFragments()) &#123;</span><br><span class=\"line\">            moveFragmentToExpectedState(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Now iterate through all active fragments. These will include those that are removed</span></span><br><span class=\"line\">        <span class=\"comment\">// and detached.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (FragmentStateManager fragmentStateManager :</span><br><span class=\"line\">                mFragmentStore.getActiveFragmentStateManagers()) &#123;</span><br><span class=\"line\">            Fragment f = fragmentStateManager.getFragment();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!f.mIsNewlyAdded) &#123;</span><br><span class=\"line\">                moveFragmentToExpectedState(f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (beingRemoved) &#123;</span><br><span class=\"line\">                mFragmentStore.makeInactive(fragmentStateManager);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    startPendingDeferredFragments();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mNeedMenuInvalidate &amp;&amp; mHost != <span class=\"keyword\">null</span> &amp;&amp; mCurState == Fragment.RESUMED) &#123;</span><br><span class=\"line\">        mHost.onSupportInvalidateOptionsMenu();</span><br><span class=\"line\">        mNeedMenuInvalidate = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">moveFragmentToExpectedState</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToExpectedState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Must add them in the proper order. mActive fragments may be out of order</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Fragment f : mAdded) &#123;</span><br><span class=\"line\">        FragmentStateManager fragmentStateManager = mActive.get(f.mWho);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragmentStateManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragmentStateManager.moveToExpectedState();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Now iterate through all active fragments. These will include those that are removed</span></span><br><span class=\"line\">    <span class=\"comment\">// and detached.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (FragmentStateManager fragmentStateManager : mActive.values()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragmentStateManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragmentStateManager.moveToExpectedState();</span><br><span class=\"line\"></span><br><span class=\"line\">            Fragment f = fragmentStateManager.getFragment();</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (beingRemoved) &#123;</span><br><span class=\"line\">                makeInactive(fragmentStateManager);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意只有在mActive集合的Fragment才可以<code>moveToExpectedState</code> ，attach阶段的Fragment 并未进入此集合，add之后才进入，此后Fragment接收生命周期方法派发。</p>\n<h1 id=\"BackStack\"><a href=\"#BackStack\" class=\"headerlink\" title=\"BackStack\"></a>BackStack</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implementation of &#123;<span class=\"doctag\">@link</span> FragmentManagerImpl.OpGenerator&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * This operation is added to the list of pending actions during &#123;<span class=\"doctag\">@link</span> #commit()&#125;, and</span></span><br><span class=\"line\"><span class=\"comment\"> * will be executed on the UI thread to run this FragmentTransaction.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records Modified to add this BackStackRecord</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isRecordPop Modified to add a false (this isn&#x27;t a pop)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true always because the records and isRecordPop will always be changed</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">generateOps</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isRecordPop)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FragmentManagerImpl.DEBUG) &#123;</span><br><span class=\"line\">        Log.v(TAG, <span class=\"string\">&quot;Run: &quot;</span> + <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    records.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    isRecordPop.add(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAddToBackStack) &#123;</span><br><span class=\"line\">        mManager.addBackStackState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBackStackState</span><span class=\"params\">(BackStackRecord state)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mBackStack == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mBackStack = <span class=\"keyword\">new</span> ArrayList&lt;BackStackRecord&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mBackStack.add(state);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把当前backStackRecord 即事务加入mBackStack 集合。此处可以猜想：当接收back事件时，activity先派发back事件给FragmentManager，如果mBackStack存在元素，则将列表末尾的事务revert，并移出集合，指针向左偏移一位，并直接返回。如果FragmentManager不回应back event，那么由Activity继续回应。我们看下具体实现是否这样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.activity.ComponentActivity#onBackPressed</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Called when the activity has detected the user&#x27;s press of the back</span></span><br><span class=\"line\"><span class=\"comment\"> * key. The &#123;<span class=\"doctag\">@link</span> #getOnBackPressedDispatcher() OnBackPressedDispatcher&#125; will be given a</span></span><br><span class=\"line\"><span class=\"comment\"> * chance to handle the back button before the default behavior of</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> android.app.Activity#onBackPressed()&#125; is invoked.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #getOnBackPressedDispatcher()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBackPressed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mOnBackPressedDispatcher.onBackPressed();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> OnBackPressedDispatcher mOnBackPressedDispatcher =</span><br><span class=\"line\">      <span class=\"keyword\">new</span> OnBackPressedDispatcher(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">              ComponentActivity.<span class=\"keyword\">super</span>.onBackPressed();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.activity.OnBackPressedDispatcher#onBackPressed</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Trigger a call to the currently added &#123;<span class=\"doctag\">@link</span> OnBackPressedCallback callbacks&#125; in reverse</span></span><br><span class=\"line\"><span class=\"comment\"> * order in which they were added. Only if the most recently added callback is not</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> OnBackPressedCallback#isEnabled() enabled&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * will any previously added callback be called.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * It is strongly recommended to call &#123;<span class=\"doctag\">@link</span> #hasEnabledCallbacks()&#125; prior to calling</span></span><br><span class=\"line\"><span class=\"comment\"> * this method to determine if there are any enabled callbacks that will be triggered</span></span><br><span class=\"line\"><span class=\"comment\"> * by this method as calling this method.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBackPressed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;OnBackPressedCallback&gt; iterator =</span><br><span class=\"line\">            mOnBackPressedCallbacks.descendingIterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">        OnBackPressedCallback callback = iterator.next();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callback.isEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 如果回调回应back事件，则返回</span></span><br><span class=\"line\">            callback.handleOnBackPressed();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// FragmentManager 没回应，则继续走这里</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mFallbackOnBackPressed != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 为OnBackPressedDispatcher初始化时，传入的回调方法，其实现是</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 调用Activity的onBackPressed()</span></span><br><span class=\"line\">        mFallbackOnBackPressed.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>FragmentManager如何注册callback</p>\n<p>→androidx.fragment.app.FragmentActivity#init</p>\n<p>→androidx.fragment.app.FragmentController#attachHost</p>\n<p>→androidx.fragment.app.FragmentManager#attachController</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressLint(&quot;SyntheticAccessor&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attachController</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> FragmentHostCallback&lt;?&gt; host,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"meta\">@NonNull</span> FragmentContainer container, <span class=\"meta\">@Nullable</span> <span class=\"keyword\">final</span> Fragment parent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHost != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Already attached&quot;</span>);</span><br><span class=\"line\">    mHost = host;</span><br><span class=\"line\">    mContainer = container;</span><br><span class=\"line\">    mParent = parent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Add a FragmentOnAttachListener to the parent fragment / host to support</span></span><br><span class=\"line\">    <span class=\"comment\">// backward compatibility with the deprecated onAttachFragment() APIs</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        addFragmentOnAttachListener(<span class=\"keyword\">new</span> FragmentOnAttachListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAttachFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> FragmentManager fragmentManager,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                    <span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">                parent.onAttachFragment(fragment);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (host <span class=\"keyword\">instanceof</span> FragmentOnAttachListener) &#123;</span><br><span class=\"line\">        addFragmentOnAttachListener((FragmentOnAttachListener) host);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Since the callback depends on us being the primary navigation fragment,</span></span><br><span class=\"line\">        <span class=\"comment\">// update our callback now that we have a parent so that we have the correct</span></span><br><span class=\"line\">        <span class=\"comment\">// state by default</span></span><br><span class=\"line\">        updateOnBackPressedCallbackEnabled();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Set up the OnBackPressedCallback</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (host <span class=\"keyword\">instanceof</span> OnBackPressedDispatcherOwner) &#123;</span><br><span class=\"line\">        OnBackPressedDispatcherOwner dispatcherOwner = ((OnBackPressedDispatcherOwner) host);</span><br><span class=\"line\">        mOnBackPressedDispatcher = dispatcherOwner.getOnBackPressedDispatcher();</span><br><span class=\"line\">        LifecycleOwner owner = parent != <span class=\"keyword\">null</span> ? parent : dispatcherOwner;</span><br><span class=\"line\">        mOnBackPressedDispatcher.addCallback(owner, mOnBackPressedCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 代码省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> OnBackPressedCallback mOnBackPressedCallback =</span><br><span class=\"line\">    <span class=\"keyword\">new</span> OnBackPressedCallback(<span class=\"keyword\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleOnBackPressed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            FragmentManager.<span class=\"keyword\">this</span>.handleOnBackPressed();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#handleOnBackPressed</span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class=\"comment\">/* synthetic access */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleOnBackPressed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// First, execute any pending actions to make sure we&#x27;re in an</span></span><br><span class=\"line\">    <span class=\"comment\">// up to date view of the world just in case anyone is queuing</span></span><br><span class=\"line\">    <span class=\"comment\">// up transactions that change the back stack then immediately</span></span><br><span class=\"line\">    <span class=\"comment\">// calling onBackPressed()</span></span><br><span class=\"line\">    execPendingActions(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mOnBackPressedCallback.isEnabled()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We still have a back stack, so we can pop</span></span><br><span class=\"line\">        popBackStackImmediate();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Sigh. Due to FragmentManager&#x27;s asynchronicity, we can</span></span><br><span class=\"line\">        <span class=\"comment\">// get into cases where we *think* we can handle the back</span></span><br><span class=\"line\">        <span class=\"comment\">// button but because of frame perfect dispatch, we fell</span></span><br><span class=\"line\">        <span class=\"comment\">// on our face. Since our callback is disabled, we can</span></span><br><span class=\"line\">        <span class=\"comment\">// re-trigger the onBackPressed() to dispatch to the next</span></span><br><span class=\"line\">        <span class=\"comment\">// enabled callback</span></span><br><span class=\"line\">        mOnBackPressedDispatcher.onBackPressed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看fragmentManager.popBackStackImmediate()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">popBackStackImmediate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    checkStateLoss();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> popBackStackImmediate(<span class=\"keyword\">null</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Used by all public popBackStackImmediate methods, this executes pending transactions and</span></span><br><span class=\"line\"><span class=\"comment\"> * returns true if the pop action did anything, regardless of what other pending</span></span><br><span class=\"line\"><span class=\"comment\"> * transactions did.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true if the pop operation did anything or false otherwise.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">popBackStackImmediate</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> id, <span class=\"keyword\">int</span> flags)</span> </span>&#123;</span><br><span class=\"line\">    execPendingActions();</span><br><span class=\"line\">    ensureExecReady(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPrimaryNav != <span class=\"keyword\">null</span> <span class=\"comment\">// We have a primary nav fragment</span></span><br><span class=\"line\">            &amp;&amp; id &lt; <span class=\"number\">0</span> <span class=\"comment\">// No valid id (since they&#x27;re local)</span></span><br><span class=\"line\">            &amp;&amp; name == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// no name to pop to (since they&#x27;re local)</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> FragmentManager childManager = mPrimaryNav.getChildFragmentManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childManager.popBackStackImmediate()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We did something, just not to this specific FragmentManager. Return true.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> executePop = popBackStackState(mTmpRecords, mTmpIsPop, name, id, flags);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executePop) &#123;</span><br><span class=\"line\">        mExecutingActions = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            cleanupExec();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    updateOnBackPressedCallbackEnabled();</span><br><span class=\"line\">    doPendingDeferredStart();</span><br><span class=\"line\">    burpActive();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> executePop;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>popBackStackState获取回退事务集合，交由removeRedundantOperationsAndExecute执行事务回退。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">popBackStackState</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isRecordPop,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                              String name, <span class=\"keyword\">int</span> id, <span class=\"keyword\">int</span> flags)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mBackStack == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 无参数回退，只回退一个事务</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span> &amp;&amp; id &lt; <span class=\"number\">0</span> &amp;&amp; (flags &amp; POP_BACK_STACK_INCLUSIVE) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> last = mBackStack.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (last &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        records.add(mBackStack.remove(last));</span><br><span class=\"line\">        isRecordPop.add(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 指定id或者backStack name回退，可以一次回退多个事务。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name != <span class=\"keyword\">null</span> || id &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If a name or ID is specified, look for that place in</span></span><br><span class=\"line\">            <span class=\"comment\">// the stack.</span></span><br><span class=\"line\">            index = mBackStack.size()-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (index &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                BackStackRecord bss = mBackStack.get(index);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (name != <span class=\"keyword\">null</span> &amp;&amp; name.equals(bss.getName())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (id &gt;= <span class=\"number\">0</span> &amp;&amp; id == bss.mIndex) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((flags&amp;POP_BACK_STACK_INCLUSIVE) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">                <span class=\"comment\">// Consume all following entries that match.</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (index &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    BackStackRecord bss = mBackStack.get(index);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((name != <span class=\"keyword\">null</span> &amp;&amp; name.equals(bss.getName()))</span><br><span class=\"line\">                            || (id &gt;= <span class=\"number\">0</span> &amp;&amp; id == bss.mIndex)) &#123;</span><br><span class=\"line\">                        index--;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == mBackStack.size()-<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = mBackStack.size() - <span class=\"number\">1</span>; i &gt; index; i--) &#123;</span><br><span class=\"line\">            records.add(mBackStack.remove(i));</span><br><span class=\"line\">            isRecordPop.add(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>事务从mBackStack回退栈管理集合移出，并加入records用于执行事务，对应的isRecordPop元素设置为true，标记位回退事务，最后执行逆向操作，实现回退。</p>\n<p>→androidx.fragment.app.FragmentManagerImpl#removeRedundantOperationsAndExecute</p>\n<p>→androidx.fragment.app.FragmentManagerImpl#executeOpsTogether</p>\n<p>→androidx.fragment.app.FragmentManager#executeOps</p>\n<p>→androidx.fragment.app.BackStackRecord#executePopOps</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#executeOps</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Run the operations in the BackStackRecords, either to push or pop.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records The list of records whose operations should be run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isRecordPop The direction that these records are being run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> startIndex The index of the first entry in records to run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> endIndex One past the index of the final entry in records to run.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">executeOps</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ArrayList&lt;BackStackRecord&gt; records,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"meta\">@NonNull</span> ArrayList&lt;Boolean&gt; isRecordPop, <span class=\"keyword\">int</span> startIndex, <span class=\"keyword\">int</span> endIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = startIndex; i &lt; endIndex; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BackStackRecord record = records.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isPop = isRecordPop.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isPop) &#123;</span><br><span class=\"line\">            record.bumpBackStackNesting(-<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// Only execute the add operations at the end of</span></span><br><span class=\"line\">            <span class=\"comment\">// all transactions.</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> moveToState = i == (endIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">            record.executePopOps(moveToState);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            record.bumpBackStackNesting(<span class=\"number\">1</span>);</span><br><span class=\"line\">            record.executeOps();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.fragment.app.BackStackRecord#executePopOps</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Reverses the execution of the operations within this transaction. The Fragment states will</span></span><br><span class=\"line\"><span class=\"comment\"> * only be modified if reordering is not allowed.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> moveToState &#123;<span class=\"doctag\">@code</span> true&#125; if added fragments should be moved to their final state</span></span><br><span class=\"line\"><span class=\"comment\"> *                    in ordered transactions</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">executePopOps</span><span class=\"params\">(<span class=\"keyword\">boolean</span> moveToState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> opNum = mOps.size() - <span class=\"number\">1</span>; opNum &gt;= <span class=\"number\">0</span>; opNum--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Op op = mOps.get(opNum);</span><br><span class=\"line\">        Fragment f = op.mFragment;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            f.setPopDirection(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            f.setAnimations(op.mEnterAnim, op.mExitAnim, op.mPopEnterAnim, op.mPopExitAnim);</span><br><span class=\"line\">            f.setNextTransition(FragmentManager.reverseTransit(mTransition));</span><br><span class=\"line\">            <span class=\"comment\">// Reverse the target and source names for pop operations</span></span><br><span class=\"line\">            f.setSharedElementNames(mSharedElementTargetNames, mSharedElementSourceNames);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (op.mCmd) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_ADD:</span><br><span class=\"line\">                mManager.setExitAnimationOrder(f, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                mManager.removeFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_REMOVE:</span><br><span class=\"line\">                mManager.addFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_HIDE:</span><br><span class=\"line\">                mManager.showFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_SHOW:</span><br><span class=\"line\">                mManager.setExitAnimationOrder(f, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                mManager.hideFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_DETACH:</span><br><span class=\"line\">                mManager.attachFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_ATTACH:</span><br><span class=\"line\">                mManager.setExitAnimationOrder(f, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                mManager.detachFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_SET_PRIMARY_NAV:</span><br><span class=\"line\">                mManager.setPrimaryNavigationFragment(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_UNSET_PRIMARY_NAV:</span><br><span class=\"line\">                mManager.setPrimaryNavigationFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_SET_MAX_LIFECYCLE:</span><br><span class=\"line\">                mManager.setMaxLifecycle(f, op.mOldMaxState);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Unknown cmd: &quot;</span> + op.mCmd);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mReorderingAllowed &amp;&amp; op.mCmd != OP_REMOVE &amp;&amp; f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!FragmentManager.USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">                mManager.moveFragmentToExpectedState(f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mReorderingAllowed &amp;&amp; moveToState &amp;&amp; !FragmentManager.USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">        mManager.moveToState(mManager.mCurState, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"BackPressedCallback注册和反注册\"><a href=\"#BackPressedCallback注册和反注册\" class=\"headerlink\" title=\"BackPressedCallback注册和反注册\"></a>BackPressedCallback注册和反注册</h1><p>注册和反注册有些值得揣摩，它和以往的模式略有不同。一般而言，注册和反注册都是提供一对API，add &amp; remove 或者 register &amp; unregister。但这里mOnBackPressedDispatcher只提供addCallback，反注册是mOnBackPressedCallback自己调用cancel 方法实现。</p>\n<h2 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#attachController</span><br><span class=\"line\"><span class=\"meta\">@SuppressLint(&quot;SyntheticAccessor&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attachController</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> FragmentHostCallback&lt;?&gt; host,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"meta\">@NonNull</span> FragmentContainer container, <span class=\"meta\">@Nullable</span> <span class=\"keyword\">final</span> Fragment parent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHost != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Already attached&quot;</span>);</span><br><span class=\"line\">    mHost = host;</span><br><span class=\"line\">    mContainer = container;</span><br><span class=\"line\">    mParent = parent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set up the OnBackPressedCallback</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (host <span class=\"keyword\">instanceof</span> OnBackPressedDispatcherOwner) &#123;</span><br><span class=\"line\">        OnBackPressedDispatcherOwner dispatcherOwner = ((OnBackPressedDispatcherOwner) host);</span><br><span class=\"line\">        mOnBackPressedDispatcher = dispatcherOwner.getOnBackPressedDispatcher();</span><br><span class=\"line\">        LifecycleOwner owner = parent != <span class=\"keyword\">null</span> ? parent : dispatcherOwner;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 注册</span></span><br><span class=\"line\">        mOnBackPressedDispatcher.addCallback(owner, mOnBackPressedCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"反注册\"><a href=\"#反注册\" class=\"headerlink\" title=\"反注册\"></a>反注册</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mDestroyed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    execPendingActions(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    endAnimatingAwayFragments();</span><br><span class=\"line\">    dispatchStateChange(Fragment.INITIALIZING);</span><br><span class=\"line\">    mHost = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    mContainer = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    mParent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mOnBackPressedDispatcher != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mOnBackPressedDispatcher can hold a reference to the host</span></span><br><span class=\"line\">        <span class=\"comment\">// so we need to null it out to prevent memory leaks</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 反注册</span></span><br><span class=\"line\">        mOnBackPressedCallback.remove();</span><br><span class=\"line\">        mOnBackPressedDispatcher = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注册实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.activity.OnBackPressedDispatcher#addCallback(androidx.lifecycle.LifecycleOwner, androidx.activity.OnBackPressedCallback)</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Receive callbacks to a new &#123;<span class=\"doctag\">@link</span> OnBackPressedCallback&#125; when the given</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> LifecycleOwner&#125; is at least &#123;<span class=\"doctag\">@link</span> Lifecycle.State#STARTED started&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * This will automatically call &#123;<span class=\"doctag\">@link</span> #addCallback(OnBackPressedCallback)&#125; and</span></span><br><span class=\"line\"><span class=\"comment\"> * remove the callback as the lifecycle state changes.</span></span><br><span class=\"line\"><span class=\"comment\"> * As a corollary, if your lifecycle is already at least</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> Lifecycle.State#STARTED started&#125;, calling this method will result in an immediate</span></span><br><span class=\"line\"><span class=\"comment\"> * call to &#123;<span class=\"doctag\">@link</span> #addCallback(OnBackPressedCallback)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * When the &#123;<span class=\"doctag\">@link</span> LifecycleOwner&#125; is &#123;<span class=\"doctag\">@link</span> Lifecycle.State#DESTROYED destroyed&#125;, it will</span></span><br><span class=\"line\"><span class=\"comment\"> * automatically be removed from the list of callbacks. The only time you would need to</span></span><br><span class=\"line\"><span class=\"comment\"> * manually call &#123;<span class=\"doctag\">@link</span> OnBackPressedCallback#remove()&#125; is if</span></span><br><span class=\"line\"><span class=\"comment\"> * you&#x27;d like to remove the callback prior to destruction of the associated lifecycle.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If the Lifecycle is already &#123;<span class=\"doctag\">@link</span> Lifecycle.State#DESTROYED destroyed&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * when this method is called, the callback will not be added.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> owner The LifecycleOwner which controls when the callback should be invoked</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onBackPressedCallback The callback to add</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #onBackPressed()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressLint(&quot;LambdaLast&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addCallback</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner owner,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"meta\">@NonNull</span> OnBackPressedCallback onBackPressedCallback)</span> </span>&#123;</span><br><span class=\"line\">    Lifecycle lifecycle = owner.getLifecycle();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lifecycle.getCurrentState() == Lifecycle.State.DESTROYED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 注册 action2</span></span><br><span class=\"line\">    onBackPressedCallback.addCancellable(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> LifecycleOnBackPressedCancellable(lifecycle, onBackPressedCallback));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>onBackPressedCallback的注册委托给LifecycleOnBackPressedCancellable，同时，持有LifecycleOnBackPressedCancellable的实例引用，但反注册时，onBackPressedCallback调用cancel方法，通知LifecycleOnBackPressedCancellable实例反注册。也就是A 向C注册，其实是委托给B实现注册，反注册通过A持有B的引用，也由B负责完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleOnBackPressedCancellable</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleEventObserver</span>,</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">Cancellable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lifecycle mLifecycle;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> OnBackPressedCallback mOnBackPressedCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Cancellable mCurrentCancellable;</span><br><span class=\"line\"></span><br><span class=\"line\">    LifecycleOnBackPressedCancellable(<span class=\"meta\">@NonNull</span> Lifecycle lifecycle,</span><br><span class=\"line\">            <span class=\"meta\">@NonNull</span> OnBackPressedCallback onBackPressedCallback) &#123;</span><br><span class=\"line\">        mLifecycle = lifecycle;</span><br><span class=\"line\">        mOnBackPressedCallback = onBackPressedCallback;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 注册 action1</span></span><br><span class=\"line\">        lifecycle.addObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner source,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event == Lifecycle.Event.ON_START) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 实际注册</span></span><br><span class=\"line\">            mCurrentCancellable = addCancellableCallback(mOnBackPressedCallback);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event == Lifecycle.Event.ON_STOP) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Should always be non-null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCurrentCancellable != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mCurrentCancellable.cancel();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class=\"line\">            cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 反注册 action1</span></span><br><span class=\"line\">        mLifecycle.removeObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 反注册 action2</span></span><br><span class=\"line\">        mOnBackPressedCallback.removeCancellable(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCurrentCancellable != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 实际反注册</span></span><br><span class=\"line\">            mCurrentCancellable.cancel();</span><br><span class=\"line\">            mCurrentCancellable = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.activity.OnBackPressedDispatcher#addCancellableCallback</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Internal implementation of &#123;<span class=\"doctag\">@link</span> #addCallback(OnBackPressedCallback)&#125; that gives</span></span><br><span class=\"line\"><span class=\"comment\"> * access to the &#123;<span class=\"doctag\">@link</span> Cancellable&#125; that specifically removes this callback from</span></span><br><span class=\"line\"><span class=\"comment\"> * the dispatcher without relying on &#123;<span class=\"doctag\">@link</span> OnBackPressedCallback#remove()&#125; which</span></span><br><span class=\"line\"><span class=\"comment\"> * is what external developers should be using.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onBackPressedCallback The callback to add</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> a &#123;<span class=\"doctag\">@link</span> Cancellable&#125; which can be used to &#123;<span class=\"doctag\">@link</span> Cancellable#cancel() cancel&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * the callback and remove it from the set of OnBackPressedCallbacks.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class=\"comment\">/* synthetic access */</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\">Cancellable <span class=\"title\">addCancellableCallback</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> OnBackPressedCallback onBackPressedCallback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// start后，实际注册进callback列表</span></span><br><span class=\"line\">\t\tmOnBackPressedCallbacks.add(onBackPressedCallback);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 建立OnBackPressedCancellable实例 与onBackPressedCallback的双向引用并返回</span></span><br><span class=\"line\">    OnBackPressedCancellable cancellable = <span class=\"keyword\">new</span> OnBackPressedCancellable(onBackPressedCallback);</span><br><span class=\"line\">    onBackPressedCallback.addCancellable(cancellable);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cancellable;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OnBackPressedCancellable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cancellable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> OnBackPressedCallback mOnBackPressedCallback;</span><br><span class=\"line\">    OnBackPressedCancellable(OnBackPressedCallback onBackPressedCallback) &#123;</span><br><span class=\"line\">        mOnBackPressedCallback = onBackPressedCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// stop后，实际反注册</span></span><br><span class=\"line\">        mOnBackPressedCallbacks.remove(mOnBackPressedCallback);</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 断开引用</span></span><br><span class=\"line\">        mOnBackPressedCallback.removeCancellable(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"remove-amp-detach-Fragment差别\"><a href=\"#remove-amp-detach-Fragment差别\" class=\"headerlink\" title=\"remove &amp; detach Fragment差别\"></a>remove &amp; detach Fragment差别</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeFragment</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;remove: &quot;</span> + fragment + <span class=\"string\">&quot; nesting=&quot;</span> + fragment.mBackStackNesting);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> inactive = !fragment.isInBackStack();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached || inactive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mAdded) &#123;</span><br><span class=\"line\">            mAdded.remove(fragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">            mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fragment.mAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        fragment.mRemoving = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">detachFragment</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;detach: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached) &#123;</span><br><span class=\"line\">        fragment.mDetached = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragment.mAdded) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We are not already in back stack, so need to remove the fragment.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;remove from detach: &quot;</span> + fragment);</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mAdded) &#123;</span><br><span class=\"line\">                mAdded.remove(fragment);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">                mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fragment.mAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>都是移出mAdded集合，并将mAdded置为false，区别在更新的标记不同mRemoving &amp; mDetached。在FragmentManager同步状态调用时，有对remove &amp; detach的状态同步。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Changes the state of the fragment manager to &#123;<span class=\"doctag\">@code</span> newState&#125;. If the fragment manager</span></span><br><span class=\"line\"><span class=\"comment\"> * changes state or &#123;<span class=\"doctag\">@code</span> always&#125; is &#123;<span class=\"doctag\">@code</span> true&#125;, any fragments within it have their</span></span><br><span class=\"line\"><span class=\"comment\"> * states updated as well.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> newState The new state for the fragment manager</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> always If &#123;<span class=\"doctag\">@code</span> true&#125;, all fragments update their state, even</span></span><br><span class=\"line\"><span class=\"comment\"> *               if &#123;<span class=\"doctag\">@code</span> newState&#125; matches the current fragment manager&#x27;s state.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(<span class=\"keyword\">int</span> newState, <span class=\"keyword\">boolean</span> always)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHost == <span class=\"keyword\">null</span> &amp;&amp; newState != Fragment.INITIALIZING) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;No activity&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!always &amp;&amp; newState == mCurState) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mCurState = newState;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mActive != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Must add them in the proper order. mActive fragments may be out of order</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Fragment add &amp; attach 后的状态同步</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> numAdded = mAdded.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numAdded; i++) &#123;</span><br><span class=\"line\">            Fragment f = mAdded.get(i);</span><br><span class=\"line\">            moveFragmentToExpectedState(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Now iterate through all active fragments. These will include those that are removed</span></span><br><span class=\"line\">        <span class=\"comment\">// and detached.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> numActive = mActive.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numActive; i++) &#123;</span><br><span class=\"line\">            Fragment f = mActive.valueAt(i);</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// Fragment 激活后执行remove 或者 detach，同步状态。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span> &amp;&amp; (f.mRemoving || f.mDetached) &amp;&amp; !f.mIsNewlyAdded) &#123;</span><br><span class=\"line\">                moveFragmentToExpectedState(f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        startPendingDeferredFragments();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mNeedMenuInvalidate &amp;&amp; mHost != <span class=\"keyword\">null</span> &amp;&amp; mCurState == Fragment.RESUMED) &#123;</span><br><span class=\"line\">            mHost.onSupportInvalidateOptionsMenu();</span><br><span class=\"line\">            mNeedMenuInvalidate = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Moves a fragment to its expected final state or the fragment manager&#x27;s state, depending</span></span><br><span class=\"line\"><span class=\"comment\"> * on whether the fragment manager&#x27;s state is raised properly.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> f The fragment to change.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveFragmentToExpectedState</span><span class=\"params\">(Fragment f)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mActive.containsKey(f.mWho)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (DEBUG) &#123;</span><br><span class=\"line\">            Log.v(TAG, <span class=\"string\">&quot;Ignoring moving &quot;</span> + f + <span class=\"string\">&quot; to state &quot;</span> + mCurState</span><br><span class=\"line\">                    + <span class=\"string\">&quot;since it is not added to &quot;</span> + <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextState = mCurState;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f.mRemoving) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f.isInBackStack()) &#123;</span><br><span class=\"line\">            nextState = Math.min(nextState, Fragment.CREATED);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            nextState = Math.min(nextState, Fragment.INITIALIZING);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    moveToState(f, nextState, f.getNextTransition(), f.getNextTransitionStyle(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于Remove如果nextState 是CREATED，Fragment只会<code>f.performDestroyView()</code>，但如果是INITIALIZING，分两种情况：</p>\n<ol>\n<li>不在回退栈，执行<code>f.performDestroy()</code>;</li>\n<li>在回退栈，执行<code>f.performDetach()</code>;并<code>makeInactive(f);</code></li>\n</ol>\n<p>对于detach，nextState是CREATED，也即只执行<code>f.performDestroyView()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;ReferenceEquality&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(Fragment f, <span class=\"keyword\">int</span> newState, <span class=\"keyword\">int</span> transit, <span class=\"keyword\">int</span> transitionStyle,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"keyword\">boolean</span> keepActive)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fragments that are not currently added will sit in the onCreate() state.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((!f.mAdded || f.mDetached) &amp;&amp; newState &gt; Fragment.CREATED) &#123;</span><br><span class=\"line\">        newState = Fragment.CREATED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"add-amp-attach-Fragment区别\"><a href=\"#add-amp-attach-Fragment区别\" class=\"headerlink\" title=\"add &amp; attach Fragment区别\"></a>add &amp; attach Fragment区别</h1><p>由于addFragment 有activate调用，fragment 已经在mActive映射里，允许状态同步，但attach没有activate 调用，于是状态不同步。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Moves a fragment to its expected final state or the fragment manager&#x27;s state, depending</span></span><br><span class=\"line\"><span class=\"comment\"> * on whether the fragment manager&#x27;s state is raised properly.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> f The fragment to change.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveFragmentToExpectedState</span><span class=\"params\">(Fragment f)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mActive.containsKey(f.mWho)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (DEBUG) &#123;</span><br><span class=\"line\">            Log.v(TAG, <span class=\"string\">&quot;Ignoring moving &quot;</span> + f + <span class=\"string\">&quot; to state &quot;</span> + mCurState</span><br><span class=\"line\">                    + <span class=\"string\">&quot;since it is not added to &quot;</span> + <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextState = mCurState;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f.mRemoving) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f.isInBackStack()) &#123;</span><br><span class=\"line\">            nextState = Math.min(nextState, Fragment.CREATED);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            nextState = Math.min(nextState, Fragment.INITIALIZING);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    moveToState(f, nextState, f.getNextTransition(), f.getNextTransitionStyle(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFragment</span><span class=\"params\">(Fragment fragment, <span class=\"keyword\">boolean</span> moveToStateNow)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;add: &quot;</span> + fragment);</span><br><span class=\"line\">    **makeActive(fragment);<span class=\"comment\">// 这是主要区别**</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mDetached) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mAdded.contains(fragment)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Fragment already added: &quot;</span> + fragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mAdded) &#123;</span><br><span class=\"line\">            mAdded.add(fragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fragment.mAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        fragment.mRemoving = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragment.mView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragment.mHiddenChanged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">            mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (moveToStateNow) &#123;</span><br><span class=\"line\">            moveToState(fragment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attachFragment</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;attach: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fragment.mDetached) &#123;</span><br><span class=\"line\">        fragment.mDetached = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!fragment.mAdded) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mAdded.contains(fragment)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Fragment already added: &quot;</span> + fragment);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;add from attach: &quot;</span> + fragment);</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mAdded) &#123;</span><br><span class=\"line\">                mAdded.add(fragment);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fragment.mAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isMenuAvailable(fragment)) &#123;</span><br><span class=\"line\">                mNeedMenuInvalidate = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Show和hide-Fragment区别\"><a href=\"#Show和hide-Fragment区别\" class=\"headerlink\" title=\"Show和hide Fragment区别\"></a>Show和hide Fragment区别</h1><p>首先，更新mHidden标记。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Marks a fragment as hidden to be later animated in with</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #completeShowHideFragment(Fragment)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> fragment The fragment to be shown.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hideFragment</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;hide: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!fragment.mHidden) &#123;</span><br><span class=\"line\">        fragment.mHidden = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Toggle hidden changed so that if a fragment goes through show/hide/show</span></span><br><span class=\"line\">        <span class=\"comment\">// it doesn&#x27;t go through the animation.</span></span><br><span class=\"line\">        fragment.mHiddenChanged = !fragment.mHiddenChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Marks a fragment as shown to be later animated in with</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #completeShowHideFragment(Fragment)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> fragment The fragment to be shown.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showFragment</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;show: &quot;</span> + fragment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fragment.mHidden) &#123;</span><br><span class=\"line\">        fragment.mHidden = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Toggle hidden changed so that if a fragment goes through show/hide/show</span></span><br><span class=\"line\">        <span class=\"comment\">// it doesn&#x27;t go through the animation.</span></span><br><span class=\"line\">        fragment.mHiddenChanged = !fragment.mHiddenChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>故事并没有就此结束，看下这个标记如何使用。</p>\n<p>首先，hidden后，Fragment下的View为Gone，不贡献视图。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentStateManager#<span class=\"function\">moveToExpectedState</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">if</span> <span class=\"params\">(FragmentManager.USE_STATE_MANAGER &amp;&amp; mFragment.mHiddenChanged)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mFragment.mView != <span class=\"keyword\">null</span> &amp;&amp; mFragment.mContainer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Get the controller and enqueue the show/hide</span></span><br><span class=\"line\">        SpecialEffectsController controller = SpecialEffectsController</span><br><span class=\"line\">                .getOrCreateController(mFragment.mContainer,</span><br><span class=\"line\">                        mFragment.getParentFragmentManager());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFragment.mHidden) &#123;</span><br><span class=\"line\">            controller.enqueueHide(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            controller.enqueueShow(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mFragment.mFragmentManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mFragment.mFragmentManager.invalidateMenuForFragment(mFragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mFragment.mHiddenChanged = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    mFragment.onHiddenChanged(mFragment.mHidden);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其次，hidden后，Fragment不再贡献菜单项</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">dispatchPrepareOptionsMenu</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">dispatchPrepareOptionsMenu</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Menu menu)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mCurState &lt; Fragment.CREATED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> show = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Fragment f : mFragmentStore.getFragments()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isParentMenuVisible(f) &amp;&amp; f.performPrepareOptionsMenu(menu)) &#123;</span><br><span class=\"line\">                show = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> show;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.fragment.app.Fragment#<span class=\"function\">performPrepareOptionsMenu</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">performPrepareOptionsMenu</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Menu menu)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> show = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mHidden) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mHasMenu &amp;&amp; mMenuVisible) &#123;</span><br><span class=\"line\">            show = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            onPrepareOptionsMenu(menu);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        show |= mChildFragmentManager.dispatchPrepareOptionsMenu(menu);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> show;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显隐切换完成后，androidx.fragment.app.Fragment#onHiddenChanged会得到通知调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#completeShowHideFragment</span><br><span class=\"line\">androidx.fragment.app.FragmentStateManager#moveToExpectedState</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"FragmentManager-派发生命周期方法\"><a href=\"#FragmentManager-派发生命周期方法\" class=\"headerlink\" title=\"FragmentManager 派发生命周期方法\"></a>FragmentManager 派发生命周期方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">ComponentActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> FragmentController mFragments = FragmentController.createController(</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">new</span> HostCallbacks());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>mFragments 负责Activity 生命周期方法，派发给FragmentManager，再遍历逐个派发给旗下的Fragment。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Perform initialization of all fragments.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    mFragments.attachHost(<span class=\"keyword\">null</span> <span class=\"comment\">/*parent*/</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (savedInstanceState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class=\"line\">        mFragments.restoreSaveState(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class=\"line\">    mFragments.dispatchCreate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Moves all Fragments managed by the controller&#x27;s FragmentManager</span></span><br><span class=\"line\"><span class=\"comment\"> * into the create state.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Call when Fragments should be created.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> Fragment#onCreate(Bundle)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mHost.mFragmentManager.dispatchCreate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>dispatchCreate 终导致FragmentManagerImpl的当前状态<code>mCurState</code> 变更。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">dispatchCreate</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mStateSaved = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    mStopped = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    mNonConfig.setIsStateSaved(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    dispatchStateChange(Fragment.CREATED);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">dispatchStateChange</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchStateChange</span><span class=\"params\">(<span class=\"keyword\">int</span> nextState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        mExecutingActions = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        mFragmentStore.dispatchStateChange(nextState);</span><br><span class=\"line\">        moveToState(nextState, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">            Set&lt;SpecialEffectsController&gt; controllers = collectAllSpecialEffectsController();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (SpecialEffectsController controller : controllers) &#123;</span><br><span class=\"line\">                controller.forceCompleteAllOperations();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mExecutingActions = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    execPendingActions(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步生命周期状态给mActive内fragment集合</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchStateChange</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (FragmentStateManager fragmentStateManager : mActive.values()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragmentStateManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragmentStateManager.setFragmentManagerState(state);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#moveToState(<span class=\"keyword\">int</span>, <span class=\"keyword\">boolean</span>)</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Changes the state of the fragment manager to &#123;<span class=\"doctag\">@code</span> newState&#125;. If the fragment manager</span></span><br><span class=\"line\"><span class=\"comment\"> * changes state or &#123;<span class=\"doctag\">@code</span> always&#125; is &#123;<span class=\"doctag\">@code</span> true&#125;, any fragments within it have their</span></span><br><span class=\"line\"><span class=\"comment\"> * states updated as well.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> newState The new state for the fragment manager</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> always If &#123;<span class=\"doctag\">@code</span> true&#125;, all fragments update their state, even</span></span><br><span class=\"line\"><span class=\"comment\"> *               if &#123;<span class=\"doctag\">@code</span> newState&#125; matches the current fragment manager&#x27;s state.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(<span class=\"keyword\">int</span> newState, <span class=\"keyword\">boolean</span> always)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHost == <span class=\"keyword\">null</span> &amp;&amp; newState != Fragment.INITIALIZING) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;No activity&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!always &amp;&amp; newState == mCurState) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mCurState = newState;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">        mFragmentStore.moveToExpectedState();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Must add them in the proper order. mActive fragments may be out of order</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Fragment f : mFragmentStore.getFragments()) &#123;</span><br><span class=\"line\">            moveFragmentToExpectedState(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Now iterate through all active fragments. These will include those that are removed</span></span><br><span class=\"line\">        <span class=\"comment\">// and detached.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (FragmentStateManager fragmentStateManager :</span><br><span class=\"line\">                mFragmentStore.getActiveFragmentStateManagers()) &#123;</span><br><span class=\"line\">            Fragment f = fragmentStateManager.getFragment();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!f.mIsNewlyAdded) &#123;</span><br><span class=\"line\">                moveFragmentToExpectedState(f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (beingRemoved) &#123;</span><br><span class=\"line\">                mFragmentStore.makeInactive(fragmentStateManager);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    startPendingDeferredFragments();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mNeedMenuInvalidate &amp;&amp; mHost != <span class=\"keyword\">null</span> &amp;&amp; mCurState == Fragment.RESUMED) &#123;</span><br><span class=\"line\">        mHost.onSupportInvalidateOptionsMenu();</span><br><span class=\"line\">        mNeedMenuInvalidate = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#<span class=\"function\">moveFragmentToExpectedState</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveToExpectedState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Must add them in the proper order. mActive fragments may be out of order</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Fragment f : mAdded) &#123;</span><br><span class=\"line\">        FragmentStateManager fragmentStateManager = mActive.get(f.mWho);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragmentStateManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragmentStateManager.moveToExpectedState();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Now iterate through all active fragments. These will include those that are removed</span></span><br><span class=\"line\">    <span class=\"comment\">// and detached.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (FragmentStateManager fragmentStateManager : mActive.values()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fragmentStateManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fragmentStateManager.moveToExpectedState();</span><br><span class=\"line\"></span><br><span class=\"line\">            Fragment f = fragmentStateManager.getFragment();</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (beingRemoved) &#123;</span><br><span class=\"line\">                makeInactive(fragmentStateManager);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意只有在mActive集合的Fragment才可以<code>moveToExpectedState</code> ，attach阶段的Fragment 并未进入此集合，add之后才进入，此后Fragment接收生命周期方法派发。</p>\n<h1 id=\"BackStack\"><a href=\"#BackStack\" class=\"headerlink\" title=\"BackStack\"></a>BackStack</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implementation of &#123;<span class=\"doctag\">@link</span> FragmentManagerImpl.OpGenerator&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * This operation is added to the list of pending actions during &#123;<span class=\"doctag\">@link</span> #commit()&#125;, and</span></span><br><span class=\"line\"><span class=\"comment\"> * will be executed on the UI thread to run this FragmentTransaction.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records Modified to add this BackStackRecord</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isRecordPop Modified to add a false (this isn&#x27;t a pop)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true always because the records and isRecordPop will always be changed</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">generateOps</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isRecordPop)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FragmentManagerImpl.DEBUG) &#123;</span><br><span class=\"line\">        Log.v(TAG, <span class=\"string\">&quot;Run: &quot;</span> + <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    records.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    isRecordPop.add(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAddToBackStack) &#123;</span><br><span class=\"line\">        mManager.addBackStackState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBackStackState</span><span class=\"params\">(BackStackRecord state)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mBackStack == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mBackStack = <span class=\"keyword\">new</span> ArrayList&lt;BackStackRecord&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mBackStack.add(state);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把当前backStackRecord 即事务加入mBackStack 集合。此处可以猜想：当接收back事件时，activity先派发back事件给FragmentManager，如果mBackStack存在元素，则将列表末尾的事务revert，并移出集合，指针向左偏移一位，并直接返回。如果FragmentManager不回应back event，那么由Activity继续回应。我们看下具体实现是否这样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.activity.ComponentActivity#onBackPressed</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Called when the activity has detected the user&#x27;s press of the back</span></span><br><span class=\"line\"><span class=\"comment\"> * key. The &#123;<span class=\"doctag\">@link</span> #getOnBackPressedDispatcher() OnBackPressedDispatcher&#125; will be given a</span></span><br><span class=\"line\"><span class=\"comment\"> * chance to handle the back button before the default behavior of</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> android.app.Activity#onBackPressed()&#125; is invoked.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #getOnBackPressedDispatcher()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBackPressed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mOnBackPressedDispatcher.onBackPressed();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> OnBackPressedDispatcher mOnBackPressedDispatcher =</span><br><span class=\"line\">      <span class=\"keyword\">new</span> OnBackPressedDispatcher(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">              ComponentActivity.<span class=\"keyword\">super</span>.onBackPressed();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.activity.OnBackPressedDispatcher#onBackPressed</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Trigger a call to the currently added &#123;<span class=\"doctag\">@link</span> OnBackPressedCallback callbacks&#125; in reverse</span></span><br><span class=\"line\"><span class=\"comment\"> * order in which they were added. Only if the most recently added callback is not</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> OnBackPressedCallback#isEnabled() enabled&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * will any previously added callback be called.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * It is strongly recommended to call &#123;<span class=\"doctag\">@link</span> #hasEnabledCallbacks()&#125; prior to calling</span></span><br><span class=\"line\"><span class=\"comment\"> * this method to determine if there are any enabled callbacks that will be triggered</span></span><br><span class=\"line\"><span class=\"comment\"> * by this method as calling this method.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBackPressed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;OnBackPressedCallback&gt; iterator =</span><br><span class=\"line\">            mOnBackPressedCallbacks.descendingIterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">        OnBackPressedCallback callback = iterator.next();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callback.isEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 如果回调回应back事件，则返回</span></span><br><span class=\"line\">            callback.handleOnBackPressed();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// FragmentManager 没回应，则继续走这里</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mFallbackOnBackPressed != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 为OnBackPressedDispatcher初始化时，传入的回调方法，其实现是</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 调用Activity的onBackPressed()</span></span><br><span class=\"line\">        mFallbackOnBackPressed.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>FragmentManager如何注册callback</p>\n<p>→androidx.fragment.app.FragmentActivity#init</p>\n<p>→androidx.fragment.app.FragmentController#attachHost</p>\n<p>→androidx.fragment.app.FragmentManager#attachController</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressLint(&quot;SyntheticAccessor&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attachController</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> FragmentHostCallback&lt;?&gt; host,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"meta\">@NonNull</span> FragmentContainer container, <span class=\"meta\">@Nullable</span> <span class=\"keyword\">final</span> Fragment parent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHost != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Already attached&quot;</span>);</span><br><span class=\"line\">    mHost = host;</span><br><span class=\"line\">    mContainer = container;</span><br><span class=\"line\">    mParent = parent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Add a FragmentOnAttachListener to the parent fragment / host to support</span></span><br><span class=\"line\">    <span class=\"comment\">// backward compatibility with the deprecated onAttachFragment() APIs</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        addFragmentOnAttachListener(<span class=\"keyword\">new</span> FragmentOnAttachListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAttachFragment</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> FragmentManager fragmentManager,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                    <span class=\"meta\">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">                parent.onAttachFragment(fragment);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (host <span class=\"keyword\">instanceof</span> FragmentOnAttachListener) &#123;</span><br><span class=\"line\">        addFragmentOnAttachListener((FragmentOnAttachListener) host);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Since the callback depends on us being the primary navigation fragment,</span></span><br><span class=\"line\">        <span class=\"comment\">// update our callback now that we have a parent so that we have the correct</span></span><br><span class=\"line\">        <span class=\"comment\">// state by default</span></span><br><span class=\"line\">        updateOnBackPressedCallbackEnabled();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Set up the OnBackPressedCallback</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (host <span class=\"keyword\">instanceof</span> OnBackPressedDispatcherOwner) &#123;</span><br><span class=\"line\">        OnBackPressedDispatcherOwner dispatcherOwner = ((OnBackPressedDispatcherOwner) host);</span><br><span class=\"line\">        mOnBackPressedDispatcher = dispatcherOwner.getOnBackPressedDispatcher();</span><br><span class=\"line\">        LifecycleOwner owner = parent != <span class=\"keyword\">null</span> ? parent : dispatcherOwner;</span><br><span class=\"line\">        mOnBackPressedDispatcher.addCallback(owner, mOnBackPressedCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 代码省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> OnBackPressedCallback mOnBackPressedCallback =</span><br><span class=\"line\">    <span class=\"keyword\">new</span> OnBackPressedCallback(<span class=\"keyword\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleOnBackPressed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            FragmentManager.<span class=\"keyword\">this</span>.handleOnBackPressed();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#handleOnBackPressed</span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class=\"comment\">/* synthetic access */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleOnBackPressed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// First, execute any pending actions to make sure we&#x27;re in an</span></span><br><span class=\"line\">    <span class=\"comment\">// up to date view of the world just in case anyone is queuing</span></span><br><span class=\"line\">    <span class=\"comment\">// up transactions that change the back stack then immediately</span></span><br><span class=\"line\">    <span class=\"comment\">// calling onBackPressed()</span></span><br><span class=\"line\">    execPendingActions(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mOnBackPressedCallback.isEnabled()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We still have a back stack, so we can pop</span></span><br><span class=\"line\">        popBackStackImmediate();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Sigh. Due to FragmentManager&#x27;s asynchronicity, we can</span></span><br><span class=\"line\">        <span class=\"comment\">// get into cases where we *think* we can handle the back</span></span><br><span class=\"line\">        <span class=\"comment\">// button but because of frame perfect dispatch, we fell</span></span><br><span class=\"line\">        <span class=\"comment\">// on our face. Since our callback is disabled, we can</span></span><br><span class=\"line\">        <span class=\"comment\">// re-trigger the onBackPressed() to dispatch to the next</span></span><br><span class=\"line\">        <span class=\"comment\">// enabled callback</span></span><br><span class=\"line\">        mOnBackPressedDispatcher.onBackPressed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看fragmentManager.popBackStackImmediate()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">popBackStackImmediate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    checkStateLoss();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> popBackStackImmediate(<span class=\"keyword\">null</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Used by all public popBackStackImmediate methods, this executes pending transactions and</span></span><br><span class=\"line\"><span class=\"comment\"> * returns true if the pop action did anything, regardless of what other pending</span></span><br><span class=\"line\"><span class=\"comment\"> * transactions did.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true if the pop operation did anything or false otherwise.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">popBackStackImmediate</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> id, <span class=\"keyword\">int</span> flags)</span> </span>&#123;</span><br><span class=\"line\">    execPendingActions();</span><br><span class=\"line\">    ensureExecReady(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mPrimaryNav != <span class=\"keyword\">null</span> <span class=\"comment\">// We have a primary nav fragment</span></span><br><span class=\"line\">            &amp;&amp; id &lt; <span class=\"number\">0</span> <span class=\"comment\">// No valid id (since they&#x27;re local)</span></span><br><span class=\"line\">            &amp;&amp; name == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// no name to pop to (since they&#x27;re local)</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> FragmentManager childManager = mPrimaryNav.getChildFragmentManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childManager.popBackStackImmediate()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We did something, just not to this specific FragmentManager. Return true.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> executePop = popBackStackState(mTmpRecords, mTmpIsPop, name, id, flags);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executePop) &#123;</span><br><span class=\"line\">        mExecutingActions = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            cleanupExec();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    updateOnBackPressedCallbackEnabled();</span><br><span class=\"line\">    doPendingDeferredStart();</span><br><span class=\"line\">    burpActive();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> executePop;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>popBackStackState获取回退事务集合，交由removeRedundantOperationsAndExecute执行事务回退。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">popBackStackState</span><span class=\"params\">(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isRecordPop,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                              String name, <span class=\"keyword\">int</span> id, <span class=\"keyword\">int</span> flags)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mBackStack == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 无参数回退，只回退一个事务</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span> &amp;&amp; id &lt; <span class=\"number\">0</span> &amp;&amp; (flags &amp; POP_BACK_STACK_INCLUSIVE) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> last = mBackStack.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (last &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        records.add(mBackStack.remove(last));</span><br><span class=\"line\">        isRecordPop.add(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 指定id或者backStack name回退，可以一次回退多个事务。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name != <span class=\"keyword\">null</span> || id &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If a name or ID is specified, look for that place in</span></span><br><span class=\"line\">            <span class=\"comment\">// the stack.</span></span><br><span class=\"line\">            index = mBackStack.size()-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (index &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                BackStackRecord bss = mBackStack.get(index);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (name != <span class=\"keyword\">null</span> &amp;&amp; name.equals(bss.getName())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (id &gt;= <span class=\"number\">0</span> &amp;&amp; id == bss.mIndex) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((flags&amp;POP_BACK_STACK_INCLUSIVE) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">                <span class=\"comment\">// Consume all following entries that match.</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (index &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    BackStackRecord bss = mBackStack.get(index);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((name != <span class=\"keyword\">null</span> &amp;&amp; name.equals(bss.getName()))</span><br><span class=\"line\">                            || (id &gt;= <span class=\"number\">0</span> &amp;&amp; id == bss.mIndex)) &#123;</span><br><span class=\"line\">                        index--;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == mBackStack.size()-<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = mBackStack.size() - <span class=\"number\">1</span>; i &gt; index; i--) &#123;</span><br><span class=\"line\">            records.add(mBackStack.remove(i));</span><br><span class=\"line\">            isRecordPop.add(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>事务从mBackStack回退栈管理集合移出，并加入records用于执行事务，对应的isRecordPop元素设置为true，标记位回退事务，最后执行逆向操作，实现回退。</p>\n<p>→androidx.fragment.app.FragmentManagerImpl#removeRedundantOperationsAndExecute</p>\n<p>→androidx.fragment.app.FragmentManagerImpl#executeOpsTogether</p>\n<p>→androidx.fragment.app.FragmentManager#executeOps</p>\n<p>→androidx.fragment.app.BackStackRecord#executePopOps</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#executeOps</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Run the operations in the BackStackRecords, either to push or pop.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> records The list of records whose operations should be run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isRecordPop The direction that these records are being run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> startIndex The index of the first entry in records to run.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> endIndex One past the index of the final entry in records to run.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">executeOps</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ArrayList&lt;BackStackRecord&gt; records,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"meta\">@NonNull</span> ArrayList&lt;Boolean&gt; isRecordPop, <span class=\"keyword\">int</span> startIndex, <span class=\"keyword\">int</span> endIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = startIndex; i &lt; endIndex; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BackStackRecord record = records.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isPop = isRecordPop.get(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isPop) &#123;</span><br><span class=\"line\">            record.bumpBackStackNesting(-<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// Only execute the add operations at the end of</span></span><br><span class=\"line\">            <span class=\"comment\">// all transactions.</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> moveToState = i == (endIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">            record.executePopOps(moveToState);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            record.bumpBackStackNesting(<span class=\"number\">1</span>);</span><br><span class=\"line\">            record.executeOps();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.fragment.app.BackStackRecord#executePopOps</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Reverses the execution of the operations within this transaction. The Fragment states will</span></span><br><span class=\"line\"><span class=\"comment\"> * only be modified if reordering is not allowed.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> moveToState &#123;<span class=\"doctag\">@code</span> true&#125; if added fragments should be moved to their final state</span></span><br><span class=\"line\"><span class=\"comment\"> *                    in ordered transactions</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">executePopOps</span><span class=\"params\">(<span class=\"keyword\">boolean</span> moveToState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> opNum = mOps.size() - <span class=\"number\">1</span>; opNum &gt;= <span class=\"number\">0</span>; opNum--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Op op = mOps.get(opNum);</span><br><span class=\"line\">        Fragment f = op.mFragment;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            f.setPopDirection(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            f.setAnimations(op.mEnterAnim, op.mExitAnim, op.mPopEnterAnim, op.mPopExitAnim);</span><br><span class=\"line\">            f.setNextTransition(FragmentManager.reverseTransit(mTransition));</span><br><span class=\"line\">            <span class=\"comment\">// Reverse the target and source names for pop operations</span></span><br><span class=\"line\">            f.setSharedElementNames(mSharedElementTargetNames, mSharedElementSourceNames);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (op.mCmd) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_ADD:</span><br><span class=\"line\">                mManager.setExitAnimationOrder(f, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                mManager.removeFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_REMOVE:</span><br><span class=\"line\">                mManager.addFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_HIDE:</span><br><span class=\"line\">                mManager.showFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_SHOW:</span><br><span class=\"line\">                mManager.setExitAnimationOrder(f, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                mManager.hideFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_DETACH:</span><br><span class=\"line\">                mManager.attachFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_ATTACH:</span><br><span class=\"line\">                mManager.setExitAnimationOrder(f, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                mManager.detachFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_SET_PRIMARY_NAV:</span><br><span class=\"line\">                mManager.setPrimaryNavigationFragment(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_UNSET_PRIMARY_NAV:</span><br><span class=\"line\">                mManager.setPrimaryNavigationFragment(f);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> OP_SET_MAX_LIFECYCLE:</span><br><span class=\"line\">                mManager.setMaxLifecycle(f, op.mOldMaxState);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Unknown cmd: &quot;</span> + op.mCmd);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mReorderingAllowed &amp;&amp; op.mCmd != OP_REMOVE &amp;&amp; f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!FragmentManager.USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">                mManager.moveFragmentToExpectedState(f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mReorderingAllowed &amp;&amp; moveToState &amp;&amp; !FragmentManager.USE_STATE_MANAGER) &#123;</span><br><span class=\"line\">        mManager.moveToState(mManager.mCurState, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"BackPressedCallback注册和反注册\"><a href=\"#BackPressedCallback注册和反注册\" class=\"headerlink\" title=\"BackPressedCallback注册和反注册\"></a>BackPressedCallback注册和反注册</h1><p>注册和反注册有些值得揣摩，它和以往的模式略有不同。一般而言，注册和反注册都是提供一对API，add &amp; remove 或者 register &amp; unregister。但这里mOnBackPressedDispatcher只提供addCallback，反注册是mOnBackPressedCallback自己调用cancel 方法实现。</p>\n<h2 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentManager#attachController</span><br><span class=\"line\"><span class=\"meta\">@SuppressLint(&quot;SyntheticAccessor&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attachController</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> FragmentHostCallback&lt;?&gt; host,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"meta\">@NonNull</span> FragmentContainer container, <span class=\"meta\">@Nullable</span> <span class=\"keyword\">final</span> Fragment parent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHost != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Already attached&quot;</span>);</span><br><span class=\"line\">    mHost = host;</span><br><span class=\"line\">    mContainer = container;</span><br><span class=\"line\">    mParent = parent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set up the OnBackPressedCallback</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (host <span class=\"keyword\">instanceof</span> OnBackPressedDispatcherOwner) &#123;</span><br><span class=\"line\">        OnBackPressedDispatcherOwner dispatcherOwner = ((OnBackPressedDispatcherOwner) host);</span><br><span class=\"line\">        mOnBackPressedDispatcher = dispatcherOwner.getOnBackPressedDispatcher();</span><br><span class=\"line\">        LifecycleOwner owner = parent != <span class=\"keyword\">null</span> ? parent : dispatcherOwner;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 注册</span></span><br><span class=\"line\">        mOnBackPressedDispatcher.addCallback(owner, mOnBackPressedCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"反注册\"><a href=\"#反注册\" class=\"headerlink\" title=\"反注册\"></a>反注册</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mDestroyed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    execPendingActions(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    endAnimatingAwayFragments();</span><br><span class=\"line\">    dispatchStateChange(Fragment.INITIALIZING);</span><br><span class=\"line\">    mHost = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    mContainer = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    mParent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mOnBackPressedDispatcher != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mOnBackPressedDispatcher can hold a reference to the host</span></span><br><span class=\"line\">        <span class=\"comment\">// so we need to null it out to prevent memory leaks</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 反注册</span></span><br><span class=\"line\">        mOnBackPressedCallback.remove();</span><br><span class=\"line\">        mOnBackPressedDispatcher = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注册实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.activity.OnBackPressedDispatcher#addCallback(androidx.lifecycle.LifecycleOwner, androidx.activity.OnBackPressedCallback)</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Receive callbacks to a new &#123;<span class=\"doctag\">@link</span> OnBackPressedCallback&#125; when the given</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> LifecycleOwner&#125; is at least &#123;<span class=\"doctag\">@link</span> Lifecycle.State#STARTED started&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * This will automatically call &#123;<span class=\"doctag\">@link</span> #addCallback(OnBackPressedCallback)&#125; and</span></span><br><span class=\"line\"><span class=\"comment\"> * remove the callback as the lifecycle state changes.</span></span><br><span class=\"line\"><span class=\"comment\"> * As a corollary, if your lifecycle is already at least</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> Lifecycle.State#STARTED started&#125;, calling this method will result in an immediate</span></span><br><span class=\"line\"><span class=\"comment\"> * call to &#123;<span class=\"doctag\">@link</span> #addCallback(OnBackPressedCallback)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * When the &#123;<span class=\"doctag\">@link</span> LifecycleOwner&#125; is &#123;<span class=\"doctag\">@link</span> Lifecycle.State#DESTROYED destroyed&#125;, it will</span></span><br><span class=\"line\"><span class=\"comment\"> * automatically be removed from the list of callbacks. The only time you would need to</span></span><br><span class=\"line\"><span class=\"comment\"> * manually call &#123;<span class=\"doctag\">@link</span> OnBackPressedCallback#remove()&#125; is if</span></span><br><span class=\"line\"><span class=\"comment\"> * you&#x27;d like to remove the callback prior to destruction of the associated lifecycle.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If the Lifecycle is already &#123;<span class=\"doctag\">@link</span> Lifecycle.State#DESTROYED destroyed&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * when this method is called, the callback will not be added.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> owner The LifecycleOwner which controls when the callback should be invoked</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onBackPressedCallback The callback to add</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #onBackPressed()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressLint(&quot;LambdaLast&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addCallback</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner owner,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"meta\">@NonNull</span> OnBackPressedCallback onBackPressedCallback)</span> </span>&#123;</span><br><span class=\"line\">    Lifecycle lifecycle = owner.getLifecycle();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lifecycle.getCurrentState() == Lifecycle.State.DESTROYED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 注册 action2</span></span><br><span class=\"line\">    onBackPressedCallback.addCancellable(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> LifecycleOnBackPressedCancellable(lifecycle, onBackPressedCallback));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>onBackPressedCallback的注册委托给LifecycleOnBackPressedCancellable，同时，持有LifecycleOnBackPressedCancellable的实例引用，但反注册时，onBackPressedCallback调用cancel方法，通知LifecycleOnBackPressedCancellable实例反注册。也就是A 向C注册，其实是委托给B实现注册，反注册通过A持有B的引用，也由B负责完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleOnBackPressedCancellable</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleEventObserver</span>,</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">Cancellable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lifecycle mLifecycle;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> OnBackPressedCallback mOnBackPressedCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Cancellable mCurrentCancellable;</span><br><span class=\"line\"></span><br><span class=\"line\">    LifecycleOnBackPressedCancellable(<span class=\"meta\">@NonNull</span> Lifecycle lifecycle,</span><br><span class=\"line\">            <span class=\"meta\">@NonNull</span> OnBackPressedCallback onBackPressedCallback) &#123;</span><br><span class=\"line\">        mLifecycle = lifecycle;</span><br><span class=\"line\">        mOnBackPressedCallback = onBackPressedCallback;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 注册 action1</span></span><br><span class=\"line\">        lifecycle.addObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner source,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event == Lifecycle.Event.ON_START) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 实际注册</span></span><br><span class=\"line\">            mCurrentCancellable = addCancellableCallback(mOnBackPressedCallback);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event == Lifecycle.Event.ON_STOP) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Should always be non-null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCurrentCancellable != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mCurrentCancellable.cancel();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class=\"line\">            cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 反注册 action1</span></span><br><span class=\"line\">        mLifecycle.removeObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 反注册 action2</span></span><br><span class=\"line\">        mOnBackPressedCallback.removeCancellable(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCurrentCancellable != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 实际反注册</span></span><br><span class=\"line\">            mCurrentCancellable.cancel();</span><br><span class=\"line\">            mCurrentCancellable = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.activity.OnBackPressedDispatcher#addCancellableCallback</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Internal implementation of &#123;<span class=\"doctag\">@link</span> #addCallback(OnBackPressedCallback)&#125; that gives</span></span><br><span class=\"line\"><span class=\"comment\"> * access to the &#123;<span class=\"doctag\">@link</span> Cancellable&#125; that specifically removes this callback from</span></span><br><span class=\"line\"><span class=\"comment\"> * the dispatcher without relying on &#123;<span class=\"doctag\">@link</span> OnBackPressedCallback#remove()&#125; which</span></span><br><span class=\"line\"><span class=\"comment\"> * is what external developers should be using.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onBackPressedCallback The callback to add</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> a &#123;<span class=\"doctag\">@link</span> Cancellable&#125; which can be used to &#123;<span class=\"doctag\">@link</span> Cancellable#cancel() cancel&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * the callback and remove it from the set of OnBackPressedCallbacks.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class=\"comment\">/* synthetic access */</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\">Cancellable <span class=\"title\">addCancellableCallback</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> OnBackPressedCallback onBackPressedCallback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// start后，实际注册进callback列表</span></span><br><span class=\"line\">\t\tmOnBackPressedCallbacks.add(onBackPressedCallback);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 建立OnBackPressedCancellable实例 与onBackPressedCallback的双向引用并返回</span></span><br><span class=\"line\">    OnBackPressedCancellable cancellable = <span class=\"keyword\">new</span> OnBackPressedCancellable(onBackPressedCallback);</span><br><span class=\"line\">    onBackPressedCallback.addCancellable(cancellable);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cancellable;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OnBackPressedCancellable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cancellable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> OnBackPressedCallback mOnBackPressedCallback;</span><br><span class=\"line\">    OnBackPressedCancellable(OnBackPressedCallback onBackPressedCallback) &#123;</span><br><span class=\"line\">        mOnBackPressedCallback = onBackPressedCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// stop后，实际反注册</span></span><br><span class=\"line\">        mOnBackPressedCallbacks.remove(mOnBackPressedCallback);</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 断开引用</span></span><br><span class=\"line\">        mOnBackPressedCallback.removeCancellable(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"LifeCycle & LiveData源码剖析","date":"2022-02-14T12:33:46.000Z","_content":"\n![类图](https://s3.bmp.ovh/imgs/2022/02/c5d4136edbfe0f20.png)\n\n# 生命周期回调方法映射为事件，并派发给LifeCycle\n\n```java\nandroidx.fragment.app.FragmentActivity#onStart\n@Override\nprotected void onStart() {\n    super.onStart();\n    // ……\n    // NOTE: HC onStart goes here.\n    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);\n    mFragments.dispatchStart();\n}\n\nandroidx.lifecycle.LifecycleRegistry#handleLifecycleEvent\n/**\n * Sets the current state and notifies the observers.\n * <p>\n * Note that if the {@code currentState} is the same state as the last call to this method,\n * calling this method has no effect.\n *\n * @param event The event that was received\n */\npublic void handleLifecycleEvent(@NonNull Lifecycle.Event event) {\n    State next = getStateAfter(event);\n    moveToState(next);\n}\n\nprivate void moveToState(State next) {\n    if (mState == next) {\n        return;\n    }\n    mState = next;\n    if (mHandlingEvent || mAddingObserverCounter != 0) {\n        mNewEventOccurred = true;\n        // we will figure out what to do on upper level.\n        return;\n    }\n    mHandlingEvent = true;\n    sync();\n    mHandlingEvent = false;\n}\n\n// happens only on the top of stack (never in reentrance),\n// so it doesn't have to take in account parents\nprivate void sync() {\n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n    if (lifecycleOwner == null) {\n        throw new IllegalStateException(\"LifecycleOwner of this LifecycleRegistry is already\"\n                + \"garbage collected. It is too late to change lifecycle state.\");\n    }\n    while (!isSynced()) {\n        mNewEventOccurred = false;\n        // no need to check eldest for nullability, because isSynced does it for us.\n// State descends, such as RESUMED to STARTED\n        if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) {\n            backwardPass(lifecycleOwner);\n        }\n// State ascends, such at STARTED TO RESUMED\n        Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();\n        if (!mNewEventOccurred && newest != null\n                && mState.compareTo(newest.getValue().mState) > 0) {\n            forwardPass(lifecycleOwner);\n        }\n    }\n    mNewEventOccurred = false;\n}\n```\n\n![状态图](https://s3.bmp.ovh/imgs/2022/02/a70384d33bf36163.png)\n\n如果是状态降级，从尾部向头部遍历监听队列，如果是状态升级，从头部向尾部遍历监听队列。之所以如此区分是因为要保证FastSafeIterableMap的Invariant，但为什么要维持这个不变量呢？原则上，LifeCycleOwner 从ON_CREATED到ON_RESUMED，再到ON_CREATED是一种状态回退，监听回调顺序也要从向前到向后回退。FastSafeIterableMap 是一个map，同时每个Entry是一个双向链表，新加入元素插入尾部。\n\n```java\nandroidx.lifecycle.LifecycleRegistry#mObserverMap\n\n/**\n * Custom list that keeps observers and can handle removals / additions during traversal.\n *\n * Invariant: at any moment of time for observer1 & observer2:\n * if addition_order(observer1) < addition_order(observer2), then\n * state(observer1) >= state(observer2),\n */\nprivate FastSafeIterableMap<LifecycleObserver, ObserverWithState> mObserverMap =\n        new FastSafeIterableMap<>();\n```\n\n```java\nandroidx.lifecycle.LifecycleRegistry#backwardPass\n\nprivate void backwardPass(LifecycleOwner lifecycleOwner) {\n    Iterator<Entry<LifecycleObserver, ObserverWithState>> descendingIterator =\n            mObserverMap.descendingIterator();\n    while (descendingIterator.hasNext() && !mNewEventOccurred) {\n        Entry<LifecycleObserver, ObserverWithState> entry = descendingIterator.next();\n        ObserverWithState observer = entry.getValue();\n        while ((observer.mState.compareTo(mState) > 0 && !mNewEventOccurred\n                && mObserverMap.contains(entry.getKey()))) {\n            Event event = downEvent(observer.mState);\n            pushParentState(getStateAfter(event));\n            observer.dispatchEvent(lifecycleOwner, event);\n            popParentState();\n        }\n    }\n}\n```\n\n```java\nandroidx.lifecycle.LifecycleRegistry.ObserverWithState#dispatchEvent\nvoid dispatchEvent(LifecycleOwner owner, Event event) {\n    State newState = getStateAfter(event);\n    mState = min(mState, newState);\n    mLifecycleObserver.onStateChanged(owner, event);\n    mState = newState;\n}\n```\n\n```java\n/**\n * Class that can receive any lifecycle change and dispatch it to the receiver.\n * <p>\n * If a class implements both this interface and\n * {@link androidx.lifecycle.DefaultLifecycleObserver}, then\n * methods of {@code DefaultLifecycleObserver} will be called first, and then followed by the call\n * of {@link LifecycleEventObserver#onStateChanged(LifecycleOwner, Lifecycle.Event)}\n * <p>\n * If a class implements this interface and in the same time uses {@link OnLifecycleEvent}, then\n * annotations will be ignored.\n */\npublic interface LifecycleEventObserver extends LifecycleObserver {\n    /**\n     * Called when a state transition event happens.\n     *\n     * @param source The source of the event\n     * @param event The event\n     */\n    void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event);\n}\n```\n\nLiveData包 androidx.lifecycle.LiveData.LifecycleBoundObserver实现了这个接口，接下来看如何实现和使用\n\n# 监听注册\n\n```java\nandroidx.lifecycle.LiveData#observe\n/**\n * Adds the given observer to the observers list within the lifespan of the given\n * owner. The events are dispatched on the main thread. If LiveData already has data\n * set, it will be delivered to the observer.\n * <p>\n * The observer will only receive events if the owner is in {@link Lifecycle.State#STARTED}\n * or {@link Lifecycle.State#RESUMED} state (active).\n * <p>\n * If the owner moves to the {@link Lifecycle.State#DESTROYED} state, the observer will\n * automatically be removed.\n * <p>\n * When data changes while the {@code owner} is not active, it will not receive any updates.\n * If it becomes active again, it will receive the last available data automatically.\n * <p>\n * LiveData keeps a strong reference to the observer and the owner as long as the\n * given LifecycleOwner is not destroyed. When it is destroyed, LiveData removes references to\n * the observer &amp; the owner.\n * <p>\n * If the given owner is already in {@link Lifecycle.State#DESTROYED} state, LiveData\n * ignores the call.\n * <p>\n * If the given owner, observer tuple is already in the list, the call is ignored.\n * If the observer is already in the list with another owner, LiveData throws an\n * {@link IllegalArgumentException}.\n *\n * @param owner    The LifecycleOwner which controls the observer\n * @param observer The observer that will receive the events\n */\n@MainThread\npublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {\n    assertMainThread(\"observe\");\n    if (owner.getLifecycle().getCurrentState() == DESTROYED) {\n        // ignore\n        return;\n    }\n    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);\n    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n    if (existing != null && !existing.isAttachedTo(owner)) {\n        throw new IllegalArgumentException(\"Cannot add the same observer\"\n                + \" with different lifecycles\");\n    }\n    if (existing != null) {\n        return;\n    }\n    owner.getLifecycle().addObserver(wrapper);\n}\n```\n\nobserver 被封装为LifecycleBoundObserver，并注册到Lifecycle的监听队列里，当生命周期方法调用，并派发事件，最终androidx.lifecycle.LiveData.LifecycleBoundObserver#onStateChanged被调用，对于LiveData而言，它只关注两个方面：\n\n1. 如果是Lifecycle 已经destroy，那么自动移除双向监听（对LiveData，和对Lifecycle的监听）；\n2. 判断active & inActive 状态变更方向，如果是inactive →  active，说明Lifecycle重新回到前台，则将LiveData的value派发给监听者，提供数据刷新UI。\n\n```java\nclass LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver {\n    @NonNull\n    final LifecycleOwner mOwner;\n\n    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<? super T> observer) {\n        super(observer);\n        mOwner = owner;\n    }\n\n    @Override\n    public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) {\n        if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {\n\t\t\t\t\t\t// Remove double direction observers.\n            removeObserver(mObserver);\n            return;\n        }\n\t\t\t\t// Dispatch value if state changes from inactive to active.\n        activeStateChanged(shouldBeActive());\n    }\n}\n```\n\nLifecycleBoundObserver 注册观察Lifecycle时，需要处理注册时，错失的生命周期方法派发，将当前LifecycleBoundObserver的状态推送至Lifecycle一致。\n\n```java\nandroidx.lifecycle.LifecycleRegistry#addObserver\n@Override\npublic void addObserver(@NonNull LifecycleObserver observer) {\n    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\n    ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);\n    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);\n\n    if (previous != null) {\n        return;\n    }\n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n    if (lifecycleOwner == null) {\n        // it is null we should be destroyed. Fallback quickly\n        return;\n    }\n\n    boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;\n    State targetState = calculateTargetState(observer);\n    mAddingObserverCounter++;\n    while ((statefulObserver.mState.compareTo(targetState) < 0\n            && mObserverMap.contains(observer))) {\n        pushParentState(statefulObserver.mState);\n        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));\n        popParentState();\n        // mState / subling may have been changed recalculate\n        targetState = calculateTargetState(observer);\n    }\n\n    if (!isReentrance) {\n        // we do sync only on the top level.\n        sync();\n    }\n    mAddingObserverCounter--;\n}\n```\n\n# 数据变更\n\n```java\nandroidx.lifecycle.LiveData#setValue\n/**\n * Sets the value. If there are active observers, the value will be dispatched to them.\n * <p>\n * This method must be called from the main thread. If you need set a value from a background\n * thread, you can use {@link #postValue(Object)}\n *\n * @param value The new value\n */\n@MainThread\nprotected void setValue(T value) {\n    assertMainThread(\"setValue\");\n    mVersion++;\n    mData = value;\n    dispatchingValue(null);\n}\n```\n\n```java\nandroidx.lifecycle.LiveData#dispatchingValue\n@SuppressWarnings(\"WeakerAccess\") /* synthetic access */\nvoid dispatchingValue(@Nullable ObserverWrapper initiator) {\n    if (mDispatchingValue) {\n        mDispatchInvalidated = true;\n        return;\n    }\n    mDispatchingValue = true;\n    do {\n        mDispatchInvalidated = false;\n        if (initiator != null) {\n// Maxim: Lifecycle changes from inactive to active, but the data keeps still,\n// notify the corresponding observer in the lifecycle owner only.\n            considerNotify(initiator);\n            initiator = null;\n        } else {\n//Maxim:  The data source has changed, notify all observers.\n            for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =\n                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n                considerNotify(iterator.next().getValue());\n                if (mDispatchInvalidated) {\n                    break;\n                }\n            }\n        }\n    } while (mDispatchInvalidated);\n    mDispatchingValue = false;\n}\n```\n\n```java\nprivate void considerNotify(ObserverWrapper observer) {\n    if (!observer.mActive) {\n        return;\n    }\n    // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.\n    //\n    // we still first check observer.active to keep it as the entrance for events. So even if\n    // the observer moved to an active state, if we've not received that event, we better not\n    // notify for a more predictable notification order.\n\t\t// Maxim: Don't notify if the observer is not active, for lifecycle, it should\n\t\t// at leat be started or above(resumed).\n    if (!observer.shouldBeActive()) {\n        observer.activeStateChanged(false);\n        return;\n    }\n    if (observer.mLastVersion >= mVersion) {\n        return;\n    }\n    observer.mLastVersion = mVersion;\n    //noinspection unchecked\n    observer.mObserver.onChanged((T) mData);\n}\n```\n\n\n\n# 更多资料\n\nhttps://google-developer-training.github.io/android-developer-advanced-course-practicals/unit-6-working-with-architecture-components/lesson-14-room,-livedata,-viewmodel/14-1-a-room-livedata-viewmodel/14-1-a-room-livedata-viewmodel.html\n","source":"_posts/LifeCycle-LiveData源码剖析.md","raw":"---\ntitle: LifeCycle & LiveData源码剖析\ndate: 2022-02-14 20:33:46\ntags: LifeCycle, LiveData\n---\n\n![类图](https://s3.bmp.ovh/imgs/2022/02/c5d4136edbfe0f20.png)\n\n# 生命周期回调方法映射为事件，并派发给LifeCycle\n\n```java\nandroidx.fragment.app.FragmentActivity#onStart\n@Override\nprotected void onStart() {\n    super.onStart();\n    // ……\n    // NOTE: HC onStart goes here.\n    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);\n    mFragments.dispatchStart();\n}\n\nandroidx.lifecycle.LifecycleRegistry#handleLifecycleEvent\n/**\n * Sets the current state and notifies the observers.\n * <p>\n * Note that if the {@code currentState} is the same state as the last call to this method,\n * calling this method has no effect.\n *\n * @param event The event that was received\n */\npublic void handleLifecycleEvent(@NonNull Lifecycle.Event event) {\n    State next = getStateAfter(event);\n    moveToState(next);\n}\n\nprivate void moveToState(State next) {\n    if (mState == next) {\n        return;\n    }\n    mState = next;\n    if (mHandlingEvent || mAddingObserverCounter != 0) {\n        mNewEventOccurred = true;\n        // we will figure out what to do on upper level.\n        return;\n    }\n    mHandlingEvent = true;\n    sync();\n    mHandlingEvent = false;\n}\n\n// happens only on the top of stack (never in reentrance),\n// so it doesn't have to take in account parents\nprivate void sync() {\n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n    if (lifecycleOwner == null) {\n        throw new IllegalStateException(\"LifecycleOwner of this LifecycleRegistry is already\"\n                + \"garbage collected. It is too late to change lifecycle state.\");\n    }\n    while (!isSynced()) {\n        mNewEventOccurred = false;\n        // no need to check eldest for nullability, because isSynced does it for us.\n// State descends, such as RESUMED to STARTED\n        if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) {\n            backwardPass(lifecycleOwner);\n        }\n// State ascends, such at STARTED TO RESUMED\n        Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();\n        if (!mNewEventOccurred && newest != null\n                && mState.compareTo(newest.getValue().mState) > 0) {\n            forwardPass(lifecycleOwner);\n        }\n    }\n    mNewEventOccurred = false;\n}\n```\n\n![状态图](https://s3.bmp.ovh/imgs/2022/02/a70384d33bf36163.png)\n\n如果是状态降级，从尾部向头部遍历监听队列，如果是状态升级，从头部向尾部遍历监听队列。之所以如此区分是因为要保证FastSafeIterableMap的Invariant，但为什么要维持这个不变量呢？原则上，LifeCycleOwner 从ON_CREATED到ON_RESUMED，再到ON_CREATED是一种状态回退，监听回调顺序也要从向前到向后回退。FastSafeIterableMap 是一个map，同时每个Entry是一个双向链表，新加入元素插入尾部。\n\n```java\nandroidx.lifecycle.LifecycleRegistry#mObserverMap\n\n/**\n * Custom list that keeps observers and can handle removals / additions during traversal.\n *\n * Invariant: at any moment of time for observer1 & observer2:\n * if addition_order(observer1) < addition_order(observer2), then\n * state(observer1) >= state(observer2),\n */\nprivate FastSafeIterableMap<LifecycleObserver, ObserverWithState> mObserverMap =\n        new FastSafeIterableMap<>();\n```\n\n```java\nandroidx.lifecycle.LifecycleRegistry#backwardPass\n\nprivate void backwardPass(LifecycleOwner lifecycleOwner) {\n    Iterator<Entry<LifecycleObserver, ObserverWithState>> descendingIterator =\n            mObserverMap.descendingIterator();\n    while (descendingIterator.hasNext() && !mNewEventOccurred) {\n        Entry<LifecycleObserver, ObserverWithState> entry = descendingIterator.next();\n        ObserverWithState observer = entry.getValue();\n        while ((observer.mState.compareTo(mState) > 0 && !mNewEventOccurred\n                && mObserverMap.contains(entry.getKey()))) {\n            Event event = downEvent(observer.mState);\n            pushParentState(getStateAfter(event));\n            observer.dispatchEvent(lifecycleOwner, event);\n            popParentState();\n        }\n    }\n}\n```\n\n```java\nandroidx.lifecycle.LifecycleRegistry.ObserverWithState#dispatchEvent\nvoid dispatchEvent(LifecycleOwner owner, Event event) {\n    State newState = getStateAfter(event);\n    mState = min(mState, newState);\n    mLifecycleObserver.onStateChanged(owner, event);\n    mState = newState;\n}\n```\n\n```java\n/**\n * Class that can receive any lifecycle change and dispatch it to the receiver.\n * <p>\n * If a class implements both this interface and\n * {@link androidx.lifecycle.DefaultLifecycleObserver}, then\n * methods of {@code DefaultLifecycleObserver} will be called first, and then followed by the call\n * of {@link LifecycleEventObserver#onStateChanged(LifecycleOwner, Lifecycle.Event)}\n * <p>\n * If a class implements this interface and in the same time uses {@link OnLifecycleEvent}, then\n * annotations will be ignored.\n */\npublic interface LifecycleEventObserver extends LifecycleObserver {\n    /**\n     * Called when a state transition event happens.\n     *\n     * @param source The source of the event\n     * @param event The event\n     */\n    void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event);\n}\n```\n\nLiveData包 androidx.lifecycle.LiveData.LifecycleBoundObserver实现了这个接口，接下来看如何实现和使用\n\n# 监听注册\n\n```java\nandroidx.lifecycle.LiveData#observe\n/**\n * Adds the given observer to the observers list within the lifespan of the given\n * owner. The events are dispatched on the main thread. If LiveData already has data\n * set, it will be delivered to the observer.\n * <p>\n * The observer will only receive events if the owner is in {@link Lifecycle.State#STARTED}\n * or {@link Lifecycle.State#RESUMED} state (active).\n * <p>\n * If the owner moves to the {@link Lifecycle.State#DESTROYED} state, the observer will\n * automatically be removed.\n * <p>\n * When data changes while the {@code owner} is not active, it will not receive any updates.\n * If it becomes active again, it will receive the last available data automatically.\n * <p>\n * LiveData keeps a strong reference to the observer and the owner as long as the\n * given LifecycleOwner is not destroyed. When it is destroyed, LiveData removes references to\n * the observer &amp; the owner.\n * <p>\n * If the given owner is already in {@link Lifecycle.State#DESTROYED} state, LiveData\n * ignores the call.\n * <p>\n * If the given owner, observer tuple is already in the list, the call is ignored.\n * If the observer is already in the list with another owner, LiveData throws an\n * {@link IllegalArgumentException}.\n *\n * @param owner    The LifecycleOwner which controls the observer\n * @param observer The observer that will receive the events\n */\n@MainThread\npublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {\n    assertMainThread(\"observe\");\n    if (owner.getLifecycle().getCurrentState() == DESTROYED) {\n        // ignore\n        return;\n    }\n    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);\n    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n    if (existing != null && !existing.isAttachedTo(owner)) {\n        throw new IllegalArgumentException(\"Cannot add the same observer\"\n                + \" with different lifecycles\");\n    }\n    if (existing != null) {\n        return;\n    }\n    owner.getLifecycle().addObserver(wrapper);\n}\n```\n\nobserver 被封装为LifecycleBoundObserver，并注册到Lifecycle的监听队列里，当生命周期方法调用，并派发事件，最终androidx.lifecycle.LiveData.LifecycleBoundObserver#onStateChanged被调用，对于LiveData而言，它只关注两个方面：\n\n1. 如果是Lifecycle 已经destroy，那么自动移除双向监听（对LiveData，和对Lifecycle的监听）；\n2. 判断active & inActive 状态变更方向，如果是inactive →  active，说明Lifecycle重新回到前台，则将LiveData的value派发给监听者，提供数据刷新UI。\n\n```java\nclass LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver {\n    @NonNull\n    final LifecycleOwner mOwner;\n\n    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<? super T> observer) {\n        super(observer);\n        mOwner = owner;\n    }\n\n    @Override\n    public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) {\n        if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {\n\t\t\t\t\t\t// Remove double direction observers.\n            removeObserver(mObserver);\n            return;\n        }\n\t\t\t\t// Dispatch value if state changes from inactive to active.\n        activeStateChanged(shouldBeActive());\n    }\n}\n```\n\nLifecycleBoundObserver 注册观察Lifecycle时，需要处理注册时，错失的生命周期方法派发，将当前LifecycleBoundObserver的状态推送至Lifecycle一致。\n\n```java\nandroidx.lifecycle.LifecycleRegistry#addObserver\n@Override\npublic void addObserver(@NonNull LifecycleObserver observer) {\n    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\n    ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);\n    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);\n\n    if (previous != null) {\n        return;\n    }\n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n    if (lifecycleOwner == null) {\n        // it is null we should be destroyed. Fallback quickly\n        return;\n    }\n\n    boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;\n    State targetState = calculateTargetState(observer);\n    mAddingObserverCounter++;\n    while ((statefulObserver.mState.compareTo(targetState) < 0\n            && mObserverMap.contains(observer))) {\n        pushParentState(statefulObserver.mState);\n        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));\n        popParentState();\n        // mState / subling may have been changed recalculate\n        targetState = calculateTargetState(observer);\n    }\n\n    if (!isReentrance) {\n        // we do sync only on the top level.\n        sync();\n    }\n    mAddingObserverCounter--;\n}\n```\n\n# 数据变更\n\n```java\nandroidx.lifecycle.LiveData#setValue\n/**\n * Sets the value. If there are active observers, the value will be dispatched to them.\n * <p>\n * This method must be called from the main thread. If you need set a value from a background\n * thread, you can use {@link #postValue(Object)}\n *\n * @param value The new value\n */\n@MainThread\nprotected void setValue(T value) {\n    assertMainThread(\"setValue\");\n    mVersion++;\n    mData = value;\n    dispatchingValue(null);\n}\n```\n\n```java\nandroidx.lifecycle.LiveData#dispatchingValue\n@SuppressWarnings(\"WeakerAccess\") /* synthetic access */\nvoid dispatchingValue(@Nullable ObserverWrapper initiator) {\n    if (mDispatchingValue) {\n        mDispatchInvalidated = true;\n        return;\n    }\n    mDispatchingValue = true;\n    do {\n        mDispatchInvalidated = false;\n        if (initiator != null) {\n// Maxim: Lifecycle changes from inactive to active, but the data keeps still,\n// notify the corresponding observer in the lifecycle owner only.\n            considerNotify(initiator);\n            initiator = null;\n        } else {\n//Maxim:  The data source has changed, notify all observers.\n            for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =\n                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n                considerNotify(iterator.next().getValue());\n                if (mDispatchInvalidated) {\n                    break;\n                }\n            }\n        }\n    } while (mDispatchInvalidated);\n    mDispatchingValue = false;\n}\n```\n\n```java\nprivate void considerNotify(ObserverWrapper observer) {\n    if (!observer.mActive) {\n        return;\n    }\n    // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.\n    //\n    // we still first check observer.active to keep it as the entrance for events. So even if\n    // the observer moved to an active state, if we've not received that event, we better not\n    // notify for a more predictable notification order.\n\t\t// Maxim: Don't notify if the observer is not active, for lifecycle, it should\n\t\t// at leat be started or above(resumed).\n    if (!observer.shouldBeActive()) {\n        observer.activeStateChanged(false);\n        return;\n    }\n    if (observer.mLastVersion >= mVersion) {\n        return;\n    }\n    observer.mLastVersion = mVersion;\n    //noinspection unchecked\n    observer.mObserver.onChanged((T) mData);\n}\n```\n\n\n\n# 更多资料\n\nhttps://google-developer-training.github.io/android-developer-advanced-course-practicals/unit-6-working-with-architecture-components/lesson-14-room,-livedata,-viewmodel/14-1-a-room-livedata-viewmodel/14-1-a-room-livedata-viewmodel.html\n","slug":"LifeCycle-LiveData源码剖析","published":1,"updated":"2022-02-15T02:25:11.509Z","_id":"ckzmpikdk0000rgf9fm6p0u0f","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://s3.bmp.ovh/imgs/2022/02/c5d4136edbfe0f20.png\" alt=\"类图\"></p>\n<h1 id=\"生命周期回调方法映射为事件，并派发给LifeCycle\"><a href=\"#生命周期回调方法映射为事件，并派发给LifeCycle\" class=\"headerlink\" title=\"生命周期回调方法映射为事件，并派发给LifeCycle\"></a>生命周期回调方法映射为事件，并派发给LifeCycle</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentActivity#onStart</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">    <span class=\"comment\">// ……</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> HC onStart goes here.</span></span><br><span class=\"line\">    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class=\"line\">    mFragments.dispatchStart();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.lifecycle.LifecycleRegistry#handleLifecycleEvent</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Sets the current state and notifies the observers.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Note that if the &#123;<span class=\"doctag\">@code</span> currentState&#125; is the same state as the last call to this method,</span></span><br><span class=\"line\"><span class=\"comment\"> * calling this method has no effect.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> event The event that was received</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLifecycleEvent</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">    State next = getStateAfter(event);</span><br><span class=\"line\">    moveToState(next);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(State next)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mState == next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mState = next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHandlingEvent || mAddingObserverCounter != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        mNewEventOccurred = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// we will figure out what to do on upper level.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mHandlingEvent = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    sync();</span><br><span class=\"line\">    mHandlingEvent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// happens only on the top of stack (never in reentrance),</span></span><br><span class=\"line\"><span class=\"comment\">// so it doesn&#x27;t have to take in account parents</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sync</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lifecycleOwner == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;LifecycleOwner of this LifecycleRegistry is already&quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;garbage collected. It is too late to change lifecycle state.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isSynced()) &#123;</span><br><span class=\"line\">        mNewEventOccurred = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class=\"line\"><span class=\"comment\">// State descends, such as RESUMED to STARTED</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            backwardPass(lifecycleOwner);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">// State ascends, such at STARTED TO RESUMED</span></span><br><span class=\"line\">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            forwardPass(lifecycleOwner);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mNewEventOccurred = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://s3.bmp.ovh/imgs/2022/02/a70384d33bf36163.png\" alt=\"状态图\"></p>\n<p>如果是状态降级，从尾部向头部遍历监听队列，如果是状态升级，从头部向尾部遍历监听队列。之所以如此区分是因为要保证FastSafeIterableMap的Invariant，但为什么要维持这个不变量呢？原则上，LifeCycleOwner 从ON_CREATED到ON_RESUMED，再到ON_CREATED是一种状态回退，监听回调顺序也要从向前到向后回退。FastSafeIterableMap 是一个map，同时每个Entry是一个双向链表，新加入元素插入尾部。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LifecycleRegistry#mObserverMap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Custom list that keeps observers and can handle removals / additions during traversal.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Invariant: at any moment of time for observer1 &amp; observer2:</span></span><br><span class=\"line\"><span class=\"comment\"> * if addition_order(observer1) &lt; addition_order(observer2), then</span></span><br><span class=\"line\"><span class=\"comment\"> * state(observer1) &gt;= state(observer2),</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> FastSafeIterableMap&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LifecycleRegistry#<span class=\"function\">backwardPass</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">backwardPass</span><span class=\"params\">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =</span><br><span class=\"line\">            mObserverMap.descendingIterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class=\"line\">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();</span><br><span class=\"line\">        ObserverWithState observer = entry.getValue();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((observer.mState.compareTo(mState) &gt; <span class=\"number\">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class=\"line\">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class=\"line\">            Event event = downEvent(observer.mState);</span><br><span class=\"line\">            pushParentState(getStateAfter(event));</span><br><span class=\"line\">            observer.dispatchEvent(lifecycleOwner, event);</span><br><span class=\"line\">            popParentState();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LifecycleRegistry.ObserverWithState#<span class=\"function\">dispatchEvent</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchEvent</span><span class=\"params\">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class=\"line\">    State newState = getStateAfter(event);</span><br><span class=\"line\">    mState = min(mState, newState);</span><br><span class=\"line\">    mLifecycleObserver.onStateChanged(owner, event);</span><br><span class=\"line\">    mState = newState;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Class that can receive any lifecycle change and dispatch it to the receiver.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If a class implements both this interface and</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> androidx.lifecycle.DefaultLifecycleObserver&#125;, then</span></span><br><span class=\"line\"><span class=\"comment\"> * methods of &#123;<span class=\"doctag\">@code</span> DefaultLifecycleObserver&#125; will be called first, and then followed by the call</span></span><br><span class=\"line\"><span class=\"comment\"> * of &#123;<span class=\"doctag\">@link</span> LifecycleEventObserver#onStateChanged(LifecycleOwner, Lifecycle.Event)&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If a class implements this interface and in the same time uses &#123;<span class=\"doctag\">@link</span> OnLifecycleEvent&#125;, then</span></span><br><span class=\"line\"><span class=\"comment\"> * annotations will be ignored.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleEventObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Called when a state transition event happens.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> source The source of the event</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> event The event</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner source, <span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>LiveData包 androidx.lifecycle.LiveData.LifecycleBoundObserver实现了这个接口，接下来看如何实现和使用</p>\n<h1 id=\"监听注册\"><a href=\"#监听注册\" class=\"headerlink\" title=\"监听注册\"></a>监听注册</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LiveData#observe</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Adds the given observer to the observers list within the lifespan of the given</span></span><br><span class=\"line\"><span class=\"comment\"> * owner. The events are dispatched on the main thread. If LiveData already has data</span></span><br><span class=\"line\"><span class=\"comment\"> * set, it will be delivered to the observer.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * The observer will only receive events if the owner is in &#123;<span class=\"doctag\">@link</span> Lifecycle.State#STARTED&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * or &#123;<span class=\"doctag\">@link</span> Lifecycle.State#RESUMED&#125; state (active).</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If the owner moves to the &#123;<span class=\"doctag\">@link</span> Lifecycle.State#DESTROYED&#125; state, the observer will</span></span><br><span class=\"line\"><span class=\"comment\"> * automatically be removed.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * When data changes while the &#123;<span class=\"doctag\">@code</span> owner&#125; is not active, it will not receive any updates.</span></span><br><span class=\"line\"><span class=\"comment\"> * If it becomes active again, it will receive the last available data automatically.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * LiveData keeps a strong reference to the observer and the owner as long as the</span></span><br><span class=\"line\"><span class=\"comment\"> * given LifecycleOwner is not destroyed. When it is destroyed, LiveData removes references to</span></span><br><span class=\"line\"><span class=\"comment\"> * the observer &amp;amp; the owner.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If the given owner is already in &#123;<span class=\"doctag\">@link</span> Lifecycle.State#DESTROYED&#125; state, LiveData</span></span><br><span class=\"line\"><span class=\"comment\"> * ignores the call.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If the given owner, observer tuple is already in the list, the call is ignored.</span></span><br><span class=\"line\"><span class=\"comment\"> * If the observer is already in the list with another owner, LiveData throws an</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> IllegalArgumentException&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> owner    The LifecycleOwner which controls the observer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> observer The observer that will receive the events</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observe</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, <span class=\"meta\">@NonNull</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">&quot;observe&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ignore</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LifecycleBoundObserver wrapper = <span class=\"keyword\">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Cannot add the same observer&quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot; with different lifecycles&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    owner.getLifecycle().addObserver(wrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>observer 被封装为LifecycleBoundObserver，并注册到Lifecycle的监听队列里，当生命周期方法调用，并派发事件，最终androidx.lifecycle.LiveData.LifecycleBoundObserver#onStateChanged被调用，对于LiveData而言，它只关注两个方面：</p>\n<ol>\n<li>如果是Lifecycle 已经destroy，那么自动移除双向监听（对LiveData，和对Lifecycle的监听）；</li>\n<li>判断active &amp; inActive 状态变更方向，如果是inactive →  active，说明Lifecycle重新回到前台，则将LiveData的value派发给监听者，提供数据刷新UI。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleBoundObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">ObserverWrapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">GenericLifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> LifecycleOwner mOwner;</span><br><span class=\"line\"></span><br><span class=\"line\">    LifecycleBoundObserver(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(observer);</span><br><span class=\"line\">        mOwner = owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// Remove double direction observers.</span></span><br><span class=\"line\">            removeObserver(mObserver);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Dispatch value if state changes from inactive to active.</span></span><br><span class=\"line\">        activeStateChanged(shouldBeActive());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>LifecycleBoundObserver 注册观察Lifecycle时，需要处理注册时，错失的生命周期方法派发，将当前LifecycleBoundObserver的状态推送至Lifecycle一致。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LifecycleRegistry#addObserver</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class=\"line\">    ObserverWithState statefulObserver = <span class=\"keyword\">new</span> ObserverWithState(observer, initialState);</span><br><span class=\"line\">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lifecycleOwner == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// it is null we should be destroyed. Fallback quickly</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isReentrance = mAddingObserverCounter != <span class=\"number\">0</span> || mHandlingEvent;</span><br><span class=\"line\">    State targetState = calculateTargetState(observer);</span><br><span class=\"line\">    mAddingObserverCounter++;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class=\"number\">0</span></span><br><span class=\"line\">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class=\"line\">        pushParentState(statefulObserver.mState);</span><br><span class=\"line\">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class=\"line\">        popParentState();</span><br><span class=\"line\">        <span class=\"comment\">// mState / subling may have been changed recalculate</span></span><br><span class=\"line\">        targetState = calculateTargetState(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isReentrance) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// we do sync only on the top level.</span></span><br><span class=\"line\">        sync();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mAddingObserverCounter--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数据变更\"><a href=\"#数据变更\" class=\"headerlink\" title=\"数据变更\"></a>数据变更</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LiveData#setValue</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Sets the value. If there are active observers, the value will be dispatched to them.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * This method must be called from the main thread. If you need set a value from a background</span></span><br><span class=\"line\"><span class=\"comment\"> * thread, you can use &#123;<span class=\"doctag\">@link</span> #postValue(Object)&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value The new value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">&quot;setValue&quot;</span>);</span><br><span class=\"line\">    mVersion++;</span><br><span class=\"line\">    mData = value;</span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LiveData#dispatchingValue</span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class=\"comment\">/* synthetic access */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> ObserverWrapper initiator)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDispatchingValue) &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initiator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">// Maxim: Lifecycle changes from inactive to active, but the data keeps still,</span></span><br><span class=\"line\"><span class=\"comment\">// notify the corresponding observer in the lifecycle owner only.</span></span><br><span class=\"line\">            considerNotify(initiator);</span><br><span class=\"line\">            initiator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//Maxim:  The data source has changed, notify all observers.</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class=\"keyword\">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">                considerNotify(iterator.next().getValue());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class=\"line\">    <span class=\"comment\">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span></span><br><span class=\"line\">    <span class=\"comment\">// notify for a more predictable notification order.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Maxim: Don&#x27;t notify if the observer is not active, for lifecycle, it should</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// at leat be started or above(resumed).</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    observer.mLastVersion = mVersion;</span><br><span class=\"line\">    <span class=\"comment\">//noinspection unchecked</span></span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"更多资料\"><a href=\"#更多资料\" class=\"headerlink\" title=\"更多资料\"></a>更多资料</h1><p><a href=\"https://google-developer-training.github.io/android-developer-advanced-course-practicals/unit-6-working-with-architecture-components/lesson-14-room,-livedata,-viewmodel/14-1-a-room-livedata-viewmodel/14-1-a-room-livedata-viewmodel.html\">https://google-developer-training.github.io/android-developer-advanced-course-practicals/unit-6-working-with-architecture-components/lesson-14-room,-livedata,-viewmodel/14-1-a-room-livedata-viewmodel/14-1-a-room-livedata-viewmodel.html</a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><img src=\"https://s3.bmp.ovh/imgs/2022/02/c5d4136edbfe0f20.png\" alt=\"类图\"></p>\n<h1 id=\"生命周期回调方法映射为事件，并派发给LifeCycle\"><a href=\"#生命周期回调方法映射为事件，并派发给LifeCycle\" class=\"headerlink\" title=\"生命周期回调方法映射为事件，并派发给LifeCycle\"></a>生命周期回调方法映射为事件，并派发给LifeCycle</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.fragment.app.FragmentActivity#onStart</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">    <span class=\"comment\">// ……</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> HC onStart goes here.</span></span><br><span class=\"line\">    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class=\"line\">    mFragments.dispatchStart();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">androidx.lifecycle.LifecycleRegistry#handleLifecycleEvent</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Sets the current state and notifies the observers.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Note that if the &#123;<span class=\"doctag\">@code</span> currentState&#125; is the same state as the last call to this method,</span></span><br><span class=\"line\"><span class=\"comment\"> * calling this method has no effect.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> event The event that was received</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLifecycleEvent</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">    State next = getStateAfter(event);</span><br><span class=\"line\">    moveToState(next);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(State next)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mState == next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mState = next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHandlingEvent || mAddingObserverCounter != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        mNewEventOccurred = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// we will figure out what to do on upper level.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mHandlingEvent = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    sync();</span><br><span class=\"line\">    mHandlingEvent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// happens only on the top of stack (never in reentrance),</span></span><br><span class=\"line\"><span class=\"comment\">// so it doesn&#x27;t have to take in account parents</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sync</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lifecycleOwner == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;LifecycleOwner of this LifecycleRegistry is already&quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;garbage collected. It is too late to change lifecycle state.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isSynced()) &#123;</span><br><span class=\"line\">        mNewEventOccurred = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class=\"line\"><span class=\"comment\">// State descends, such as RESUMED to STARTED</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            backwardPass(lifecycleOwner);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">// State ascends, such at STARTED TO RESUMED</span></span><br><span class=\"line\">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            forwardPass(lifecycleOwner);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mNewEventOccurred = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://s3.bmp.ovh/imgs/2022/02/a70384d33bf36163.png\" alt=\"状态图\"></p>\n<p>如果是状态降级，从尾部向头部遍历监听队列，如果是状态升级，从头部向尾部遍历监听队列。之所以如此区分是因为要保证FastSafeIterableMap的Invariant，但为什么要维持这个不变量呢？原则上，LifeCycleOwner 从ON_CREATED到ON_RESUMED，再到ON_CREATED是一种状态回退，监听回调顺序也要从向前到向后回退。FastSafeIterableMap 是一个map，同时每个Entry是一个双向链表，新加入元素插入尾部。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LifecycleRegistry#mObserverMap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Custom list that keeps observers and can handle removals / additions during traversal.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Invariant: at any moment of time for observer1 &amp; observer2:</span></span><br><span class=\"line\"><span class=\"comment\"> * if addition_order(observer1) &lt; addition_order(observer2), then</span></span><br><span class=\"line\"><span class=\"comment\"> * state(observer1) &gt;= state(observer2),</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> FastSafeIterableMap&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LifecycleRegistry#<span class=\"function\">backwardPass</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">backwardPass</span><span class=\"params\">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =</span><br><span class=\"line\">            mObserverMap.descendingIterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class=\"line\">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();</span><br><span class=\"line\">        ObserverWithState observer = entry.getValue();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((observer.mState.compareTo(mState) &gt; <span class=\"number\">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class=\"line\">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class=\"line\">            Event event = downEvent(observer.mState);</span><br><span class=\"line\">            pushParentState(getStateAfter(event));</span><br><span class=\"line\">            observer.dispatchEvent(lifecycleOwner, event);</span><br><span class=\"line\">            popParentState();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LifecycleRegistry.ObserverWithState#<span class=\"function\">dispatchEvent</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchEvent</span><span class=\"params\">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class=\"line\">    State newState = getStateAfter(event);</span><br><span class=\"line\">    mState = min(mState, newState);</span><br><span class=\"line\">    mLifecycleObserver.onStateChanged(owner, event);</span><br><span class=\"line\">    mState = newState;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Class that can receive any lifecycle change and dispatch it to the receiver.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If a class implements both this interface and</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> androidx.lifecycle.DefaultLifecycleObserver&#125;, then</span></span><br><span class=\"line\"><span class=\"comment\"> * methods of &#123;<span class=\"doctag\">@code</span> DefaultLifecycleObserver&#125; will be called first, and then followed by the call</span></span><br><span class=\"line\"><span class=\"comment\"> * of &#123;<span class=\"doctag\">@link</span> LifecycleEventObserver#onStateChanged(LifecycleOwner, Lifecycle.Event)&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If a class implements this interface and in the same time uses &#123;<span class=\"doctag\">@link</span> OnLifecycleEvent&#125;, then</span></span><br><span class=\"line\"><span class=\"comment\"> * annotations will be ignored.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleEventObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Called when a state transition event happens.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> source The source of the event</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> event The event</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner source, <span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>LiveData包 androidx.lifecycle.LiveData.LifecycleBoundObserver实现了这个接口，接下来看如何实现和使用</p>\n<h1 id=\"监听注册\"><a href=\"#监听注册\" class=\"headerlink\" title=\"监听注册\"></a>监听注册</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LiveData#observe</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Adds the given observer to the observers list within the lifespan of the given</span></span><br><span class=\"line\"><span class=\"comment\"> * owner. The events are dispatched on the main thread. If LiveData already has data</span></span><br><span class=\"line\"><span class=\"comment\"> * set, it will be delivered to the observer.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * The observer will only receive events if the owner is in &#123;<span class=\"doctag\">@link</span> Lifecycle.State#STARTED&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * or &#123;<span class=\"doctag\">@link</span> Lifecycle.State#RESUMED&#125; state (active).</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If the owner moves to the &#123;<span class=\"doctag\">@link</span> Lifecycle.State#DESTROYED&#125; state, the observer will</span></span><br><span class=\"line\"><span class=\"comment\"> * automatically be removed.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * When data changes while the &#123;<span class=\"doctag\">@code</span> owner&#125; is not active, it will not receive any updates.</span></span><br><span class=\"line\"><span class=\"comment\"> * If it becomes active again, it will receive the last available data automatically.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * LiveData keeps a strong reference to the observer and the owner as long as the</span></span><br><span class=\"line\"><span class=\"comment\"> * given LifecycleOwner is not destroyed. When it is destroyed, LiveData removes references to</span></span><br><span class=\"line\"><span class=\"comment\"> * the observer &amp;amp; the owner.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If the given owner is already in &#123;<span class=\"doctag\">@link</span> Lifecycle.State#DESTROYED&#125; state, LiveData</span></span><br><span class=\"line\"><span class=\"comment\"> * ignores the call.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If the given owner, observer tuple is already in the list, the call is ignored.</span></span><br><span class=\"line\"><span class=\"comment\"> * If the observer is already in the list with another owner, LiveData throws an</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> IllegalArgumentException&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> owner    The LifecycleOwner which controls the observer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> observer The observer that will receive the events</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observe</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, <span class=\"meta\">@NonNull</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">&quot;observe&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ignore</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LifecycleBoundObserver wrapper = <span class=\"keyword\">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Cannot add the same observer&quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot; with different lifecycles&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    owner.getLifecycle().addObserver(wrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>observer 被封装为LifecycleBoundObserver，并注册到Lifecycle的监听队列里，当生命周期方法调用，并派发事件，最终androidx.lifecycle.LiveData.LifecycleBoundObserver#onStateChanged被调用，对于LiveData而言，它只关注两个方面：</p>\n<ol>\n<li>如果是Lifecycle 已经destroy，那么自动移除双向监听（对LiveData，和对Lifecycle的监听）；</li>\n<li>判断active &amp; inActive 状态变更方向，如果是inactive →  active，说明Lifecycle重新回到前台，则将LiveData的value派发给监听者，提供数据刷新UI。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleBoundObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">ObserverWrapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">GenericLifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> LifecycleOwner mOwner;</span><br><span class=\"line\"></span><br><span class=\"line\">    LifecycleBoundObserver(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(observer);</span><br><span class=\"line\">        mOwner = owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// Remove double direction observers.</span></span><br><span class=\"line\">            removeObserver(mObserver);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Dispatch value if state changes from inactive to active.</span></span><br><span class=\"line\">        activeStateChanged(shouldBeActive());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>LifecycleBoundObserver 注册观察Lifecycle时，需要处理注册时，错失的生命周期方法派发，将当前LifecycleBoundObserver的状态推送至Lifecycle一致。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LifecycleRegistry#addObserver</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class=\"line\">    ObserverWithState statefulObserver = <span class=\"keyword\">new</span> ObserverWithState(observer, initialState);</span><br><span class=\"line\">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lifecycleOwner == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// it is null we should be destroyed. Fallback quickly</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isReentrance = mAddingObserverCounter != <span class=\"number\">0</span> || mHandlingEvent;</span><br><span class=\"line\">    State targetState = calculateTargetState(observer);</span><br><span class=\"line\">    mAddingObserverCounter++;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class=\"number\">0</span></span><br><span class=\"line\">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class=\"line\">        pushParentState(statefulObserver.mState);</span><br><span class=\"line\">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class=\"line\">        popParentState();</span><br><span class=\"line\">        <span class=\"comment\">// mState / subling may have been changed recalculate</span></span><br><span class=\"line\">        targetState = calculateTargetState(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isReentrance) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// we do sync only on the top level.</span></span><br><span class=\"line\">        sync();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mAddingObserverCounter--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数据变更\"><a href=\"#数据变更\" class=\"headerlink\" title=\"数据变更\"></a>数据变更</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LiveData#setValue</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Sets the value. If there are active observers, the value will be dispatched to them.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * This method must be called from the main thread. If you need set a value from a background</span></span><br><span class=\"line\"><span class=\"comment\"> * thread, you can use &#123;<span class=\"doctag\">@link</span> #postValue(Object)&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value The new value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">&quot;setValue&quot;</span>);</span><br><span class=\"line\">    mVersion++;</span><br><span class=\"line\">    mData = value;</span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">androidx.lifecycle.LiveData#dispatchingValue</span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class=\"comment\">/* synthetic access */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> ObserverWrapper initiator)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDispatchingValue) &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initiator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">// Maxim: Lifecycle changes from inactive to active, but the data keeps still,</span></span><br><span class=\"line\"><span class=\"comment\">// notify the corresponding observer in the lifecycle owner only.</span></span><br><span class=\"line\">            considerNotify(initiator);</span><br><span class=\"line\">            initiator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//Maxim:  The data source has changed, notify all observers.</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class=\"keyword\">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">                considerNotify(iterator.next().getValue());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class=\"line\">    <span class=\"comment\">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span></span><br><span class=\"line\">    <span class=\"comment\">// notify for a more predictable notification order.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Maxim: Don&#x27;t notify if the observer is not active, for lifecycle, it should</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// at leat be started or above(resumed).</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    observer.mLastVersion = mVersion;</span><br><span class=\"line\">    <span class=\"comment\">//noinspection unchecked</span></span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"更多资料\"><a href=\"#更多资料\" class=\"headerlink\" title=\"更多资料\"></a>更多资料</h1><p><a href=\"https://google-developer-training.github.io/android-developer-advanced-course-practicals/unit-6-working-with-architecture-components/lesson-14-room,-livedata,-viewmodel/14-1-a-room-livedata-viewmodel/14-1-a-room-livedata-viewmodel.html\">https://google-developer-training.github.io/android-developer-advanced-course-practicals/unit-6-working-with-architecture-components/lesson-14-room,-livedata,-viewmodel/14-1-a-room-livedata-viewmodel/14-1-a-room-livedata-viewmodel.html</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/activity-transfer-detection/app_flow_chart.png","slug":"app_flow_chart.png","post":"ckr8n7ku9000035ci30yc2t6l","modified":0,"renderable":0},{"_id":"source/_posts/activity-transfer-detection/sequence_of_lifecycle_method_for_starting_activity.png","slug":"sequence_of_lifecycle_method_for_starting_activity.png","post":"ckr8n7ku9000035ci30yc2t6l","modified":0,"renderable":0},{"_id":"source/_posts/English-introduction/3d2515cb-3f1b-4fb0-bf37-d4235478d34a.webp","slug":"3d2515cb-3f1b-4fb0-bf37-d4235478d34a.webp","post":"ckshj98tv0000ddci7ccz6eba","modified":0,"renderable":0},{"_id":"source/_posts/English-introduction/455c9a21-0451-4256-94cc-3b79cec2d58a.webp","slug":"455c9a21-0451-4256-94cc-3b79cec2d58a.webp","post":"ckshj98tv0000ddci7ccz6eba","modified":0,"renderable":0},{"_id":"source/_posts/English-introduction/743839ae-8b54-43af-94a3-1efaa17dc711.webp","slug":"743839ae-8b54-43af-94a3-1efaa17dc711.webp","post":"ckshj98tv0000ddci7ccz6eba","modified":0,"renderable":0},{"_id":"source/_posts/English-introduction/9cbef091-ff03-487e-99d3-a638cab03662.webp","slug":"9cbef091-ff03-487e-99d3-a638cab03662.webp","post":"ckshj98tv0000ddci7ccz6eba","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ckshj98tv0000ddci7ccz6eba","tag_id":"ckszpoug100001qci6wif3d77","_id":"ckszpoug300011qci513m2lxq"},{"post_id":"cktr4p3jz00002tf9bs1438nj","tag_id":"cktr4p3k300012tf9eb5z4du9","_id":"cktr4p3k500022tf9av878aur"},{"post_id":"ckzmpikdk0000rgf9fm6p0u0f","tag_id":"ckzmpikdn0001rgf92nya682k","_id":"ckzmpikdp0002rgf99oe05gvf"}],"Tag":[{"name":"英语,自学,入门,指南,方法论,词典","_id":"ckszpoug100001qci6wif3d77"},{"name":"Fragment, FragmentManager源码","_id":"cktmzx6nq000485f9h5b756eo"},{"name":"ViewModel源码剖析, Android, ViewModel","_id":"cktr4p3k300012tf9eb5z4du9"},{"name":"LifeCycle, LiveData","_id":"ckzmpikdn0001rgf92nya682k"}]}}